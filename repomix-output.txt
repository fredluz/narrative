This file is a merged representation of the entire codebase, combined into a single document.
Generated by Repomix on: 2025-02-09T00:14:15.757Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
app.config.ts
app.json
app/_layout.tsx
app/+not-found.tsx
app/index.tsx
app/journal.tsx
app/landing.tsx
app/notification.tsx
app/quests.tsx
app/styles/global.js
app/types.ts
components/__tests__/__snapshots__/ThemedText-test.tsx.snap
components/__tests__/ThemedText-test.tsx
components/ChatInterface.tsx
components/Collapsible.tsx
components/ExternalLink.tsx
components/HapticTab.tsx
components/HelloWave.tsx
components/KanbanBoard.tsx
components/layouts/DesktopLayout.tsx
components/layouts/MobileLayout.tsx
components/ParallaxScrollView.tsx
components/QuestsOverview.tsx
components/TaskList.tsx
components/ThemedText.tsx
components/ThemedView.tsx
components/ui/HamburgerMenu.tsx
components/ui/IconSymbol.ios.tsx
components/ui/IconSymbol.tsx
components/ui/LoadingSpinner.tsx
components/ui/SettingsButton.tsx
components/ui/TabBarBackground.ios.tsx
components/ui/TabBarBackground.tsx
constants/Colors.ts
contexts/QuestUpdateContext.tsx
contexts/SupabaseContext.tsx
contexts/ThemeContext.tsx
hooks/useChatData.ts
hooks/useColorScheme.web.ts
hooks/useThemeColor.ts
lib/supabase.ts
package.json
README.md
scripts/reset-project.js
services/questsService.ts
services/tasksService.ts
tsconfig.json
types/quest.ts
utils/dateFormatters.ts

================================================================
Files
================================================================

================
File: .gitignore
================
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local


# typescript
*.tsbuildinfo

app-example

================
File: app.config.ts
================
import {config} from 'dotenv';

config({path: '.env.local'});

export default {
  expo: {
    name: "QuestLog",
    slug: "questlog",
    version: "1.0.0",
    extra: {
      supabaseUrl: process.env.EXPO_PUBLIC_SUPABASE_URL,
      supabaseAnonKey: process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY,
    },
  },
};

================
File: app.json
================
{
  "expo": {
    "name": "QuestLog",
    "slug": "QuestLog",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "myapp",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      }
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff"
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    }
  }
}

================
File: app/_layout.tsx
================
import { Stack } from 'expo-router';
import * as SplashScreen from 'expo-splash-screen';
import { useCallback } from 'react';
import { View, Text } from 'react-native';
import { useFonts, Inter_400Regular, Inter_700Bold } from '@expo-google-fonts/inter';
import { Poppins_400Regular, Poppins_700Bold } from '@expo-google-fonts/poppins';
import { ThemeProvider as AppThemeProvider } from '@/contexts/ThemeContext';
import { SupabaseProvider, useSupabase } from '@/contexts/SupabaseContext';
import { QuestUpdateProvider } from '@/contexts/QuestUpdateContext';
import styles from './styles/global';

// Keep the splash screen visible while we fetch resources
SplashScreen.preventAutoHideAsync();

function RootLayoutContent() {
  const { isLoading: isSupabaseLoading } = useSupabase();
  const [fontsLoaded] = useFonts({
    Inter_400Regular,
    Inter_700Bold,
    Poppins_400Regular,
    Poppins_700Bold,
  });

  const onLayoutRootView = useCallback(async () => {
    if (fontsLoaded && !isSupabaseLoading) {
      await SplashScreen.hideAsync();
    }
  }, [fontsLoaded, isSupabaseLoading]);

  if (!fontsLoaded || isSupabaseLoading) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#181818' }}>
        <Text style={{ color: '#fff' }}>Loading...</Text>
      </View>
    );
  }

  return (
    <View style={{ flex: 1 }} onLayout={onLayoutRootView}>
      <AppThemeProvider>
        <QuestUpdateProvider>
          <Stack
            screenOptions={{
              headerShown: false,
              contentStyle: { backgroundColor: '#181818' },
            }}
          >
            <Stack.Screen name="index" options={{ headerShown: false }} />
            <Stack.Screen name="landing" options={{ headerShown: false }} />
            <Stack.Screen name="quests" options={{ headerShown: false }} />
          </Stack>
        </QuestUpdateProvider>
      </AppThemeProvider>
    </View>
  );
}

export default function RootLayout() {
  return (
    <SupabaseProvider>
      <RootLayoutContent />
    </SupabaseProvider>
  );
}

================
File: app/+not-found.tsx
================
import { Link, Stack } from 'expo-router';
import { StyleSheet } from 'react-native';

import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';

export default function NotFoundScreen() {
  return (
    <>
      <Stack.Screen options={{ title: 'Oops!' }} />
      <ThemedView style={styles.container}>
        <ThemedText type="title">This screen doesn't exist.</ThemedText>
        <Link href="/" style={styles.link}>
          <ThemedText type="link">Go to home screen!</ThemedText>
        </Link>
      </ThemedView>
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
});

================
File: app/index.tsx
================
import { Redirect } from 'expo-router';

export default function Index() {
  return <Redirect href="/landing" />;
}

================
File: app/journal.tsx
================
import React, { useState, useEffect } from 'react';
import {
  View,
  ScrollView,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  Platform,
  KeyboardAvoidingView,
  SafeAreaView,
  Dimensions
} from 'react-native';
import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import { useTheme } from '@/contexts/ThemeContext'; // Import useTheme
import { IconSymbol } from '@/components/ui/IconSymbol';

// Mock data for journal entries (replace with actual data fetching)
interface JournalEntry {
  date: string; // YYYY-MM-DD format
  userEntry: string;
  aiGeneratedEntry: string;
}

const getMockJournalEntries = (): JournalEntry[] => {
  const today = new Date();
  const entries: JournalEntry[] = [];

  for (let i = -6; i <= 0; i++) { // Last 7 days, including today
    const date = new Date(today);
    date.setDate(today.getDate() + i);
    const dateString = date.toISOString().split('T')[0];

    let userEntry = '';
    let aiGeneratedEntry = `AI summary for ${dateString}.`;
    if (i === -2) {
      userEntry = "I felt really productive today! Finished the Kanban board UI and started working on the chat integration.";
      aiGeneratedEntry = "[SILVERHAND]: Not bad, samurai. You're crushing it with that UI work. Keep pushing those boundaries and stick it to the corporate code.";
    } else if (i === -5) {
      userEntry = "[NO USER ENTRY]";
      aiGeneratedEntry = "[SILVERHAND]: Wake the fuck up, samurai. Can't build digital revolution by staring at blank screens. Time to make some noise.";
    } else if (i === 0) {
        userEntry = "Today, I missed the deadline and it was a big bummer. I also forgot to plan today, so I feel lost";
        aiGeneratedEntry = "[SILVERHAND]: Listen up - deadlines are just corpo bullshit anyway. Tomorrow's another day to raise hell. Get your shit together and show them what you're made of.";
    }

    entries.push({
      date: dateString,
      userEntry,
      aiGeneratedEntry,
    });
  }
  return entries;
};


const JournalScreen: React.FC = () => {
  const { themeColor } = useTheme(); // Use the themeColor
  const [entries, setEntries] = useState<JournalEntry[]>([]);
  const [selectedDate, setSelectedDate] = useState<string | null>(null);
  const [userEntry, setUserEntry] = useState<string>('');
  const [isEditing, setIsEditing] = useState<boolean>(false);
  const [isNewEntry, setIsNewEntry] = useState<boolean>(false);
  const windowHeight = Dimensions.get('window').height;


  useEffect(() => {
    // Replace with actual data fetching from your backend/local storage
    const fetchedEntries = getMockJournalEntries();
    setEntries(fetchedEntries);

    // Set today's date as the initially selected date
    const today = new Date().toISOString().split('T')[0];
    setSelectedDate(today);

    // Load the user entry for today
    const todaysEntry = fetchedEntries.find((entry) => entry.date === today);
    setUserEntry(todaysEntry?.userEntry || '');
  }, []);

  const handleDateSelect = (date: string) => {
    setSelectedDate(date);
    const selectedEntry = entries.find((entry) => entry.date === date);
    setUserEntry(selectedEntry?.userEntry || '');
    setIsEditing(false); // Exit edit mode when switching dates
    setIsNewEntry(false);
  };

  const handleSaveEntry = () => {
    // Replace with actual data saving to your backend/local storage
    if (selectedDate) {
      const updatedEntries = entries.map((entry) =>
        entry.date === selectedDate ? { ...entry, userEntry } : entry
      );

      if (isNewEntry) { //add new entry to entries array
        updatedEntries.push({
            date: selectedDate,
            userEntry,
            aiGeneratedEntry: 'AI summary will appear after saving.'
        })
      }
      setEntries(updatedEntries);
      setIsEditing(false);
      setIsNewEntry(false)
      console.log('Saving entry:', { date: selectedDate, userEntry });
    }
  };

  const handleNewEntry = () => {
    setIsEditing(true)
    setIsNewEntry(true)
    setUserEntry('');
    const today = new Date().toISOString().split('T')[0];
    setSelectedDate(today);
  }

  const selectedEntry = selectedDate ? entries.find((entry) => entry.date === selectedDate) : null;
  const isDarkColor = (color: string) => {
    const hex = color.replace('#', '');
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    return brightness < 128;
  };

  const textColor = isDarkColor(themeColor) ? '#fff' : '#000';


  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: '#181818', height: windowHeight }}>
        <ThemedView style={[styles.container, { backgroundColor: '#181818', height: windowHeight }]}  >
            <View style={styles.header}>
                <ThemedText type="title">Journal</ThemedText>
                <TouchableOpacity style={[styles.newEntryButton, {backgroundColor: themeColor}]} onPress={handleNewEntry}>
                <IconSymbol name="plus" size={20} color={textColor} />
                <ThemedText style={[styles.newEntryButtonText, {color: textColor}]}>New Entry</ThemedText>
                </TouchableOpacity>
            </View>

            <View style={styles.contentContainer}>
                <ScrollView
                horizontal
                showsHorizontalScrollIndicator={false}
                contentContainerStyle={styles.dateList}
                >
                {entries.map((entry) => (
                    <TouchableOpacity
                    key={entry.date}
                    style={[
                        styles.dateButton,
                        selectedDate === entry.date && { backgroundColor: themeColor },
                    ]}
                    onPress={() => handleDateSelect(entry.date)}
                    >
                    <ThemedText style={[styles.dateText, selectedDate === entry.date && { color: textColor } ]}>
                        {entry.date}
                    </ThemedText>
                    </TouchableOpacity>
                ))}
                </ScrollView>

                <ThemedView style={[styles.entryContainer, { borderColor: themeColor, borderWidth: 2, backgroundColor: '#333333' } ]}>
                {selectedEntry ? (
                    <ScrollView style={styles.entryScrollView} >
                        {isEditing ? (
                            <KeyboardAvoidingView
                            behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
                            style={{ flex: 1 }}
                            >
                            <TextInput
                                style={[styles.entryInput, {color: textColor}]}
                                multiline
                                value={userEntry}
                                onChangeText={setUserEntry}
                                placeholder="Write your entry..."
                                placeholderTextColor="#AAA"
                            />
                            </KeyboardAvoidingView>
                        ) : (
                            <>
                            <ThemedText style={styles.entryText}>
                                {selectedEntry.userEntry || 'No personal entry for this day.'}
                            </ThemedText>
                            <ThemedText style={styles.aiEntryText}>
                                {selectedEntry.aiGeneratedEntry}
                            </ThemedText>
                            </>
                        )}
                    </ScrollView>
                ) : (
                    <ThemedText style={styles.noEntryText}>Select a date to view the entry.</ThemedText>
                )}

                {!isEditing && selectedEntry ? (
                    <TouchableOpacity
                    style={[styles.editButton, {backgroundColor: themeColor }]}
                    onPress={() => setIsEditing(true)}
                    >
                    <IconSymbol name="pencil" size={20} color={textColor} />
                    <ThemedText style={[styles.buttonText, {color: textColor}]}>Edit Entry</ThemedText>
                    </TouchableOpacity>
                ) : isEditing ? (
                    <TouchableOpacity
                    style={[styles.saveButton, {backgroundColor: themeColor}]}
                    onPress={handleSaveEntry}
                    >
                    <IconSymbol name="checkmark" size={20} color={textColor} />
                    <ThemedText style={[styles.buttonText, {color: textColor}]}>Save Entry</ThemedText>
                    </TouchableOpacity>
                ) : null}
              </ThemedView>
            </View>
        </ThemedView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  contentContainer: {
    flex: 1,
  },
  dateList: {
    flexDirection: 'row',
    paddingBottom: 10,
  },
  dateButton: {
    paddingHorizontal: 15,
    paddingVertical: 10,
    marginRight: 10,
    borderRadius: 20,
    backgroundColor: '#444', // Default date button color
  },
  dateText: {
    fontSize: 16,
    color: '#FFF',
  },
  entryContainer: {
    flex: 1,
    borderRadius: 12,
    padding: 16,
    marginTop: 10,
    marginBottom: 20,
    backgroundColor: '#333'
  },
  entryScrollView:{
    flex: 1
  },
  entryText: {
    fontSize: 16,
    color: '#FFF',
    marginBottom: 20,
    fontFamily: 'Inter_400Regular',
  },
  aiEntryText: {
    fontSize: 14,
    color: '#AAA',
    fontStyle: 'italic',
    fontFamily: 'Inter_400Regular',
  },
  noEntryText: {
    fontSize: 16,
    color: '#888',
    textAlign: 'center',
    marginTop: 20,
    fontFamily: 'Inter_400Regular',
  },
  entryInput: {
    flex: 1,
    fontSize: 16,
    color: '#FFF',
    fontFamily: 'Inter_400Regular',
    minHeight: 250,
    textAlignVertical: 'top',
  },
  editButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 10,
    borderRadius: 20,
    marginTop: 10,
    backgroundColor: '#007BFF', // Edit button color
  },
  saveButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 10,
    borderRadius: 20,
    marginTop: 10,
     // Save button color
  },
  buttonText: {
    color: 'white',
    marginLeft: 8,
    fontSize: 16,
    fontFamily: 'Inter_700Bold',
  },
    newEntryButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 15,
    paddingVertical: 10,
    borderRadius: 20,
  },
  newEntryButtonText: {
    marginLeft: 8,
    fontSize: 16,
    fontFamily: 'Inter_700Bold',
  }
});

export default JournalScreen;

================
File: app/landing.tsx
================
import React from 'react';
import { useWindowDimensions, Platform } from 'react-native';
import { MobileLayout } from '@/components/layouts/MobileLayout';
import { DesktopLayout } from '@/components/layouts/DesktopLayout';

export default function HomeScreen() {
  const { width } = useWindowDimensions();
  const isMobile = Platform.OS === 'ios' || Platform.OS === 'android' || width < 768;

  return isMobile ? <MobileLayout /> : <DesktopLayout />;
}

================
File: app/notification.tsx
================
/*import React from 'react';
import { View } from 'react-native';
import { ChatInterface } from '@/components/ChatInterface';
import { useTheme } from '@/contexts/ThemeContext';
import styles from './styles/global';

export default function NotificationScreen() {
  const { themeColor } = useTheme();
  const recentMessages = [
    { sender: "Batcomputer", message: "Fred, today's your last day to get your medication refilled." },
    { sender: "Batcomputer", message: "The pharmacy closes at 3PM, so you've got 5 hours."},
    { sender: "You", message: "I don't feel like going out right now." },
    { sender: "Batcomputer", message: "Then I'll set a reminder for after lunch." },
    { sender: "Batcomputer", message: "Please make sure to get this done, you know how much better you feel when medicated." },
  ];

  return (
    <View style={[styles.container, { backgroundColor: '#181818' }]}>
      <ChatInterface themeColor={themeColor} recentMessages={recentMessages} />
    </View>
  );
}
*/

================
File: app/quests.tsx
================
import React from 'react';
import { QuestsOverview } from '@/components/QuestsOverview';
import { useRouter } from 'expo-router';
import { useQuests } from '@/services/questsService';
import { useQuestUpdate } from '@/contexts/QuestUpdateContext';

export default function QuestsScreen() {
  const router = useRouter();
  const { quests, setQuestAsMain, mainQuest } = useQuests();
  const { triggerUpdate } = useQuestUpdate();

  const handleQuestSelect = async (questId: number) => {
    await setQuestAsMain(questId);
    triggerUpdate(); // Mark that an update is needed
  };

  return (
    <QuestsOverview 
      onSelectQuest={handleQuestSelect} 
      quests={quests} 
      currentMainQuest={mainQuest}
    />
  );
}

================
File: app/styles/global.js
================
import { StyleSheet, Platform } from 'react-native';

/**
 * A refined dark theme leveraging subtle gradients, rounded corners, 
 * modern font pairings, soft shadows, and increased spacing to improve 
 * readability and visual hierarchy. 
 * 
 * Note: 
 * - For gradient backgrounds, consider using libraries such as 
 *   "react-native-linear-gradient" or "expo-linear-gradient" and 
 *   wrapping relevant components accordingly.
 * - For animations (hover, loading, transitions), consider using
 *   React Native's Animated API or third-party libraries like
 *   "react-native-reanimated" or Lottie for more advanced Interactions.
 */
const styles = StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: Platform.select({
      ios: 'column',
      android: 'column',
      default: 'row'
    }),
    backgroundColor: '#1E1E1E', // Base dark background
    padding: Platform.select({
      ios: 10,
      android: 10,
      default: 16
    }),               // Increased padding for more whitespace
  },
  column: {
    flex: 1,
    marginHorizontal: 8,       // Slightly larger horizontal margin
    height: '100%',
  },
  chatCard: {
    flex: 1,
    padding: 16,
    backgroundColor: '#333',
    borderRadius: 12,          // Subtle rounded corners
    margin: Platform.select({
      ios: 10,
      android: 10,
      default: 0
    }),
    // Soft shadow for depth
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3,
  },
  chatScroll: {
    flex: 1,
  },
  leftColumn: {
    flex: 1,
    marginRight: 10,
  },
  rightColumn: {
    flex: 1,
    flexDirection: 'column',
  },
  chatContainer: {
    flex: 1,
    marginBottom: 10,
  },
  mainQuestContainer: {
    flex: 2,
    marginBottom: 10,
  },
  mainQuestCard: {
    padding: 20,
    backgroundColor: '#222',
    borderRadius: 16,
    // Slightly stronger shadow for main quest
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 6,
    elevation: 4,
  },

  // Modern chat bubble styling
  userMessage: {
    alignSelf: 'flex-end',
    backgroundColor: '#007BFF', // Accent color (can be customized)
    padding: 12,
    paddingHorizontal: 20, // Increased horizontal padding
    borderRadius: 16,
    marginVertical: 5,
    maxWidth: '75%',
    marginHorizontal: 16, // Increased horizontal margin
    // Font recommendations
    fontFamily: 'Inter_400Regular', // Example UI font
  },
  aiMessage: {
    alignSelf: 'flex-start',
    backgroundColor: '#444',
    padding: 12,
    paddingHorizontal: 20, // Increased horizontal padding
    borderRadius: 16,
    marginVertical: 5,
    maxWidth: '75%',
    marginHorizontal: 8, // Increased horizontal margin
    // Font recommendations
    fontFamily: 'Inter_400Regular', // Example UI font
  },
  messageSender: {
    fontWeight: 'bold',
    color: '#FFF',
    fontFamily: 'Poppins_700Bold', // Example heading font
  },
  messageText: {
    color: '#FFF',
    fontFamily: 'Inter_400Regular',
  },
  chatMessage: {
    color: '#FFF',
    fontStyle: 'italic',
    fontFamily: 'Inter_400Regular',
  },

  // Kanban-related styles
  kanbanTaskCard: {
    padding: 10,
    backgroundColor: '#333',
    marginVertical: 5,
    borderRadius: 12,
    // Soft shadow
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3,
  },
  mainQuestTitle: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#FFF',
    marginBottom: 10,
    fontFamily: 'Poppins_700Bold',
  },
  kanbanContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 10,
  },
  kanbanColumn: {
    flex: 1,
    marginHorizontal: 5,
  },
  kanbanTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#AAA',
    fontFamily: 'Poppins_700Bold',
  },
  kanbanTask: {
    fontSize: 14,
    color: '#CCC',
    marginVertical: 3,
    fontFamily: 'Inter_400Regular',
  },

  // Task-related styles
  taskContainer: {
    flex: 1,
    marginBottom: 10,
  },
  taskCard: {
    padding: 15,
    backgroundColor: '#444',
    marginBottom: 10,
    borderRadius: 12,
    // Soft shadow
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3,
  },
  cardTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFF',
    marginBottom: 5,
    fontFamily: 'Poppins_700Bold',
  },
  cardDetails: {
    fontSize: 14,
    color: '#BBB',
    marginBottom: 5,
    fontFamily: 'Inter_400Regular',
  },
  cardQuest: {
    color: '#FFF',
    fontSize: 14,
    fontStyle: 'italic',
    fontFamily: 'Inter_400Regular',
  },

  // Chat input & theme selector
  chatInput: {
    backgroundColor: '#222',
    color: 'white',
    marginVertical: 10,
    padding: 10,
    borderRadius: 12,
    fontFamily: 'Inter_400Regular',
  },
  themeSelector: {
    position: 'absolute',
    top: 10,
    left: 10,
    flexDirection: 'row',
    alignItems: 'center',
  },
  gearIcon: {
    marginRight: 5,
    color: 'white',
  },
  colorInput: {
    backgroundColor: '#222',
    color: 'white',
    padding: 5,
    borderRadius: 12,
    fontFamily: 'Inter_400Regular',
  },

  // Task list & toggles
  taskListContainer: {
    flex: 1,
    alignItems: 'center',
    marginTop: 10,
  },
  toggleButton: {
    backgroundColor: '#444',
    padding: 12,
    borderRadius: 12,
    marginBottom: 10,
    // Soft shadow
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 2,
  },
  toggleButtonText: {
    color: 'white',
    fontSize: 16,
    fontFamily: 'Inter_400Regular',
  },

  // Mobile-specific styles
  mobileHeader: {
    height: 50,
    backgroundColor: '#222',
    justifyContent: 'center',
    alignItems: 'center',
    borderBottomWidth: 1,
    borderBottomColor: '#444',
  },
  mobileHeaderText: {
    color: '#FFF',
    fontSize: 20,
    fontWeight: 'bold',
  },
  mobileContent: {
    flex: 1,
    padding: 10,
  },
  mobileNavigation: {
    height: 60,
    backgroundColor: '#222',
    borderTopWidth: 1,
    borderTopColor: '#333',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 100,
    position: 'relative',
  },
  mobileNavButton: {
    padding: 10,
    borderRadius: 8,
    minWidth: 80,
    alignItems: 'center',
  },
  mobileNavButtonActive: {
    backgroundColor: '#444',
  },
  mobileNavText: {
    color: '#FFF',
    fontSize: 14,
  },
  placeholderText: {
    color: '#888',
    fontSize: 16,
    textAlign: 'center',
    marginTop: 20,
  },
  mobileNavButton: {
    flex: 1,
    padding: 10,
    alignItems: 'center',
    borderRadius: 8,
  },
  mobileNavButtonActive: {
    backgroundColor: '#333',
  },
  mobileNavText: {
    color: 'white',
    fontSize: 16,
  },

  customChatContainer: {
    flex: 1,
    margin: 10,
    backgroundColor: '#333',
    borderRadius: 12,
    borderWidth: 2,
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.25,
    shadowRadius: 8,
    elevation: 5,
  },
  
  chatHeader: {
    padding: 16,
    backgroundColor: '#2A2A2A',
    borderBottomWidth: 1,
    borderBottomColor: '#444',
  },

  hamburgerButton: {
    width: Platform.select({ ios: 40, android: 40, default: 48 }),
    height: Platform.select({ ios: 40, android: 40, default: 48 }),
    borderRadius: 24,
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 5,
  },
  hamburgerButtonMobile: {
    backgroundColor: 'transparent',
    shadowOpacity: 0,
  },
  hamburgerButtonPressed: {
    opacity: 0.8,
    transform: [{ scale: 0.97 }],
  },

  viewAllQuests: {
    padding: 10,
    borderRadius: 8,
    marginVertical: 10,
    alignItems: 'center',
  },
  viewAllQuestsText: {
    fontSize: 14,
    fontWeight: 'bold',
    fontFamily: 'Inter_700Bold',
  },

  questTasksContainer: {
    marginTop: 20,
    paddingTop: 20,
    borderTopWidth: 1,
    borderTopColor: '#444',
  },

  setMainQuestButton: {
    padding: 8,
    borderRadius: 8,
    marginLeft: 10,
  },
  setMainQuestButtonText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: 'bold',
    fontFamily: 'Inter_700Bold',
  },

  desktopHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 20,
    backgroundColor: '#181818',
    borderBottomWidth: 1,
    borderBottomColor: '#333',
  },
  desktopHeaderText: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#fff',
  },
  errorText: {
    color: '#FF4444',
    textAlign: 'center',
    padding: 20,
  },
  
  kanbanContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
    gap: 8,
  },
  kanbanColumn: {
    flex: 1,
    gap: 8,
  },
  kanbanTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  kanbanTaskCard: {
    padding: 8,
    backgroundColor: '#333',
  },
  kanbanTask: {
    color: '#fff',
    fontSize: 14,
  },
  errorText: {
    color: '#FF4444',
    textAlign: 'center',
    padding: 20,
    fontSize: 16,
  },
  cardQuest: {
    color: '#aaa',
    fontSize: 14,
    marginTop: 4,
  },
  statusTimestamp: {
    color: '#FFF',
    fontSize: 12,
    fontFamily: 'Inter_700Bold',
    marginBottom: 5,
  },
});

export default styles;

================
File: app/types.ts
================
export interface BaseEntity {
  id: number;
  created_at: string;
  updated_at: string;
  tags?: string[];
}

export interface Task extends BaseEntity {
  title: string;
  description?: string;
  scheduled_for: string;  // Changed from scheduledFor
  location: string;
  quest_id: number;      // Changed from questId
  deadline?: string;
  status: 'ToDo' | 'InProgress' | 'Done';
  quest?: Quest;         // For joined data
}

export interface JournalEntry extends BaseEntity {
  title: string;
  userEntry: string;
  aiAnalysis: string;
}

export interface QuestStatus extends BaseEntity {
  message: string;
  timestamp: string;
  questId: number;
}

export interface Quest extends BaseEntity {
  title: string;
  tagline: string;
  is_main: boolean;  // Changed from isMain
  status: 'Active' | 'On-Hold' | 'Completed';
  questStatus?: string;
  currentStatus?: QuestStatus;
  tasks?: Task[];  // Added as optional since it's a joined field
  analysis?: string;
  parent_quest_id?: number;  // Changed from parentQuestId
  start_date?: string;  // Changed from startDate
  end_date?: string;   // Changed from endDate
  StatusHistory?: Record<string, QuestStatus>;
}

export interface ChatMessage extends BaseEntity {
  message: string;
  isUser: boolean;
}

================
File: components/__tests__/__snapshots__/ThemedText-test.tsx.snap
================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`renders correctly 1`] = `
<Text
  style={
    [
      {
        "color": "#11181C",
      },
      {
        "fontSize": 16,
        "lineHeight": 24,
      },
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
    ]
  }
>
  Snapshot test!
</Text>
`;

================
File: components/__tests__/ThemedText-test.tsx
================
import * as React from 'react';
import renderer from 'react-test-renderer';

import { ThemedText } from '../ThemedText';

it(`renders correctly`, () => {
  const tree = renderer.create(<ThemedText>Snapshot test!</ThemedText>).toJSON();

  expect(tree).toMatchSnapshot();
});

================
File: components/ChatInterface.tsx
================
import React from 'react';
import { View, Text, ScrollView, TextInput } from 'react-native';
import styles from '@/app/styles/global';
import { ChatMessage } from '@/app/types';

interface ChatInterfaceProps {
  themeColor: string;
  recentMessages: ChatMessage[];
}

export const ChatInterface: React.FC<ChatInterfaceProps> = ({ 
    themeColor, 
    recentMessages 
}) => {

  const isDarkColor = (color: string) => {
    const hex = color.replace('#', '');
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    return brightness < 128;
  };

  const textColor = isDarkColor(themeColor) ? '#fff' : '#000';

  return (
    <View style={[styles.customChatContainer, { borderColor: themeColor }]}>
      <View style={styles.chatHeader}>
        <Text style={styles.cardTitle}>Neural Link</Text>
      </View>
      <ScrollView style={styles.chatScroll}>
        {recentMessages?.map((msg: ChatMessage, index: number) => (
          <View key={index} style={[
            msg.isUser ? styles.userMessage : styles.aiMessage,
            msg.isUser && { backgroundColor: themeColor }
          ]}>
            <Text style={[styles.messageText, msg.isUser && { color: textColor }]}>
              {msg.message}
            </Text>
          </View>
        ))}
      </ScrollView>
      <TextInput 
        style={styles.chatInput} 
        placeholder="What's on your mind?" 
        placeholderTextColor='#AAA'
      />
    </View>
  );
};

================
File: components/Collapsible.tsx
================
import { PropsWithChildren, useState } from 'react';
import { StyleSheet, TouchableOpacity } from 'react-native';

import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import { IconSymbol } from '@/components/ui/IconSymbol';
import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export function Collapsible({ children, title }: PropsWithChildren & { title: string }) {
  const [isOpen, setIsOpen] = useState(false);
  const theme = useColorScheme() ?? 'light';

  return (
    <ThemedView>
      <TouchableOpacity
        style={styles.heading}
        onPress={() => setIsOpen((value) => !value)}
        activeOpacity={0.8}>
        <IconSymbol
          name="chevron.right"
          size={18}
          weight="medium"
          color={theme === 'light' ? Colors.light.icon : Colors.dark.icon}
          style={{ transform: [{ rotate: isOpen ? '90deg' : '0deg' }] }}
        />

        <ThemedText type="defaultSemiBold">{title}</ThemedText>
      </TouchableOpacity>
      {isOpen && <ThemedView style={styles.content}>{children}</ThemedView>}
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  heading: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  content: {
    marginTop: 6,
    marginLeft: 24,
  },
});

================
File: components/ExternalLink.tsx
================
import { Link } from 'expo-router';
import { openBrowserAsync } from 'expo-web-browser';
import { type ComponentProps } from 'react';
import { Platform } from 'react-native';

type Props = Omit<ComponentProps<typeof Link>, 'href'> & { href: string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    <Link
      target="_blank"
      {...rest}
      href={href}
      onPress={async (event) => {
        if (Platform.OS !== 'web') {
          // Prevent the default behavior of linking to the default browser on native.
          event.preventDefault();
          // Open the link in an in-app browser.
          await openBrowserAsync(href);
        }
      }}
    />
  );
}

================
File: components/HapticTab.tsx
================
import { BottomTabBarButtonProps } from '@react-navigation/bottom-tabs';
import { PlatformPressable } from '@react-navigation/elements';
import * as Haptics from 'expo-haptics';

export function HapticTab(props: BottomTabBarButtonProps) {
  return (
    <PlatformPressable
      {...props}
      onPressIn={(ev) => {
        if (process.env.EXPO_OS === 'ios') {
          // Add a soft haptic feedback when pressing down on the tabs.
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        }
        props.onPressIn?.(ev);
      }}
    />
  );
}

================
File: components/HelloWave.tsx
================
import { useEffect } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withRepeat,
  withSequence,
} from 'react-native-reanimated';

import { ThemedText } from '@/components/ThemedText';

export function HelloWave() {
  const rotationAnimation = useSharedValue(0);

  useEffect(() => {
    rotationAnimation.value = withRepeat(
      withSequence(withTiming(25, { duration: 150 }), withTiming(0, { duration: 150 })),
      4 // Run the animation 4 times
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotationAnimation.value}deg` }],
  }));

  return (
    <Animated.View style={animatedStyle}>
      <ThemedText style={styles.text}>👋</ThemedText>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  text: {
    fontSize: 28,
    lineHeight: 32,
    marginTop: -6,
  },
});

================
File: components/KanbanBoard.tsx
================
import React from 'react';
import { View, Text } from 'react-native';
import { Card } from 'react-native-paper';
import { useTheme } from '@/contexts/ThemeContext';
import { Task } from '@/app/types';
import {formatDateTime } from '@/utils/dateFormatters';
import styles from '@/app/styles/global';

type TaskStatus = 'ToDo' | 'InProgress' | 'Done';

interface KanbanBoardProps {
  tasks: Task[];
}

export function KanbanBoard({ tasks }: KanbanBoardProps) {
  const { themeColor } = useTheme();
  
  // Initialize empty columns
  const groupedTasks: Record<TaskStatus, Task[]> = {
    ToDo: [],
    InProgress: [],
    Done: []
  };

  // Group tasks by status, handling undefined or invalid status
  (tasks || []).forEach(task => {
    const status = task.status as TaskStatus;
    if (status in groupedTasks) {
      groupedTasks[status].push(task);
    } else {
      groupedTasks.ToDo.push(task); // Default to ToDo if status is invalid
    }
  });

  return (
    <View style={styles.kanbanContainer}>
      {(Object.keys(groupedTasks) as TaskStatus[]).map((status) => (
        <View key={status} style={styles.kanbanColumn}>
          <Text style={[styles.kanbanTitle, { color: 'white' }]}>
            {status.replace(/([A-Z])/g, ' $1').trim()}
          </Text>
          {groupedTasks[status].map((task) => (
            <Card 
              key={task.id} 
              style={[styles.kanbanTaskCard, { borderColor: themeColor, borderWidth: 1 }]}
            >
              <Text style={styles.kanbanTask}>{task.title}</Text>
              <Text style={[styles.statusTimestamp]}>
                {formatDateTime(task.scheduled_for, 'compact')}
              </Text>
              {task.deadline && (
                <Text style={[styles.cardDetails, { color: '#FF4444', fontSize: 12 }]}>
                  {formatDateTime(task.deadline, 'deadline')}
                </Text>
              )}
            </Card>
          ))}
        </View>
      ))}
    </View>
  );
}

================
File: components/layouts/DesktopLayout.tsx
================
import React, { useEffect } from 'react';
import { View, Text, TouchableOpacity } from 'react-native';
import { Card } from 'react-native-paper';
import { ChatInterface } from '@/components/ChatInterface';
import { TaskList } from '@/components/TaskList';
import { KanbanBoard } from '@/components/KanbanBoard';
import { SettingsButton } from '@/components/ui/SettingsButton';
import { LoadingSpinner } from '@/components/ui/LoadingSpinner';
import { useChatData } from '@/hooks/useChatData';
import { useQuests } from '@/services/questsService';  // Updated import path
import { useTheme } from '@/contexts/ThemeContext';
import { useRouter } from 'expo-router';
import styles from '@/app/styles/global';
import { formatDateTime } from '@/utils/dateFormatters';
import { useQuestUpdate } from '@/contexts/QuestUpdateContext';

export function DesktopLayout() {
  const router = useRouter();
  const { themeColor } = useTheme();
  const { messages } = useChatData();
  const { mainQuest, loading, error, reload } = useQuests();  // Updated hook name and added reload
  const { shouldUpdate, resetUpdate } = useQuestUpdate();

  console.log("DesktopLayout mainQuest:", mainQuest); // Add log to check main quest

  // Simple mount-time load
  useEffect(() => {
    reload();
  }, []);

  // Add effect to check for updates
  useEffect(() => {
    if (shouldUpdate) {
      console.log('Update triggered, reloading quests');
      reload();
      resetUpdate();
    }
  }, [shouldUpdate]);

  const isDarkColor = (color: string) => {
    const hex = color.replace('#', '');
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    return brightness < 128;
  };

  const textColor = isDarkColor(themeColor) ? '#fff' : '#000';

  return (
    <View style={[styles.container, { backgroundColor: '#181818' }]}> 
      <View style={styles.column}>
        <Card style={[styles.mainQuestCard, { borderColor: themeColor, borderWidth: 2 }]}> 
          {loading ? (
            <LoadingSpinner />
          ) : error ? (
            <Text style={[styles.errorText, { color: '#FF4444' }]}>{error}</Text>
          ) : !mainQuest ? (
            <View>
              <Text style={styles.mainQuestTitle}>No main quest selected</Text>
              <TouchableOpacity 
                onPress={() => router.push('/quests')}
                style={[styles.viewAllQuests, { backgroundColor: themeColor }]}
              >
                <Text style={[styles.viewAllQuestsText, { color: textColor }]}>
                  Select Main Quest
                </Text>
              </TouchableOpacity>
            </View>
          ) : (
            <>
              <Text style={styles.mainQuestTitle}>{mainQuest.title}</Text>
              {mainQuest.start_date && (
                <Text style={[styles.cardDetails, { color: '#AAA' }]}>
                  Started: {formatDateTime(mainQuest.start_date)}
                </Text>
              )}
              {mainQuest.end_date && (
                <Text style={[styles.cardDetails, { color: '#AAA' }]}>
                  Target completion: {formatDateTime(mainQuest.end_date)}
                </Text>
              )}
              <TouchableOpacity 
                onPress={() => router.push('/quests')}
                style={[styles.viewAllQuests, { backgroundColor: themeColor }]}
              >
                <Text style={[styles.viewAllQuestsText, { color: textColor }]}>
                  View All Quests
                </Text>
              </TouchableOpacity>
              <KanbanBoard tasks={mainQuest.tasks || []} />
            </>
          )}
        </Card>
      </View>

      <View style={styles.column}>
        <ChatInterface themeColor={themeColor} recentMessages={messages} />
      </View>
      
      <TaskList />
      <SettingsButton />
    </View>
  );
}

================
File: components/layouts/MobileLayout.tsx
================
import React from 'react';
import { View, Text } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context'; // Install if needed
import { ChatInterface } from '@/components/ChatInterface';
import { HamburgerMenu } from '@/components/ui/HamburgerMenu';
import { useChatData } from '@/hooks/useChatData';
import styles from '@/app/styles/global';

const MobileNavigation: React.FC = () => (
  <View style={styles.mobileNavigation}>
    <HamburgerMenu />
  </View>
);

export function MobileLayout() {
  const { messages, themeColor } = useChatData();

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: '#181818' }}>
      <View style={styles.mobileHeader}>
        <Text style={styles.mobileHeaderText}>QuestLog</Text>
      </View>
      
      <View style={styles.mobileContent}>
        <ChatInterface 
          themeColor={themeColor} 
          recentMessages={messages}
        />
      </View>
      
      <MobileNavigation />
    </SafeAreaView>
  );
}

================
File: components/ParallaxScrollView.tsx
================
import type { PropsWithChildren, ReactElement } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  interpolate,
  useAnimatedRef,
  useAnimatedStyle,
  useScrollViewOffset,
} from 'react-native-reanimated';

import { ThemedView } from '@/components/ThemedView';
import { useBottomTabOverflow } from '@/components/ui/TabBarBackground';
import { useThemeColor } from '@/hooks/useThemeColor';

const HEADER_HEIGHT = 250;

type Props = PropsWithChildren<{
  headerImage: ReactElement;
  headerBackgroundColor: { dark: string; light: string };
}>;

export default function ParallaxScrollView({
  children,
  headerImage,
  headerBackgroundColor,
}: Props) {
  const colorScheme = useThemeColor({ light: 'light', dark: 'dark' }, 'background') as 'dark' | 'light';
  const scrollRef = useAnimatedRef<Animated.ScrollView>();
  const scrollOffset = useScrollViewOffset(scrollRef);
  const bottom = useBottomTabOverflow();
  const headerAnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateY: interpolate(
            scrollOffset.value,
            [-HEADER_HEIGHT, 0, HEADER_HEIGHT],
            [-HEADER_HEIGHT / 2, 0, HEADER_HEIGHT * 0.75]
          ),
        },
        {
          scale: interpolate(scrollOffset.value, [-HEADER_HEIGHT, 0, HEADER_HEIGHT], [2, 1, 1]),
        },
      ],
    };
  });

  return (
    <ThemedView style={styles.container}>
      <Animated.ScrollView
        ref={scrollRef}
        scrollEventThrottle={16}
        scrollIndicatorInsets={{ bottom }}
        contentContainerStyle={{ paddingBottom: bottom }}>
        <Animated.View
          style={[
            styles.header,
            { backgroundColor: headerBackgroundColor[colorScheme] },
            headerAnimatedStyle,
          ]}>
          {headerImage}
        </Animated.View>
        <ThemedView style={styles.content}>{children}</ThemedView>
      </Animated.ScrollView>
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    height: HEADER_HEIGHT,
    overflow: 'hidden',
  },
  content: {
    flex: 1,
    padding: 32,
    gap: 16,
    overflow: 'hidden',
  },
});

================
File: components/QuestsOverview.tsx
================
import React, { useState } from 'react';
import { View, Text, TouchableOpacity, FlatList, ScrollView, Dimensions } from 'react-native';
import { Card } from 'react-native-paper';
import { useTheme } from '@/contexts/ThemeContext';
import styles from '@/app/styles/global';
import { useQuests } from '@/services/questsService';
import { Quest } from '@/app/types';

type QuestStatus = 'Active' | 'On-Hold' | 'Completed';

interface QuestsOverviewProps {
  quests: Quest[];
  onSelectQuest: (questId: number) => void;
  currentMainQuest: Quest | null;
}

export function QuestsOverview({ quests, onSelectQuest, currentMainQuest }: QuestsOverviewProps) {
  const { themeColor } = useTheme();
  const [activeTab, setActiveTab] = useState<QuestStatus>('Active');
  const [selectedQuest, setSelectedQuest] = useState<Quest | null>(null);
  const windowHeight = Dimensions.get('window').height;

  const filteredQuests = quests.filter(q => q.status === activeTab);

  const tabs: QuestStatus[] = ['Active', 'On-Hold', 'Completed'];

  const getQuestCardColor = (quest: Quest) => {
    if (quest.is_main) {  // Changed from isMain
      // Create a less saturated version of themeColor
      const hex = themeColor.replace('#', '');
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);
      const desaturate = 0.5; // 50% desaturation
      const gray = (r + g + b) / 3;
      const newR = Math.round(r * (1 - desaturate) + gray * desaturate);
      const newG = Math.round(g * (1 - desaturate) + gray * desaturate);
      const newB = Math.round(b * (1 - desaturate) + gray * desaturate);
      return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
    }
    return themeColor;
  };

  return (
    <View style={[styles.container, { backgroundColor: '#181818', height: windowHeight }]}>
      <View style={styles.column}>
        <Card style={[styles.mainQuestCard, { borderColor: themeColor, borderWidth: 2, height: windowHeight * 0.95 }]}>
          <View style={{ flexDirection: 'row', marginBottom: 20 }}>
            {tabs.map(tab => (
              <TouchableOpacity 
                key={tab} 
                onPress={() => setActiveTab(tab)}
                style={[
                  styles.toggleButton,
                  { 
                    backgroundColor: activeTab === tab ? themeColor : '#333',
                    marginRight: 10,
                    flex: 1
                  }
                ]}
              >
                <Text style={[
                  styles.toggleButtonText,
                  { color: activeTab === tab ? '#fff' : '#aaa' }
                ]}>
                  {tab}
                </Text>
              </TouchableOpacity>
            ))}
          </View>

          <View style={{ flexDirection: 'row', flex: 1 }}>
            <View style={{ flex: 1, marginRight: 20, maxHeight: windowHeight * 0.8 }}>
              <FlatList
                style={{ flex: 1 }}
                data={filteredQuests}
                keyExtractor={(item) => item.id.toString()}
                renderItem={({ item }) => (
                  <TouchableOpacity onPress={() => setSelectedQuest(item)}>
                    <Card style={[
                      styles.taskCard,
                      { 
                        borderColor: item.is_main ? getQuestCardColor(item) : themeColor,  // Changed from isMain
                        borderWidth: item.is_main ? 3 : selectedQuest?.id === item.id ? 2 : 0,  // Changed from isMain
                        backgroundColor: item.is_main ? `${getQuestCardColor(item)}22` : '#444',  // Changed from isMain
                        // Add shadow for main quest
                        ...(item.is_main && {  // Changed from isMain
                          shadowColor: getQuestCardColor(item),
                          shadowOffset: { width: 0, height: 0 },
                          shadowOpacity: 0.5,
                          shadowRadius: 8,
                          elevation: 6,
                        })
                      }
                    ]}>
                      <Text style={styles.cardTitle}>{item.title}</Text>
                    </Card>
                  </TouchableOpacity>
                )}
              />
            </View>

            <View style={{ flex: 1, maxHeight: windowHeight * 0.8 }}>
              {selectedQuest ? (
                <ScrollView style={{ flex: 1 }} bounces={false}>
                  <Card style={[styles.mainQuestCard, { 
                    borderColor: themeColor, 
                    borderWidth: 2 
                  }]}>
                    <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}>
                      <Text style={styles.mainQuestTitle}>{selectedQuest.title}</Text>
                      <TouchableOpacity 
                        onPress={() => onSelectQuest(selectedQuest.id)}
                        style={[
                          styles.setMainQuestButton,
                          { 
                            backgroundColor: selectedQuest.id === currentMainQuest?.id ? '#666' : themeColor,
                            opacity: selectedQuest.id === currentMainQuest?.id ? 0.7 : 1
                          }
                        ]}
                      >
                        <Text style={styles.setMainQuestButtonText}>
                          {selectedQuest.id === currentMainQuest?.id ? 'Main Quest' : 'Set as Main Quest'}
                        </Text>
                      </TouchableOpacity>
                    </View>
                    <Text style={styles.cardDetails}>{selectedQuest.tagline}</Text>
                    
                    {selectedQuest?.currentStatus ? (
                      <Card style={[styles.taskCard, { borderColor: themeColor, borderWidth: 1 }]}>
                        <Text style={styles.statusTimestamp}>
                          [{selectedQuest.currentStatus.timestamp}]
                        </Text>
                        <Text style={styles.cardDetails}>
                          {selectedQuest.currentStatus.message}
                        </Text>
                      </Card>
                    ) : (
                      <Card style={[styles.taskCard, { borderColor: themeColor, borderWidth: 1 }]}>
                        <Text style={styles.cardDetails}>No current status</Text>
                      </Card>
                    )}

                    <Card style={[styles.taskCard, { borderColor: themeColor, borderWidth: 1 }]}>
                      <Text style={styles.cardDetails}>{selectedQuest.questStatus}</Text>
                    </Card>
                    
                    <View style={styles.questTasksContainer}>
                      <Text style={[styles.cardTitle, { marginTop: 10 }]}>
                        Current Tasks ({selectedQuest.tasks?.length || 0})
                      </Text>
                      {selectedQuest.tasks?.map((task) => (
                        <Card 
                          key={task.id} 
                          style={[styles.taskCard, { borderColor: themeColor, borderWidth: 1 }]}
                        >
                          <Text style={styles.cardTitle}>{task.title}</Text>
                          <Text style={styles.cardDetails}>
                            Start: {task.scheduled_for} ({task.location})
                          </Text>
                          {task.deadline && (
                            <Text style={[styles.cardDetails, { color: '#FF4444' }]}>
                              Deadline: {task.deadline}
                            </Text>
                          )}
                        </Card>
                      ))}
                    </View>
                  </Card>
                </ScrollView>
              ) : (
                <Card style={[styles.mainQuestCard, { borderColor: themeColor, borderWidth: 2 }]}>
                  <Text style={styles.cardDetails}>Select a quest to view details</Text>
                </Card>
              )}
            </View>
          </View>
        </Card>
      </View>
    </View>
  );
}

================
File: components/TaskList.tsx
================
import React from 'react';
import { View, Text, FlatList, TouchableOpacity } from 'react-native';
import { Card } from 'react-native-paper';
import Animated from 'react-native-reanimated';
import { useTasks } from '@/services/tasksService';
import { useTheme } from '@/contexts/ThemeContext';
import { LoadingSpinner } from './ui/LoadingSpinner';
import { formatDateTime } from '@/utils/dateFormatters';
import styles from '@/app/styles/global';

export function TaskList() {
  const { themeColor } = useTheme();
  const { tasks, taskListVisible, animatedHeight, toggleTaskList, loading, error } = useTasks();

  if (loading) return <LoadingSpinner />;
  if (error) return <Text style={{ color: 'red' }}>{error}</Text>;
  if (!tasks.length) return null;

  const isDarkColor = (color: string) => {
    const hex = color.replace('#', '');
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    return brightness < 128;
  };

  const textColor = isDarkColor(themeColor) ? '#fff' : '#000';

  return (
    <View style={styles.column}>
      <TouchableOpacity 
        onPress={toggleTaskList} 
        style={[styles.toggleButton, { backgroundColor: themeColor }]}>
        <Text style={[styles.toggleButtonText, { color: textColor }]}>
          {taskListVisible ? "Hide Tasks" : "Show Upcoming Tasks"}
        </Text>
      </TouchableOpacity>
      
      <Animated.View style={[
        styles.taskContainer,
        {
          maxHeight: animatedHeight.interpolate({
            inputRange: [0, 1],
            outputRange: ['0%', '100%']
          }),
          opacity: animatedHeight
        }
      ]}>
        <FlatList
          data={tasks}
          keyExtractor={(item) => item.id.toString()}
          renderItem={({ item }) => (
            <Card style={[styles.taskCard, { borderColor: themeColor, borderWidth: 2 }]}> 
              <Text style={styles.cardTitle}>{item.title}</Text>
              <Text style={styles.cardDetails}>
                Start: {formatDateTime(item.scheduled_for)} ({item.location})
              </Text>
              {item.deadline && (
                <Text style={[styles.cardDetails, { color: '#FF4444' }]}>
                  {formatDateTime(item.deadline, 'deadline')}
                </Text>
              )}
              <Text style={styles.cardQuest}>
                Quest: {item.quest?.title || 'No Quest Assigned'}
              </Text>
            </Card>
          )}
        />
      </Animated.View>
    </View>
  );
}

================
File: components/ThemedText.tsx
================
import { Text, type TextProps, StyleSheet } from 'react-native';

import { useThemeColor } from '@/hooks/useThemeColor';

export type ThemedTextProps = TextProps & {
  lightColor?: string;
  darkColor?: string;
  type?: 'default' | 'title' | 'defaultSemiBold' | 'subtitle' | 'link';
};

export function ThemedText({
  style,
  lightColor,
  darkColor,
  type = 'default',
  ...rest
}: ThemedTextProps) {
  const color = useThemeColor({ light: lightColor, dark: darkColor }, 'text');

  return (
    <Text
      style={[
        { color },
        type === 'default' ? styles.default : undefined,
        type === 'title' ? styles.title : undefined,
        type === 'defaultSemiBold' ? styles.defaultSemiBold : undefined,
        type === 'subtitle' ? styles.subtitle : undefined,
        type === 'link' ? styles.link : undefined,
        style,
      ]}
      {...rest}
    />
  );
}

const styles = StyleSheet.create({
  default: {
    fontSize: 16,
    lineHeight: 24,
  },
  defaultSemiBold: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: '600',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    lineHeight: 32,
  },
  subtitle: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  link: {
    lineHeight: 30,
    fontSize: 16,
    color: '#0a7ea4',
  },
});

================
File: components/ThemedView.tsx
================
import { View, type ViewProps } from 'react-native';

import { useThemeColor } from '@/hooks/useThemeColor';

export type ThemedViewProps = ViewProps & {
  lightColor?: string;
  darkColor?: string;
};

export function ThemedView({ style, lightColor, darkColor, ...otherProps }: ThemedViewProps) {
  const backgroundColor = useThemeColor({ light: lightColor, dark: darkColor }, 'background');

  return <View style={[{ backgroundColor }, style]} {...otherProps} />;
}

================
File: components/ui/HamburgerMenu.tsx
================
import { router } from 'expo-router';
import React, { useState } from 'react';
import { Pressable, StyleSheet, Text, View, Platform, useWindowDimensions, ViewStyle } from 'react-native';
import Animated, { 
  useAnimatedStyle, 
  withSpring,
  useSharedValue,
  withTiming,
  Easing
} from 'react-native-reanimated';

import { IconSymbol } from './IconSymbol';
import { Colors } from '@/constants/Colors';
import { useThemeColor } from '@/hooks/useThemeColor';
import { useTheme } from '@/contexts/ThemeContext';

const MENU_ITEMS = [
  { name: 'Notifications', icon: 'bell.fill', route: '/notification' },
  { name: 'Quests', icon: 'flag', route: '/quests' },
  { name: 'Tasks', icon: 'list.bullet', route: '*/app/tasks' },
  { name: 'Routine', icon: 'clock', route: '*/app/routine' },
  { name: 'Journal', icon: 'book', route: '*/app/journal' },
  { name: 'Profile', icon: 'person', route: '*/app/profile' },
  { name: 'Settings', icon: 'gear', route: '*/app/settings' },
] as const;

export function HamburgerMenu() {
  const { width } = useWindowDimensions();
  const isMobile = Platform.OS === 'ios' || Platform.OS === 'android' || width < 768;
  const [isOpen, setIsOpen] = useState(false);
  const menuAnimation = useSharedValue(0);
  const { themeColor } = useTheme(); // Fix: correctly destructure from useTheme

  const menuStyle = useAnimatedStyle(() => ({
    opacity: withTiming(menuAnimation.value, {
      duration: 200,
      easing: Easing.bezier(0.25, 0.1, 0.25, 1),
    }),
    transform: [
      { 
        translateY: withSpring(menuAnimation.value * -500, { // Increased from -300
          damping: 15,
          stiffness: 100,
        })
      }
    ],
  }));

  const toggleMenu = () => {
    setIsOpen(!isOpen);
    menuAnimation.value = isOpen ? 0 : 1;
  };

  const buttonStyle = (pressed: boolean): ViewStyle => ({
    ...styles.hamburgerButton,
    ...(isMobile && styles.hamburgerButtonMobile),
    ...(pressed && styles.hamburgerButtonPressed),
    backgroundColor: themeColor,
    shadowColor: themeColor,
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.5,
    shadowRadius: 8,
  });

  return (
    <View style={[
      styles.container,
      isMobile && styles.containerMobile
    ]}>
      <Pressable 
        onPress={toggleMenu} 
        style={({ pressed }) => buttonStyle(pressed)}>
        <IconSymbol 
          name={isOpen ? "xmark" : "line.3.horizontal"} 
          size={24} 
          color="#fff" 
        />
      </Pressable>

      {isOpen && (
        <Animated.View 
          pointerEvents="box-none"
          style={[
            styles.menu,
            isMobile && styles.menuMobile,
            menuStyle
          ]}>
          {MENU_ITEMS.map((item) => (
            <Pressable
              key={item.name}
              style={({ pressed }) => [
                styles.menuItem,
                pressed && styles.menuItemPressed
              ]}
              onPress={() => {
                router.push(item.route as any);
                toggleMenu();
              }}>
              <IconSymbol name={item.icon} size={20} color="#fff" />
              <Text style={styles.menuText}>{item.name}</Text>
            </Pressable>
          ))}
        </Animated.View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    right: 20,
    top: 20,
    zIndex: 1000,
  },
  menu: {
    position: 'absolute',
    top: 60,
    right: 0,
    backgroundColor: Colors.light.background,
    borderRadius: 16,
    padding: 8,
    minWidth: 180,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 12,
    elevation: 8,
  },
  menuItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    borderRadius: 8,
    marginVertical: 4,
    backgroundColor: '#333',
  },
  menuItemPressed: {
    backgroundColor: '#444',
  },
  menuText: {
    marginLeft: 12,
    fontSize: 16,
    color: '#fff',
    fontWeight: '500',
  },
  containerMobile: {
    position: 'relative',
    right: 0,
    width: 60,
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 1000,
  },
  menuMobile: {
    position: 'absolute',
    bottom: 120, // Increased from 60
    right: -70, // Centers the 200px wide menu relative to the 60px wide container
    backgroundColor: '#222',
    borderColor: '#333',
    borderWidth: 1,
    width: 200,
    minHeight: 280,
    padding: 8,
    borderRadius: 12,
    zIndex: 2000,
  },
  hamburgerButton: {
    width: 48,
    height: 48,
    borderRadius: 24,
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 5,
  },
  hamburgerButtonMobile: {
    width: 40,
    height: 40,
    backgroundColor: 'transparent',
    shadowOpacity: 0,
  },
  hamburgerButtonPressed: {
    opacity: 0.8,
    transform: [{ scale: 0.97 }],
  },
});

================
File: components/ui/IconSymbol.ios.tsx
================
import { SymbolView, SymbolViewProps, SymbolWeight } from 'expo-symbols';
import { StyleProp, ViewStyle } from 'react-native';

export function IconSymbol({
  name,
  size = 24,
  color,
  style,
  weight = 'regular',
}: {
  name: SymbolViewProps['name'];
  size?: number;
  color: string;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return (
    <SymbolView
      weight={weight}
      tintColor={color}
      resizeMode="scaleAspectFit"
      name={name}
      style={[
        {
          width: size,
          height: size,
        },
        style,
      ]}
    />
  );
}

================
File: components/ui/IconSymbol.tsx
================
// This file is a fallback for using MaterialIcons on Android and web.

import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import { SymbolWeight } from 'expo-symbols';
import React from 'react';
import { OpaqueColorValue, StyleProp, ViewStyle } from 'react-native';

// Add your SFSymbol to MaterialIcons mappings here.
const MAPPING = {
  // See MaterialIcons here: https://icons.expo.fyi
  // See SF Symbols in the SF Symbols app on Mac.
  'house.fill': 'home',
  'paperplane.fill': 'send',
  'chevron.left.forwardslash.chevron.right': 'code',
  'chevron.right': 'chevron-right',
} as Partial<
  Record<
    import('expo-symbols').SymbolViewProps['name'],
    React.ComponentProps<typeof MaterialIcons>['name']
  >
>;

export type IconSymbolName = keyof typeof MAPPING;

/**
 * An icon component that uses native SFSymbols on iOS, and MaterialIcons on Android and web. This ensures a consistent look across platforms, and optimal resource usage.
 *
 * Icon `name`s are based on SFSymbols and require manual mapping to MaterialIcons.
 */
export function IconSymbol({
  name,
  size = 24,
  color,
  style,
}: {
  name: IconSymbolName;
  size?: number;
  color: string | OpaqueColorValue;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return <MaterialIcons color={color} size={size} name={MAPPING[name]} style={style} />;
}

================
File: components/ui/LoadingSpinner.tsx
================
import React from 'react';
import { View, ActivityIndicator } from 'react-native';
import { useTheme } from '@/contexts/ThemeContext';

export function LoadingSpinner() {
  const { themeColor } = useTheme();
  
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <ActivityIndicator size="large" color={themeColor} />
    </View>
  );
}

================
File: components/ui/SettingsButton.tsx
================
import React, { useState } from 'react';
import { View, Pressable, Text, StyleSheet, Modal } from 'react-native';
import ColorPicker from 'react-native-wheel-color-picker';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '@/contexts/ThemeContext';

export function SettingsButton() {
  const [isOpen, setIsOpen] = useState(false);
  const { themeColor, setThemeColor } = useTheme();

  const isDarkColor = (color: string) => {
    const hex = color.replace('#', '');
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    return brightness < 128;
  };

  const textColor = isDarkColor(themeColor) ? '#fff' : '#000';

  return (
    <View style={styles.container}>
      <Pressable
        onPress={() => setIsOpen(!isOpen)}
        style={({ pressed }) => [
          styles.button,
          { backgroundColor: themeColor },
          pressed && styles.pressed
        ]}>
        <Ionicons
          name="settings"
          size={24}
          color={textColor}
        />
      </Pressable>
      
      <Modal
        visible={isOpen}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setIsOpen(false)}
      >
        <Pressable 
          style={styles.modalOverlay}
          onPress={() => setIsOpen(false)}
        >
          <View 
            style={styles.popup}
            onStartShouldSetResponder={() => true}
            onTouchEnd={e => e.stopPropagation()}
          >
            <Text style={[styles.label, { color: textColor }]}>Theme Color</Text>
            <View style={styles.pickerContainer}>
              <ColorPicker
                color={themeColor}
                onColorChange={setThemeColor}
                thumbSize={30}
                sliderSize={20}
                noSnap={true}
                row={false}
              />
            </View>
            <View style={styles.currentColor}>
              <Text style={[styles.colorText, { color: textColor }]}>Current: {themeColor}</Text>
              <View style={[styles.colorPreview, { backgroundColor: themeColor }]} />
            </View>
          </View>
        </Pressable>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    left: 20,
    bottom: 20,
    zIndex: 1000,
  },
  button: {
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: '#333',
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 3.84,
    elevation: 5,
  },
  pressed: {
    opacity: 0.8,
    transform: [{ scale: 0.97 }],
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  popup: {
    backgroundColor: '#222',
    padding: 20,
    borderRadius: 16,
    width: 300,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 12,
    elevation: 8,
  },
  label: {
    color: '#fff',
    marginBottom: 16,
    fontSize: 16,
    fontWeight: '500',
  },
  pickerContainer: {
    height: 300,
    marginBottom: 16,
  },
  currentColor: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  colorText: {
    color: '#fff',
    fontSize: 14,
  },
  colorPreview: {
    width: 30,
    height: 30,
    borderRadius: 15,
    borderWidth: 2,
    borderColor: '#444',
  },
});

================
File: components/ui/TabBarBackground.ios.tsx
================
import { useBottomTabBarHeight } from '@react-navigation/bottom-tabs';
import { BlurView } from 'expo-blur';
import { StyleSheet } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

export default function BlurTabBarBackground() {
  return (
    <BlurView
      // System chrome material automatically adapts to the system's theme
      // and matches the native tab bar appearance on iOS.
      tint="systemChromeMaterial"
      intensity={100}
      style={StyleSheet.absoluteFill}
    />
  );
}

export function useBottomTabOverflow() {
  const tabHeight = useBottomTabBarHeight();
  const { bottom } = useSafeAreaInsets();
  return tabHeight - bottom;
}

================
File: components/ui/TabBarBackground.tsx
================
// This is a shim for web and Android where the tab bar is generally opaque.
export default undefined;

export function useBottomTabOverflow() {
  return 0;
}

================
File: constants/Colors.ts
================
/**
 * Below are the colors that are used in the app. The colors are defined in the light and dark mode.
 * There are many other ways to style your app. For example, [Nativewind](https://www.nativewind.dev/), [Tamagui](https://tamagui.dev/), [unistyles](https://reactnativeunistyles.vercel.app), etc.
 */

const tintColorLight = '#0a7ea4';
const tintColorDark = '#fff';

export const Colors = {
  light: {
    text: '#11181C',
    background: '#fff',
    tint: tintColorLight,
    icon: '#687076',
    tabIconDefault: '#687076',
    tabIconSelected: tintColorLight,
  },
  dark: {
    text: '#ECEDEE',
    background: '#151718',
    tint: tintColorDark,
    icon: '#9BA1A6',
    tabIconDefault: '#9BA1A6',
    tabIconSelected: tintColorDark,
  },
};

================
File: contexts/QuestUpdateContext.tsx
================
import React, { createContext, useContext, useState } from 'react';

interface QuestUpdateContextType {
  triggerUpdate: () => void;
  shouldUpdate: boolean;
  resetUpdate: () => void;
}

const QuestUpdateContext = createContext<QuestUpdateContextType | undefined>(undefined);

export function QuestUpdateProvider({ children }: { children: React.ReactNode }) {
  const [shouldUpdate, setShouldUpdate] = useState(false);

  const triggerUpdate = () => setShouldUpdate(true);
  const resetUpdate = () => setShouldUpdate(false);

  return (
    <QuestUpdateContext.Provider value={{ triggerUpdate, shouldUpdate, resetUpdate }}>
      {children}
    </QuestUpdateContext.Provider>
  );
}

export const useQuestUpdate = () => {
  const context = useContext(QuestUpdateContext);
  if (!context) throw new Error('useQuestUpdate must be used within QuestUpdateProvider');
  return context;
};

================
File: contexts/SupabaseContext.tsx
================
import React, { createContext, useContext, useEffect, useState } from 'react';
import { Session } from '@supabase/supabase-js';
import { supabase } from '@/lib/supabase';

interface SupabaseContextType {
  session: Session | null;
  isLoading: boolean;
}

const SupabaseContext = createContext<SupabaseContextType>({
  session: null,
  isLoading: true,
});

export function SupabaseProvider({ children }: { children: React.ReactNode }) {
  const [session, setSession] = useState<Session | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Initialize session
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
      setIsLoading(false);
    });

    // Listen for auth changes
    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
      setSession(session);
    });

    return () => subscription.unsubscribe();
  }, []);

  return (
    <SupabaseContext.Provider value={{ session, isLoading }}>
      {children}
    </SupabaseContext.Provider>
  );
}

export const useSupabase = () => useContext(SupabaseContext);

================
File: contexts/ThemeContext.tsx
================
import React, { createContext, useContext, useState } from 'react';

interface ThemeContextType {
  themeColor: string;
  setThemeColor: (color: string) => void;
}

const ThemeContext = createContext<ThemeContextType>({
  themeColor: '#00008B',
  setThemeColor: () => {},
});

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [themeColor, setThemeColor] = useState('#00008B');

  return (
    <ThemeContext.Provider value={{ themeColor, setThemeColor }}>
      {children}
    </ThemeContext.Provider>
  );
}

export const useTheme = () => useContext(ThemeContext);

================
File: hooks/useChatData.ts
================
import { useState } from 'react';
import { ChatMessage } from '@/app/types';
import { useTheme } from '@/contexts/ThemeContext';

export function useChatData() {
  const { themeColor } = useTheme();
  const [messages] = useState<ChatMessage[]>([
    { id: 1,created_at: '00000', updated_at: '2222', isUser: false, message: "Rise and shine, samurai. Another day in this digital hellhole.",  },
    { id: 1,created_at: '00000', updated_at: '2222',isUser: false, message: "Got your todo list here - feedback loops and database grind. Oh, and try not to ghost your input parameters tonight, got that hot date coming up." },
    {id: 1,created_at: '00000', updated_at: '2222', isUser: false, message: "So what's it gonna be? Gonna dive into the code mines or keep staring at my gorgeous interface?" },
    {id: 1,created_at: '00000', updated_at: '2222', isUser: true, message: "Thinking about tackling the database first, but yeah, can't mess up tonight's plans." },
    {id: 1,created_at: '00000', updated_at: '2222', isUser: false, message: "Database work, huh? Real exciting stuff. Just don't let the corps standardize your thinking patterns. And hey - that date? That's the real quest here. Everything else is just side content." },
    {id: 1,created_at: '00000', updated_at: '2222', isUser: false, message: "I'll keep an eye on the clock for ya. Shoot you a text at 6PM. Can't let you dive so deep into the code that you forget about the real world. You know how that goes." }
  ]);

  return {
    messages,
    themeColor,
  };
}

================
File: hooks/useColorScheme.web.ts
================
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}

================
File: hooks/useThemeColor.ts
================
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from '@/constants/Colors';
import { useColorScheme } from 'react-native';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}

================
File: lib/supabase.ts
================
import 'react-native-url-polyfill/auto'
import AsyncStorage from '@react-native-async-storage/async-storage'
import { createClient } from '@supabase/supabase-js'

export const supabase = createClient(
  process.env.EXPO_PUBLIC_SUPABASE_URL || "",
  process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY || "",
  {
    auth: {
      storage: AsyncStorage,
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: false,
    },
  })

================
File: package.json
================
{
  "name": "questlog",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "test": "jest --watchAll",
    "lint": "expo lint"
  },
  "jest": {
    "preset": "jest-expo"
  },
  "dependencies": {
    "@expo-google-fonts/inter": "^0.2.3",
    "@expo-google-fonts/poppins": "^0.2.3",
    "@expo/vector-icons": "^14.0.2",
    "@react-native-async-storage/async-storage": "1.23.1",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/native": "^7.0.14",
    "@rneui/themed": "^4.0.0-rc.8",
    "@supabase/supabase-js": "^2.48.1",
    "date-fns": "^4.1.0",
    "expo": "~52.0.28",
    "expo-blur": "~14.0.3",
    "expo-constants": "~17.0.5",
    "expo-font": "~13.0.3",
    "expo-haptics": "~14.0.1",
    "expo-linking": "~7.0.5",
    "expo-router": "~4.0.17",
    "expo-splash-screen": "~0.29.21",
    "expo-status-bar": "~2.0.1",
    "expo-symbols": "~0.2.1",
    "expo-system-ui": "~4.0.7",
    "expo-web-browser": "~14.0.2",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-native": "0.76.6",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-paper": "^5.13.1",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "4.12.0",
    "react-native-screens": "~4.4.0",
    "react-native-url-polyfill": "^2.0.0",
    "react-native-web": "~0.19.13",
    "react-native-webview": "13.12.5",
    "react-native-wheel-color-picker": "^1.3.1"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/jest": "^29.5.12",
    "@types/react": "~18.3.12",
    "@types/react-test-renderer": "^18.3.0",
    "jest": "^29.2.1",
    "jest-expo": "~52.0.3",
    "react-test-renderer": "18.3.1",
    "typescript": "^5.3.3"
  },
  "private": true
}

================
File: README.md
================
# Welcome to your Expo app 👋

This is an [Expo](https://expo.dev) project created with [`create-expo-app`](https://www.npmjs.com/package/create-expo-app).

## Get started

1. Install dependencies

   ```bash
   npm install
   ```

2. Start the app

   ```bash
    npx expo start
   ```

In the output, you'll find options to open the app in a

- [development build](https://docs.expo.dev/develop/development-builds/introduction/)
- [Android emulator](https://docs.expo.dev/workflow/android-studio-emulator/)
- [iOS simulator](https://docs.expo.dev/workflow/ios-simulator/)
- [Expo Go](https://expo.dev/go), a limited sandbox for trying out app development with Expo

You can start developing by editing the files inside the **app** directory. This project uses [file-based routing](https://docs.expo.dev/router/introduction).

## Get a fresh project

When you're ready, run:

```bash
npm run reset-project
```

This command will move the starter code to the **app-example** directory and create a blank **app** directory where you can start developing.

## QUESTLOG

---

## 1. **Landing / Home Page**

### Purpose
- Provide an immediate overview of the user’s current situation: upcoming tasks, open quests, and recent messages from the AI assistant.

### Key Features
- **Quick Glance Cards**: 
  - Next 3 tasks due (with deadlines and location).
  - Active Quests: top 2–3 quests the user is focusing on.
  - Recent Chat Snippets: show last AI message or an “AI Suggestion of the Day.”
- **“Go to Chat” Button**: Encourages the user to jump into the conversational interface.

### Layout Highlights
- Clean hero-like header with user’s name or motivational greeting.
- Panels or cards summarizing key productivity data.
- Possibly highlight an important AI nudge—e.g., “Don’t forget to complete your daily journal!”

---

## 2. **Chat / LLM Interface Page**

### Purpose
- Central place for the user to converse with the AI assistant and see the ongoing dialogue.

### Key Features
- **Chat Thread**: 
  - Messages from the user (aligned right) and AI messages (aligned left).
  - Option to display small icons for different AI “personality modes” (Cheerleader, Stoic Mentor, etc.).
- **Message Input Field**:
  - Allows the user to type or use voice-to-text (if you plan to integrate).
  - Could have a short list of quick action buttons like “Add Task,” “Schedule Event,” or “Add Journal Entry.”
- **Proactive Reminders / Notifications**:
  - Above or below the chat, show real-time notifications when the AI proactively reminds the user about tasks or journal entries.

### Layout Highlights
- Minimal, clean design (similar to messaging apps).
- Keep the chat always scrolled to the bottom for a live feel.
- Possibly a side-panel with “context” info (like current active quest or next upcoming event) which the LLM is referencing.

---

## 3. **Quests Overview Page**

### Purpose
- Display a list of all quests (medium/long-term goals) in an RPG-inspired style. 
- Provide a quick way to see quest progress and statuses.

### Key Features
- **Quests List**:
  - Each quest has a title, short description, a progress bar or indicator of how many tasks are done vs. total tasks.
  - Buttons or links to open a specific quest detail page.
- **Add New Quest** button.

### Layout Highlights
- Visually reminiscent of an RPG quest log: 
  - Possibly with small “quest icons” or stylized headings.
- Clear statuses or color-coding to show which quests are “Active,” “On-Hold,” or “Completed.”

---

## 4. **Single Quest Detail & Kanban Page**

### Purpose
- Serve as the in-depth view for a single quest:
  - Show tasks, memos, and quest statuses (the stylized SWOT analysis logs).
  - Provide an interactive Kanban board to move tasks from “Todo” to “In-Progress” to “Done.”

### Key Features
1. **Quest Info Header**:
   - Title, short description, creation date, “active” or “completed” indicator.
2. **QuestStatus Log** (SWOT-inspired paragraphs):
   - Show the chronological updates to the quest status. 
   - Possibly collapse older status updates, with an option to expand them.
3. **Tasks Kanban Board**:
   - Three columns: “Todo,” “In-Progress,” “Done.”
   - Drag & drop tasks between columns.
   - Each task card shows task name, location, and due date. 
   - A “+ Add Task” button in the “Todo” column.
4. **Memos List**:
   - Separate panel or section for relevant memos/tips. 
   - Memos can be pinned or flagged.

### Layout Highlights
- A large Kanban board for tasks (main content).
- A right sidebar or bottom section for quest statuses (the 3-paragraph logs) and memos.

---

## 5. **Task List Page**

### Purpose
- Give the user a comprehensive view of **all** tasks across quests, sorted by their deadlines and grouped by location.

### Key Features
- **Tasks Grouped by Location**:
  - Sections like “Online/Desktop,” “Gym,” “Home,” “Errands,” etc.
- **Within Each Location**, tasks can be **sorted by date**:
  - Overdue tasks at the top, then upcoming tasks in chronological order.
- **Quick Action Buttons** for each task (e.g., “Mark Complete,” “Edit,” “Reschedule”).

### Layout Highlights
- A collapsible accordion or tab-based interface where each location is its own section.
- Possibly a toggle between “List View” and “Calendar View” to see how tasks map onto a timeline.

---
## 5. **Routine Page**

### Purpose

- Manage recurring maintenance tasks that are not tied to quests but are necessary for daily, weekly, or monthly upkeep.

### Key Features

- ## Task Categories:

- Daily Tasks

- Weekly Tasks

- Monthly Tasks

- Flexible Scheduling (e.g., “Two times a week” or “Every other Friday”).

### Integration with Calendar:

- Sync scheduled tasks with Google Calendar.

- Allow AI to dynamically adjust schedules if a user misses a task (“Let’s reschedule your workout to tomorrow”).

### Completion Tracking:

- Checkbox system to mark completed routines.

- AI-generated streak tracking (e.g., “You’ve completed your morning routine 5 days in a row!”).

### Layout Highlights

- A clean, checklist-style interface.

- Possible calendar-style heatmap for tracking consistency.

## 6. **Calendar Integration Page**

### Purpose
- Integrate with Google Calendar or another scheduling solution so the user can see tasks/events on a monthly/weekly/daily grid.

### Key Features
- **Calendar Grid**:
  - Mark tasks that have scheduled dates, plus any personal events pulled in from Google Calendar.
- **Add/Update Events**:
  - If the user clicks on a date, open a modal to add a new event or schedule an existing task directly on that date and time.
- **Sync Status**:
  - Show whether the user’s Google Calendar is linked, last sync time, any conflicts, etc.

### Layout Highlights
- Standard calendar UI (month, week, day views) with color-coded tasks vs. external events.
- Possibly embed the official Google Calendar UI using an iFrame (for a quicker MVP) or build your own.

---

## 7. **Journal Page (List & Detail)**

### Purpose
- Display the user’s historical journal entries so both the user and the AI can reflect on them.
- Provide a place to read and write new longer-form entries.

### Key Features
1. **Journal Entries List**:
   - Chronological list (most recent at top).
   - Each entry shows a short preview (first ~200 characters).
2. **Single Journal Entry View**:
   - Full content of the journal entry.
   - AI-generated insights or summaries (optional).
3. **Add New Entry**:
   - Rich text editor or simple text box.
   - Option to attach images (if you want a more personal journaling experience).

### Layout Highlights
- A minimal, distraction-free interface for writing. 
- Possibly a “prompt of the day” near the top to encourage daily journaling.

---

## 8. **Settings & Profile Page**

### Purpose
- Central hub for user settings, AI “personality” selection, notification preferences, and user account details.

### Key Features
- **AI Personality Modes**:
  - Let the user pick from pre-set prompts: “Cheerleader,” “Stoic Mentor,” “Sarcastic Pal,” etc.
- **Notification Preferences**:
  - Frequency of proactive AI check-ins.
- **Google Calendar Integration Settings**:
  - Connect/disconnect from Google account.
  - Configure default calendar, tasks sync, etc.
- **User Profile**:
  - Name, time zone, personal background info, etc.

### Layout Highlights
- Tab-based interface or simple form sections for each setting category.
- Toggle switches and radio buttons for easy configuration.

---

## 9. **High-Level UX Flow**

1. **Landing / Home**: Summaries at-a-glance → user can jump into the next needed action.  
2. **Chat**: The user interacts with the LLM for daily conversation, quick tasks, or motivational pep talks.  
   - LLM calls functions like `addTask()`, `updateQuestStatus()`, etc., behind the scenes.  
3. **Quests**: The user can view all quests or open a specific quest’s details and Kanban board.  
4. **Tasks**: The user can see and manage tasks across all quests via a consolidated view.  
5. **Journal**: The user writes new entries or reviews past ones. LLM analyzes them in the background.  
6. **Calendar**: Scheduling tasks and events, integrated with Google Calendar.  
7. **Settings**: Personalize the AI’s demeanor and manage account integrations.

---
---
Data Layer / API Integration:

Set up a proper backend service (e.g. Firebase, Supabase, or your own REST/GraphQL API)
Implement local storage with AsyncStorage for offline capabilities
Use React Query or similar for data fetching/caching/sync
Consider implementing a queue for offline actions


State Management:

Use React Context for global app state
Consider Zustand for more complex state management
Implement proper loading/error states for better UX
Handle state persistence across app restarts


UI Components & Styling:

Use React Native's built-in styling system or a library like StyleSheet
Consider NativeBase or React Native Paper for pre-built components
Implement proper keyboard handling and input behaviors
Ensure components work well across different screen sizes
Use React Native's Animated API for smooth transitions


Navigation & Screens:

Use React Navigation for screen management
Implement proper deep linking support
Consider using tab navigation for main sections
Handle proper back button behavior on Android
Implement gesture-based navigation where appropriate


Notifications & Background Tasks:

Use Expo's Notifications API for push notifications
Implement local notifications for reminders
Handle background tasks for routine updates
Manage notification permissions properly
Consider using Background Fetch for periodic updates


Authentication & Security:

Use Expo Auth Session for OAuth flows
Implement secure token storage
Handle biometric authentication where appropriate
Manage session expiration and refresh
Consider implementing app lock features


Offline Support:

Implement proper data synchronization
Use SQLite or Realm for local database
Handle conflict resolution for offline changes
Show appropriate offline indicators
Queue actions for later sync


Performance Optimization:

Implement proper list virtualization
Use image caching and lazy loading
Optimize animations for 60fps
Minimize JS bridge traffic
Handle memory management properly


Platform-Specific Features:

Use native date/time pickers
Implement proper calendar integration
Handle different keyboard behaviors
Support different screen sizes and orientations
Consider tablet-specific layouts


Testing & Monitoring:

Set up proper error tracking (e.g. Sentry)
Implement analytics for user behavior
Use Expo's testing tools
Handle crash reporting
Monitor performance metrics
### Summing Up

With these pages, your MVP will allow users to (1) chat with the AI assistant to manage tasks and goals, (2) track everything in an RPG-inspired Quest and Task interface, (3) maintain a personal Journal for deeper reflection, and (4) integrate with Google Calendar for real-time scheduling and reminders. The design focuses on balancing a fun, motivational vibe (through the RPG quest metaphor) with straightforward productivity tools (Kanban boards, calendar scheduling, etc.).

This structure provides a clear, game-like user journey while meeting the core requirement: letting the LLM act as a proactive project manager, hooking into tasks, quests, memos, and journal entries—always encouraging the user to stay on top of their goals and well-being.

================
File: scripts/reset-project.js
================
#!/usr/bin/env node

/**
 * This script is used to reset the project to a blank state.
 * It moves the /app, /components, /hooks, /scripts, and /constants directories to /app-example and creates a new /app directory with an index.tsx and _layout.tsx file.
 * You can remove the `reset-project` script from package.json and safely delete this file after running it.
 */

const fs = require("fs");
const path = require("path");

const root = process.cwd();
const oldDirs = ["app", "components", "hooks", "constants", "scripts"];
const newDir = "app-example";
const newAppDir = "app";
const newDirPath = path.join(root, newDir);

const indexContent = `import { Text, View } from "react-native";

export default function Index() {
  return (
    <View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Text>Edit app/index.tsx to edit this screen.</Text>
    </View>
  );
}
`;

const layoutContent = `import { Stack } from "expo-router";

export default function RootLayout() {
  return <Stack />;
}
`;

const moveDirectories = async () => {
  try {
    // Create the app-example directory
    await fs.promises.mkdir(newDirPath, { recursive: true });
    console.log(`📁 /${newDir} directory created.`);

    // Move old directories to new app-example directory
    for (const dir of oldDirs) {
      const oldDirPath = path.join(root, dir);
      const newDirPath = path.join(root, newDir, dir);
      if (fs.existsSync(oldDirPath)) {
        await fs.promises.rename(oldDirPath, newDirPath);
        console.log(`➡️ /${dir} moved to /${newDir}/${dir}.`);
      } else {
        console.log(`➡️ /${dir} does not exist, skipping.`);
      }
    }

    // Create new /app directory
    const newAppDirPath = path.join(root, newAppDir);
    await fs.promises.mkdir(newAppDirPath, { recursive: true });
    console.log("\n📁 New /app directory created.");

    // Create index.tsx
    const indexPath = path.join(newAppDirPath, "index.tsx");
    await fs.promises.writeFile(indexPath, indexContent);
    console.log("📄 app/index.tsx created.");

    // Create _layout.tsx
    const layoutPath = path.join(newAppDirPath, "_layout.tsx");
    await fs.promises.writeFile(layoutPath, layoutContent);
    console.log("📄 app/_layout.tsx created.");

    console.log("\n✅ Project reset complete. Next steps:");
    console.log(
      "1. Run `npx expo start` to start a development server.\n2. Edit app/index.tsx to edit the main screen.\n3. Delete the /app-example directory when you're done referencing it."
    );
  } catch (error) {
    console.error(`Error during script execution: ${error}`);
  }
};

moveDirectories();

================
File: services/questsService.ts
================
import { useState, useEffect } from 'react';
import { supabase } from '@/lib/supabase';
import type { Quest } from '@/app/types';
import { RealtimePostgresChangesPayload } from '@supabase/supabase-js';

// Explicitly define the payload structure
interface QuestUpdate {
  id: number;
  is_main: boolean;
  title?: string;
  tagline?: string;
  status?: string;
  start_date?: string;
  end_date?: string;
  analysis?: string;
  parent_quest_id?: number;
  tags?: string[];
}

type QuestRealtimePayload = RealtimePostgresChangesPayload<QuestUpdate>;

// Database operations
async function fetchQuests(): Promise<Quest[]> {
  console.log('Fetching quests...');
  const { data, error } = await supabase
    .from('quests')
    .select(`
      id,
      created_at,
      updated_at,
      tags,
      title,
      tagline,
      is_main,
      status,
      start_date,
      end_date,
      analysis,
      parent_quest_id,
      tasks (*)
    `)
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error fetching quests:', error);
    throw error;
  }

  console.log('Fetched quests:', data);
  return data || [];
}

async function updateMainQuest(questId: number): Promise<void> {
  console.log('Calling RPC to update main quest:', questId);
  const { error } = await supabase.rpc('update_main_quest', { p_quest_id: questId });
  if (error) {
    console.error('Error updating main quest via RPC:', error);
    throw error;
  }
  console.log('Successfully updated main quest via RPC');
}

// React Hook
export function useQuests() {
  const [quests, setQuests] = useState<Quest[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const loadQuests = async () => {
    try {
      setLoading(true);
      const allQuests = await fetchQuests();
      setQuests(allQuests);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load quests');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadQuests();
  }, []);

  return {
    mainQuest: quests.find(q => q.is_main) || null,
    quests,
    setQuestAsMain: async (questId: number) => {
      try {
        // Update local state first (optimistic update)
        setQuests(currentQuests => 
          currentQuests.map(quest => ({
            ...quest,
            is_main: quest.id === questId
          }))
        );
        
        // Then update the database
        await updateMainQuest(questId);
      } catch (err) {
        // If the update fails, reload from DB to get correct state
        console.error('Failed to set main quest:', err);
        setError(err instanceof Error ? err.message : 'Failed to update main quest');
        await loadQuests();
      }
    },
    loading,
    error,
    reload: loadQuests  // Expose reload function
  };
}

================
File: services/tasksService.ts
================
import { useState, useEffect, useRef } from 'react';
import { Animated } from 'react-native';
import { supabase } from '@/lib/supabase';
import type { Task } from '@/app/types';

// Database operations
async function fetchTasks(): Promise<Task[]> {
  console.log('Fetching tasks...');
  const { data, error } = await supabase
    .from('tasks')
    .select(`
      *,
      quest:quests!quest_id (
        id,
        title,
        tagline,
        is_main,
        status,
        start_date,
        end_date
      )
    `)
    .order('scheduled_for', { ascending: true });

  if (error) {
    console.error('Error fetching tasks:', error);
    throw error;
  }

  console.log('Fetched tasks:', data);
  return data as Task[];
}

async function fetchTasksByQuest(questId: number): Promise<Task[]> {
  const { data, error } = await supabase
    .from('tasks')
    .select('*')
    .eq('quest_id', questId)
    .order('scheduled_for', { ascending: true });

  if (error) throw error;
  return data || [];
}

// React Hook
export function useTasks() {
  const [tasks, setTasks] = useState<Task[]>([]);
  const [taskListVisible, setTaskListVisible] = useState(true);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const animatedHeight = useRef(new Animated.Value(1)).current;

  useEffect(() => {
    loadTasks();
  }, []);

  async function loadTasks() {
    try {
      setLoading(true);
      const data = await fetchTasks();
      console.log('Loaded tasks:', data);
      setTasks(data);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to load tasks';
      console.error('Error loading tasks:', errorMessage);
      setError(errorMessage);
    } finally {
      setLoading(false);
    }
  }

  const toggleTaskList = () => {
    const toValue = taskListVisible ? 0 : 1;
    setTaskListVisible(!taskListVisible);
    
    Animated.timing(animatedHeight, {
      toValue,
      duration: 300,
      useNativeDriver: false,
    }).start();
  };

  return {
    tasks,
    taskListVisible,
    animatedHeight,
    toggleTaskList,
    loading,
    error,
    reload: loadTasks
  };
}

================
File: tsconfig.json
================
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    "types/env.d.ts"
  ]
}

================
File: types/quest.ts
================
export interface BaseEntity {
  id: number;
  created_at: string;
  updated_at: string;
  tags?: string[];
}

export interface Task extends BaseEntity {
  title: string;
  description?: string;
  scheduledFor: string;
  location: string;
  questId: number;
  deadline?: string;
  quest?: Quest; // For joined data
}

export interface JournalEntry extends BaseEntity {
  title: string;
  userEntry: string;
  aiAnalysis: string;
}

export interface QuestStatus extends BaseEntity {
  message: string;
  timestamp: string;
  questId: number;
}

export interface Quest extends BaseEntity {
  title: string;
  shortDescription: string;
  isMain: boolean;
  status: 'Active' | 'On-Hold' | 'Completed';
  progress: string;
  questStatus?: string;
  currentStatus?: QuestStatus;
  tasks: Task[];
  kanban?: Record<string, string[]>;
  analysis?: string;
  parentQuestId?: number;
  startDate?: string;
  endDate?: string;
  StatusHistory?: Record<string, QuestStatus>;
}

export interface Memo extends BaseEntity {
  title: string;
  content: string;
  questId: number;
}

export interface MainQuest {
  id: number;
  title: string;
  progress: string;
  kanban: Record<string, string[]>;
}

================
File: utils/dateFormatters.ts
================
import { formatDistanceToNow, format, isToday, isTomorrow, isYesterday, parseISO } from 'date-fns';

type DateStyle = 'default' | 'deadline' | 'compact';

export function formatDateTime(isoDateString: string | null, style: DateStyle = 'default'): string {
  if (!isoDateString) return style === 'deadline' ? '' : 'No date set';
  
  const date = parseISO(isoDateString);
  const now = new Date();
  
  // Handle invalid dates
  if (isNaN(date.getTime())) return style === 'deadline' ? '' : 'Invalid date';

  // Get relative time string
  const distanceString = formatDistanceToNow(date, { addSuffix: true });

  // Deadline style just prepends "Due" to the distance
  if (style === 'deadline') {
    return `Due ${distanceString}`;
  }

  // For dates within next/past 24 hours
  if (isToday(date)) {
    return style === 'compact' 
      ? format(date, 'h:mm a')
      : `Today at ${format(date, 'h:mm a')}`;
  }
  if (isTomorrow(date)) {
    return style === 'compact'
      ? `Tom ${format(date, 'h:mm a')}`
      : `Tomorrow at ${format(date, 'h:mm a')}`;
  }
  if (isYesterday(date)) {
    return style === 'compact'
      ? `Yest ${format(date, 'h:mm a')}`
      : `Yesterday at ${format(date, 'h:mm a')}`;
  }

  // For dates within the next/past 7 days
  if (Math.abs(date.getTime() - now.getTime()) < 7 * 24 * 60 * 60 * 1000) {
    return style === 'compact'
      ? format(date, 'MMM d')
      : `${distanceString} (${format(date, 'MMM d, h:mm a')})`;
  }

  // For dates further away
  return style === 'compact'
    ? format(date, 'MMM d')
    : format(date, 'MMM d, yyyy h:mm a');
}



================================================================
End of Codebase
================================================================
