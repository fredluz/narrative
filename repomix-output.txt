This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: services/tasksService.ts, services/questsService.ts, services/personalityService.ts, services/eventsService.ts, services/globalSuggestionStore.ts, services/chatDataService.ts, services/agents/SuggestionAgent.ts, services/agents/QuestAgent.ts, services/agents/ChatAgent.ts, hooks/useChatData.ts, contexts/SupabaseContext.tsx, contexts/SuggestionContext.tsx, components/chat/ChatInterface.tsx
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
components/chat/ChatInterface.tsx
contexts/SuggestionContext.tsx
contexts/SupabaseContext.tsx
hooks/useChatData.ts
services/agents/ChatAgent.ts
services/agents/QuestAgent.ts
services/agents/SuggestionAgent.ts
services/eventsService.ts
services/globalSuggestionStore.ts
services/personalityService.ts
services/questsService.ts
services/tasksService.ts

================================================================
Files
================================================================

================
File: services/eventsService.ts
================
import EventEmitter from 'eventemitter3';

class EventsService {
  private static instance: EventsService;
  private emitter: EventEmitter;

  private constructor() {
    this.emitter = new EventEmitter();
  }

  public static getInstance(): EventsService {
    if (!EventsService.instance) {
      EventsService.instance = new EventsService();
    }
    return EventsService.instance;
  }

  public emit(eventName: string, data: any) {
    this.emitter.emit(eventName, data);
  }

  public addListener(eventName: string, callback: (data: any) => void) {
    return this.emitter.addListener(eventName, callback);
  }

  public removeListener(eventName: string, callback: (data: any) => void) {
    this.emitter.removeListener(eventName, callback);  // Changed from removeAllListeners to removeListener
  }
}

export const eventsService = EventsService.getInstance();

// Event name constants
export const EVENT_NAMES = {
  ANALYZE_JOURNAL_ENTRY: 'analyzeJournalEntry',
  NEW_SUGGESTIONS: 'newSuggestions'
} as const;

================
File: services/personalityService.ts
================
import { supabase } from '@/lib/supabase';
import type { PersonalityType } from './agents/PersonalityPrompts';

export const personalityService = {
  async getUserPersonality(userId: string): Promise<PersonalityType> {
    try {
      const { data, error } = await supabase
        .from('profiles')
        .select('ai_personality')
        .eq('id', userId)
        .single();
      
      if (error) throw error;
      
      // Use 'johnny' as default personality
      return (data?.ai_personality as PersonalityType) || 'johnny';
    } catch (error) {
      console.error('Error getting personality:', error);
      return 'johnny'; // Default to Johnny Silverhand if there's an error
    }
  },

  async setUserPersonality(userId: string, personality: PersonalityType): Promise<void> {
    try {
      const { error } = await supabase
        .from('profiles')
        .update({ ai_personality: personality })
        .eq('id', userId);

      if (error) throw error;
    } catch (error) {
      console.error('Error setting personality:', error);
      throw error;
    }
  }
};

================
File: contexts/SupabaseContext.tsx
================
import React, { createContext, useContext, useEffect, useState, useCallback } from 'react';
import { Session } from '@supabase/supabase-js';
import { supabase } from '@/lib/supabase';
import { useRouter } from 'expo-router'; // Keep if needed for error redirects
import { personalityService } from '@/services/personalityService'; // Keep if checkIfNewUser uses it

interface SupabaseContextType {
  session: Session | null;
  /** ONLY true during the initial session check on app startup. */
  isLoading: boolean;
  isNewUser: boolean;
  checkIfNewUser: (userId: string) => Promise<boolean>;
  /** Manually triggers a session refresh attempt. */
  refreshSession: () => Promise<Session | null>;
}

const SupabaseContext = createContext<SupabaseContextType>({
  session: null,
  isLoading: true, // Start loading initially
  isNewUser: false,
  checkIfNewUser: async () => false,
  refreshSession: async () => null,
});

export function SupabaseProvider({ children }: { children: React.ReactNode }) {
  const [session, setSession] = useState<Session | null>(null);
  const [isLoading, setIsLoading] = useState(true); // Tracks INITIAL load only
  const [isNewUser, setIsNewUser] = useState(false);
  const router = useRouter(); // Keep for potential error redirects

  const checkIfNewUser = useCallback(async (userId: string) => {
    console.log(`[SupabaseContext] Checking if user ${userId} is new...`);
    try {
      const { data, error } = await supabase
        .from('profiles')
        .select('ai_personality')
        .eq('id', userId)
        .single();

      // PGRST116 = No rows found, which is expected for a new user profile fetch
      if (error && error.code !== 'PGRST116') {
          console.error('[SupabaseContext] Error fetching profile for new user check:', error);
          throw error; // Re-throw other errors
      }

      const isNew = !data?.ai_personality;
      console.log(`[SupabaseContext] User ${userId} isNew: ${isNew}`);
      setIsNewUser(isNew);
      return isNew;
    } catch (error) {
      console.error('[SupabaseContext] Unexpected error in checkIfNewUser:', error);
      setIsNewUser(false); // Default to not new on error
      return false;
    }
  }, []); // Empty dependency array - this function doesn't depend on component state

  // Function to manually refresh session state if needed (e.g., button click)
  // It attempts refreshSession first, then falls back to getSession.
  // It does NOT affect the initial isLoading state.
  const refreshSession = useCallback(async (): Promise<Session | null> => {
    console.log('[SupabaseContext] Attempting manual session refresh...');
    let refreshedSession: Session | null = null;
    try {
      // Prefer refreshSession as it uses the refresh token
      const { data: refreshData, error: refreshError } = await supabase.auth.refreshSession();

      if (refreshError) {
        console.warn('[SupabaseContext] Manual refreshSession failed, trying getSession:', refreshError.message);
        // Fallback to getSession if refresh fails (e.g., invalid refresh token)
        const { data: getData, error: getError } = await supabase.auth.getSession();
        if (getError) {
          console.error('[SupabaseContext] Manual getSession failed after refresh failure:', getError);
          throw getError; // Throw if both fail
        }
        refreshedSession = getData.session;
      } else {
        refreshedSession = refreshData.session;
      }

      console.log('[SupabaseContext] Manual refresh check result:', refreshedSession ? 'Session active' : 'No session');
      setSession(refreshedSession); // Update state immediately

      if (refreshedSession) {
        await checkIfNewUser(refreshedSession.user.id);
      } else {
        setIsNewUser(false);
      }
      return refreshedSession;

    } catch (error) {
      console.error('[SupabaseContext] Error during manual session refresh:', error);
      setSession(null); // Clear session on critical error
      setIsNewUser(false);
      // Consider redirecting on specific auth errors if needed
      // if (error?.status === 401 || error?.message?.includes('invalid refresh token')) {
      //    router.replace('/auth');
      // }
      return null; // Indicate failure
    }
  }, [checkIfNewUser, router]); // Add router if used

  // Initial session fetch logic, runs only once on mount
  const initialSessionFetch = useCallback(async () => {
    console.log('[SupabaseContext] Performing initial session fetch...');
    // No need to set isLoading=true here, it starts as true
    try {
      // getSession is sufficient and lighter for initial check
      const { data: { session: currentSession }, error } = await supabase.auth.getSession();
      if (error) {
        console.error('[SupabaseContext] Initial getSession error:', error);
        setSession(null);
        setIsNewUser(false);
      } else {
        console.log('[SupabaseContext] Initial getSession result:', currentSession ? `Session found for ${currentSession.user.id}` : 'No session');
        setSession(currentSession);
        if (currentSession) {
          await checkIfNewUser(currentSession.user.id);
        } else {
          setIsNewUser(false);
        }
      }
    } catch (e) {
      console.error('[SupabaseContext] Unexpected error during initial session fetch:', e);
      setSession(null);
      setIsNewUser(false);
    } finally {
      console.log('[SupabaseContext] Initial session fetch complete.');
      setIsLoading(false); // Mark initial loading as finished
    }
  }, [checkIfNewUser]); // Depends on checkIfNewUser

  // Effect to run initial fetch and set up listener
  useEffect(() => {
    initialSessionFetch(); // Run the initial check

    // Set up the listener for subsequent auth events
    const { data: { subscription } } = supabase.auth.onAuthStateChange(async (event, newSession) => {
      console.log(`[SupabaseContext] Auth state changed: ${event}`, newSession ? `User: ${newSession.user.id}` : 'No session');

      // Update session state directly from the event
      setSession(newSession);

      // Update isNewUser status based on the new session state
      if (newSession) {
        // Avoid redundant checks if the user ID hasn't actually changed (e.g., on TOKEN_REFRESHED)
        // Only check if it's a SIGNED_IN event or if the user ID is different from the previous session state
        // Note: Comparing session objects directly might be unreliable due to object references. Use IDs.
        // We need access to the *previous* session state here. Let's simplify for now:
        // Check if new on SIGNED_IN. For TOKEN_REFRESHED, assume user status (new/existing) is unchanged.
        if (event === 'SIGNED_IN') {
            await checkIfNewUser(newSession.user.id);
        }
      } else {
        // Clear isNewUser if session becomes null (SIGNED_OUT or error)
        setIsNewUser(false);
      }
       // *** Crucially, DO NOT set isLoading here. ***
    });

    // Cleanup listener on unmount
    return () => {
      console.log('[SupabaseContext] Unsubscribing from auth state changes.');
      subscription.unsubscribe();
    };
  }, [initialSessionFetch, checkIfNewUser]); // Dependencies for setting up the effect

  // Provide the context value
  const value = {
    session,
    isLoading, // Now accurately reflects ONLY the initial load state
    isNewUser,
    checkIfNewUser,
    refreshSession, // Provide the manual refresh function
  };

  return (
    <SupabaseContext.Provider value={value}>
      {children}
    </SupabaseContext.Provider>
  );
}

export const useSupabase = () => useContext(SupabaseContext);

================
File: services/globalSuggestionStore.ts
================
import { TaskSuggestion, QuestSuggestion } from '@/services/agents/SuggestionAgent';

/**
 * GlobalSuggestionStore provides a centralized singleton for storing and accessing
 * task and quest suggestions across the application. This ensures that both the
 * SuggestionAgent and UI components like ChatInterface are always working with
 * the same data.
 */
class GlobalSuggestionStore {
  private static instance: GlobalSuggestionStore;
  
  // The actual suggestion arrays
  private taskSuggestions: TaskSuggestion[] = [];
  private questSuggestions: QuestSuggestion[] = [];
  
  // Callback handlers for data changes
  private updateHandlers: Array<(
    tasks: TaskSuggestion[], 
    quests: QuestSuggestion[],
  ) => void> = [];
  
  // Private constructor to prevent direct instantiation
  private constructor() {
    console.log('🌐 [GlobalSuggestionStore] Created global suggestion store');
  }
  
  /**
   * Get the singleton instance
   */
  public static getInstance(): GlobalSuggestionStore {
    if (!GlobalSuggestionStore.instance) {
      GlobalSuggestionStore.instance = new GlobalSuggestionStore();
    }
    return GlobalSuggestionStore.instance;
  }
  
  /**
   * Register a handler to be called whenever suggestions change
   */
  registerUpdateHandler(
    handler: (tasks: TaskSuggestion[], quests: QuestSuggestion[], ) => void
  ): () => void {
    console.log('🌐 [GlobalSuggestionStore] Registering new update handler');
    this.updateHandlers.push(handler);
    
    // Call the handler immediately with current data
    handler([...this.taskSuggestions], [...this.questSuggestions]);
    
    // Return a function to unregister this handler
    return () => {
      console.log('🌐 [GlobalSuggestionStore] Unregistering update handler');
      this.updateHandlers = this.updateHandlers.filter(h => h !== handler);
    };
  }
  
  /**
   * Notify all handlers that data has changed
   */
  private notifyHandlers(): void {
    console.log('🌐 [GlobalSuggestionStore] Notifying handlers of update:', {
      taskCount: this.taskSuggestions.length,
      questCount: this.questSuggestions.length,
    });
    
    for (const handler of this.updateHandlers) {
      try {
        handler([...this.taskSuggestions], [...this.questSuggestions]);
      } catch (error) {
        console.error('🌐 [GlobalSuggestionStore] Error in update handler:', error);
      }
    }
  }
  
  /**
   * Add a task suggestion to the store
   */
  addTaskSuggestion(task: TaskSuggestion): void {
    console.log('🌐 [GlobalSuggestionStore] Adding task suggestion:', task.title);
    
    // DEBUG: Log the full task object to see quest_id
    console.log('Task details:', JSON.stringify({
      id: task.id,
      title: task.title,
      quest_id: task.quest_id,
    }, null, 2));
    
    this.taskSuggestions = [...this.taskSuggestions, task];
    this.notifyHandlers();
  }
  
  /**
   * Add a quest suggestion to the store
   */
  addQuestSuggestion(quest: QuestSuggestion): void {
    console.log('🌐 [GlobalSuggestionStore] Adding quest suggestion:', quest.title);
    this.questSuggestions = [...this.questSuggestions, quest];
    this.notifyHandlers();
  }

  /**
   * Remove a task suggestion by ID
   */
  removeTaskSuggestion(taskId: string): void {
    console.log('🌐 [GlobalSuggestionStore] Removing task suggestion:', taskId);
    this.taskSuggestions = this.taskSuggestions.filter(task => task.id !== taskId);
    this.notifyHandlers();
  }
  
  /**
   * Remove a quest suggestion by ID
   */
  removeQuestSuggestion(questId: string): void {
    console.log('🌐 [GlobalSuggestionStore] Removing quest suggestion:', questId);
    this.questSuggestions = this.questSuggestions.filter(quest => quest.id !== questId);
    this.notifyHandlers();
  }

  
  /**
   * Get all task suggestions
   */
  getTaskSuggestions(): TaskSuggestion[] {
    return [...this.taskSuggestions];
  }
  
  /**
   * Get all quest suggestions
   */
  getQuestSuggestions(): QuestSuggestion[] {
    return [...this.questSuggestions];
  }

  /**
   * Clear all suggestions
   */
  clearSuggestions(): void {
    console.log('🌐 [GlobalSuggestionStore] Clearing all suggestions');
    this.taskSuggestions = [];
    this.questSuggestions = [];
    this.notifyHandlers();
  }
  
  /**
   * Add a suggestion (either task or quest)
   */
  addSuggestion(suggestion: TaskSuggestion | QuestSuggestion): void {
    console.log(`🌐 [GlobalSuggestionStore] addSuggestion called : ${suggestion}`);
    
    if (suggestion.type === 'task') {
      this.addTaskSuggestion(suggestion as TaskSuggestion);
    } else if (suggestion.type === 'quest') {
      this.addQuestSuggestion(suggestion as QuestSuggestion);
    } else {
      console.error('🌐 [GlobalSuggestionStore] Unknown suggestion :', suggestion);
    }
  }
}

// Export the singleton instance
export const globalSuggestionStore = GlobalSuggestionStore.getInstance();

================
File: contexts/SuggestionContext.tsx
================
import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { TaskSuggestion, QuestSuggestion, SuggestionAgent } from '@/services/agents/SuggestionAgent';
import { Quest, Task } from '@/app/types';
import { globalSuggestionStore } from '@/services/globalSuggestionStore';
import { useSupabase } from './SupabaseContext';
import { QuestAgent } from '@/services/agents/QuestAgent';
import { updateTask } from '@/services/tasksService';
import { fetchQuests } from '@/services/questsService';
import { eventsService, EVENT_NAMES } from '@/services/eventsService';

type Suggestion = TaskSuggestion | QuestSuggestion ;

// Define the shape of our context
interface SuggestionContextType {
  taskSuggestions: TaskSuggestion[];
  questSuggestions: QuestSuggestion[];
  currentTaskSuggestion: TaskSuggestion | null;
  currentQuestSuggestion: QuestSuggestion | null;
  combinedSuggestionActive: boolean;
  isAnalyzing: boolean;
  
  // Analysis methods
  analyzeJournalEntry: (entry: string, userId: string) => Promise<void>;
  
  // Navigation methods
  nextTaskSuggestion: () => void;
  prevTaskSuggestion: () => void;
  nextQuestSuggestion: () => void;
  prevQuestSuggestion: () => void;
  
  // Action methods
  acceptTaskSuggestion: (task: TaskSuggestion) => Promise<Task | null>;
  rejectTaskSuggestion: (taskId: string) => void;
  acceptQuestSuggestion: (quest: QuestSuggestion) => Promise<Quest | null>;
  rejectQuestSuggestion: (questId: string) => void;
  upgradeTaskToQuest: (task: TaskSuggestion) => Promise<void>;
  
  clearSuggestions: () => void;
}

// Create the context with default values
const SuggestionContext = createContext<SuggestionContextType>({
  taskSuggestions: [],
  questSuggestions: [],
  currentTaskSuggestion: null,
  currentQuestSuggestion: null,
  combinedSuggestionActive: false,
  isAnalyzing: false,
  
  analyzeJournalEntry: async () => {},
  
  nextTaskSuggestion: () => {},
  prevTaskSuggestion: () => {},
  nextQuestSuggestion: () => {},
  prevQuestSuggestion: () => {},
  
  acceptTaskSuggestion: async () => null,
  rejectTaskSuggestion: () => {},
  acceptQuestSuggestion: async () => null,
  rejectQuestSuggestion: () => {},
  upgradeTaskToQuest: async () => {},
  
  clearSuggestions: () => {},
});

// Create the context provider component
export const SuggestionProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  // Access the session for userId
  const { session } = useSupabase();
  
  // Get the userId if available
  const userId = session?.user?.id || '';
  
  // Set up state for suggestions and tracking
  const [taskSuggestions, setTaskSuggestions] = useState<TaskSuggestion[]>([]);
  const [questSuggestions, setQuestSuggestions] = useState<QuestSuggestion[]>([]);
  const [currentTaskIndex, setCurrentTaskIndex] = useState<number>(-1);
  const [currentQuestIndex, setCurrentQuestIndex] = useState<number>(-1);
  const [combinedSuggestionActive, setCombinedSuggestionActive] = useState<boolean>(false);
  const [isAnalyzing, setIsAnalyzing] = useState<boolean>(false);
  
  // Get singleton instances
  const suggestionAgent = SuggestionAgent.getInstance();
  const questAgent = new QuestAgent();

  // Internal helper functions moved from SuggestionAgent
  const addSuggestionToQueue = useCallback((suggestion: Suggestion) => {
    console.log('\n=== SuggestionContext.addSuggestionToQueue ===');
    console.log('Adding suggestion:', {
      type: suggestion.type,
      id: suggestion.id,
      quest_id: suggestion.quest_id ? suggestion.quest_id : 'no quest id',
      title: suggestion.type === 'task' ? suggestion.title : 
        suggestion.type === 'quest' ? (suggestion as QuestSuggestion).title : 
        null,
      timestamp: suggestion.timestamp
    });
    
    // Add the suggestion to the global store
    globalSuggestionStore.addSuggestion(suggestion);
  }, []);

  const clearSuggestionQueue = useCallback(() => {
    console.log('🧹 [SuggestionContext] Clearing suggestion queue');
    globalSuggestionStore.clearSuggestions();
  }, []);

  const removeTaskSuggestion = useCallback((id: string) => {
    console.log('🗑️ [SuggestionContext] Removing task suggestion:', id);
    globalSuggestionStore.removeTaskSuggestion(id);
  }, []);

  const removeQuestSuggestion = useCallback((id: string) => {
    console.log('🗑️ [SuggestionContext] Removing quest suggestion:', id);
    globalSuggestionStore.removeQuestSuggestion(id);
  }, []);

  // Subscribe to changes in the globalSuggestionStore
  useEffect(() => {
    console.log('🔌 [SuggestionContext] Setting up subscription to globalSuggestionStore');
    
    // Register an update handler with the global store
    const unsubscribe = globalSuggestionStore.registerUpdateHandler((tasks, quests) => {
      console.log('📢 [SuggestionContext] Received update from globalSuggestionStore:', {
        taskCount: tasks.length,
        questCount: quests.length,
      });
      
      setTaskSuggestions(tasks);
      setQuestSuggestions(quests);
      
      // Update indices if needed
      if (tasks.length > 0 && currentTaskIndex < 0) {
        setCurrentTaskIndex(0);
      } else if (tasks.length === 0) {
        setCurrentTaskIndex(-1);
      }
      
      if (quests.length > 0 && currentQuestIndex < 0) {
        setCurrentQuestIndex(0);
      } else if (quests.length === 0) {
        setCurrentQuestIndex(-1);
      }
    });
    
    // Clean up subscription on unmount
    return () => {
      console.log('🔌 [SuggestionContext] Cleaning up subscription to globalSuggestionStore');
      unsubscribe();
    };
  }, [currentTaskIndex, currentQuestIndex]);
  
  // Event handler type definitions
  type JournalAnalysisHandler = (data: { entry: string; userId: string }) => void;
  type SuggestionsHandler = (data: { suggestions: Suggestion[] }) => void;

  // Event handler types with proper typing
  type JournalAnalysisEventData = {
    entry: string;
    userId: string;
  };

  type NewSuggestionsEventData = {
    suggestions: Suggestion[];
  };

  // Create stable references to handlers using useCallback with proper types
  const handleJournalAnalysis = useCallback((data: JournalAnalysisEventData) => {
    // Only process if we're not already analyzing to prevent recursion
    if (isAnalyzing) {
      console.log('🚫 Already analyzing, skipping duplicate event');
      return;
    }

    console.log('📢 [SuggestionContext] Processing journal analysis');
    setIsAnalyzing(true);
      
    // Process using async IIFE to handle async operations
    (async () => {
      try {
        // 1. First generate the task suggestions
        console.log('🎯 Generating task suggestions');
        const suggestions = await suggestionAgent.generateTaskSuggestion(data.entry, data.userId, {
          sourceMessage: data.entry,
          relatedMessages: [],
          confidence: 0.7,
          timing: 'short-term'
        });

        if (!suggestions || suggestions.length === 0) {
          console.log('No task suggestions generated');
          return;
        }

        // Process each suggestion through the pipeline
        for (const suggestion of suggestions) {
          // 2. Check for similar existing tasks
          console.log('🔍 Checking for similar existing tasks:', suggestion.title);
          const similarityResult = await suggestionAgent.checkForDuplicatesBeforeShowing(suggestion, data.userId);

          // 3. Handle the result based on similarity and continuation
          if (similarityResult.isMatch && similarityResult.existingTask) {
            if (similarityResult.isContinuation) {
              // This is a continuation of an existing task
              console.log('🔄 Task identified as continuation:', similarityResult.continuationReason);
              
              // Get quest context if available
              const questContext = similarityResult.existingTask.quest_id ? 
                await fetchQuests(data.userId).then(quests => 
                  quests.find(q => q.id === similarityResult.existingTask?.quest_id)
                ) : undefined;
              
              // Regenerate the suggestion with continuation context and store the previous task info
              const enhancedSuggestion = await suggestionAgent.regenerateTaskWithContinuationContext(
                {
                  ...suggestion,
                  continuesFromTask: similarityResult.existingTask // Store reference to previous task
                },
                similarityResult.existingTask,
                questContext
              );
              
              if (enhancedSuggestion) {
                // Add the enhanced suggestion to queue
                console.log('✨ Adding continuation task suggestion to queue');
                addSuggestionToQueue(enhancedSuggestion);
              }
            } else if (similarityResult.matchConfidence > 0.7) {
              // If we found a very similar task with high confidence, convert to edit suggestion
              console.log(`Found similar existing task (${similarityResult.matchConfidence.toFixed(2)} confidence). Converting to edit suggestion.`);
              const editSuggestion = await suggestionAgent.convertToEditSuggestion(suggestion, similarityResult.existingTask);
              
              addSuggestionToQueue(editSuggestion);
            }
          } else {
            // 4. If no similar task found, find the best quest for this task
            console.log('🔄 Finding best quest match for new task');
            const questId = await suggestionAgent.findBestQuestForTask(suggestion, data.userId);
            
            // 5. Update the suggestion with the found quest ID
            const finalSuggestion = {
              ...suggestion,
              quest_id: questId
            };

            // 6. Add the suggestion to the queue
            console.log('✨ Adding new task suggestion to queue');
            addSuggestionToQueue(finalSuggestion);
          }
        }
      } catch (error) {
        console.error('❌ Error in analyzeJournalEntry:', error);
      } finally {
        setIsAnalyzing(false);
      }
    })();
  }, [suggestionAgent, addSuggestionToQueue, isAnalyzing]);

  const handleNewSuggestions = useCallback((data: NewSuggestionsEventData) => {
    console.log('📢 [SuggestionContext] Received new suggestions:', data.suggestions);
    data.suggestions.forEach((suggestion: Suggestion) => {
      addSuggestionToQueue(suggestion);
    });
  }, [addSuggestionToQueue]);

  // Subscribe to events with proper cleanup
  useEffect(() => {
    console.log('🔌 [SuggestionContext] Setting up event subscriptions');
    
    // Add listeners and store the returned EventEmitter instances
    const journalListener = eventsService.addListener(
      EVENT_NAMES.ANALYZE_JOURNAL_ENTRY, 
      handleJournalAnalysis
    );
    
    const suggestionsListener = eventsService.addListener(
      EVENT_NAMES.NEW_SUGGESTIONS, 
      handleNewSuggestions
    );
    
    // Cleanup function uses the stored listeners
    return () => {
      console.log('🧹 [SuggestionContext] Cleaning up event subscriptions');
      eventsService.removeListener(EVENT_NAMES.ANALYZE_JOURNAL_ENTRY, handleJournalAnalysis);
      eventsService.removeListener(EVENT_NAMES.NEW_SUGGESTIONS, handleNewSuggestions);
    };
  }, [handleJournalAnalysis, handleNewSuggestions]);

  // Compute current suggestions based on indices
  const currentTaskSuggestion = 
    currentTaskIndex >= 0 && taskSuggestions.length > 0 ? 
    taskSuggestions[currentTaskIndex % taskSuggestions.length] : null;
  
  const currentQuestSuggestion = 
    currentQuestIndex >= 0 && questSuggestions.length > 0 ? 
    questSuggestions[currentQuestIndex % questSuggestions.length] : null;
  
  // Log when current selections change
  useEffect(() => {
    console.log('🔄 [SuggestionContext] Current selections updated:', {
      currentTask: currentTaskSuggestion?.title || 'None',
      currentQuest: currentQuestSuggestion?.title || 'None'
    });
  }, [currentTaskSuggestion, currentQuestSuggestion]);

  const value: SuggestionContextType = {
    taskSuggestions,
    questSuggestions,
    currentTaskSuggestion,
    currentQuestSuggestion,
    combinedSuggestionActive,
    isAnalyzing,
    
    // Analysis methods - these still use SuggestionAgent for LLM operations
    analyzeJournalEntry: async (entry: string, userId: string) => {
      // Only emit event if not already analyzing to prevent recursion
      if (!isAnalyzing) {
        eventsService.emit(EVENT_NAMES.ANALYZE_JOURNAL_ENTRY, { entry, userId });
      }
    },

    // Navigation methods
    nextTaskSuggestion: () => {
      console.log('⏭️ [SuggestionContext] Moving to next task suggestion');
      if (taskSuggestions.length > 0) {
        setCurrentTaskIndex((prev) => (prev + 1) % taskSuggestions.length);
      }
    },
    
    prevTaskSuggestion: () => {
      console.log('⏮️ [SuggestionContext] Moving to previous task suggestion');
      if (taskSuggestions.length > 0) {
        setCurrentTaskIndex((prev) => {
          if (prev <= 0) return taskSuggestions.length - 1;
          return prev - 1;
        });
      }
    },
    
    nextQuestSuggestion: () => {
      console.log('⏭️ [SuggestionContext] Moving to next quest suggestion');
      if (questSuggestions.length > 0) {
        setCurrentQuestIndex((prev) => (prev + 1) % questSuggestions.length);
      }
    },
    
    prevQuestSuggestion: () => {
      console.log('⏮️ [SuggestionContext] Moving to previous quest suggestion');
      if (questSuggestions.length > 0) {
        setCurrentQuestIndex((prev) => {
          if (prev <= 0) return questSuggestions.length - 1;
          return prev - 1;
        });
      }
    },
    
    // Action methods that use both local state and SuggestionAgent
    acceptTaskSuggestion: async (task: TaskSuggestion) => {
      console.log('✅ [SuggestionContext] Accepting task suggestion:', task.title);
      if (!userId) {
        console.error('No user ID available to accept task');
        return null;
      }

      // If this is a continuation task, mark the previous task as done first
      if (task.continuesFromTask) {
        console.log('🔄 Marking previous task as done before accepting continuation');
        await updateTask(task.continuesFromTask.id, {
          status: 'Done' as const,
          updated_at: new Date().toISOString()
        }, userId);
      }

      const result = await suggestionAgent.acceptTaskSuggestion(task, userId);
      if (result) {
        removeTaskSuggestion(task.id);
      }
      return result;
    },
    
    rejectTaskSuggestion: (taskId: string) => {
      console.log('❌ [SuggestionContext] Rejecting task suggestion:', taskId);
      removeTaskSuggestion(taskId);
    },
    
    acceptQuestSuggestion: async (quest: QuestSuggestion) => {
      console.log('✅ [SuggestionContext] Accepting quest suggestion:', quest.title);
      if (!userId) {
        console.error('No user ID available to accept quest');
        return null;
      }
      const result = await suggestionAgent.acceptQuestSuggestion(quest, userId);
      if (result) {
        removeQuestSuggestion(quest.id);
      }
      return result;
    },
    
    rejectQuestSuggestion: (questId: string) => {
      console.log('❌ [SuggestionContext] Rejecting quest suggestion:', questId);
      removeQuestSuggestion(questId);
    },

    upgradeTaskToQuest: async (task: TaskSuggestion) => {
      console.log('⬆️ [SuggestionContext] Upgrading task to quest:', task.title);
      const quest = await suggestionAgent.upgradeTaskToQuest(task, userId);
      if (quest) {
        addSuggestionToQueue(quest);
        removeTaskSuggestion(task.id);
      }
    },
    
    clearSuggestions: clearSuggestionQueue,
  };

  return (
    <SuggestionContext.Provider value={value}>
      {children}
    </SuggestionContext.Provider>
  );
};

// Create a custom hook for easy access to the context
export const useSuggestions = () => useContext(SuggestionContext);

export default SuggestionContext;

================
File: services/agents/QuestAgent.ts
================
import OpenAI from 'openai';
import { GoogleGenerativeAI, type GenerativeModel, SchemaType } from "@google/generative-ai";
import { 
  createQuest,
  updateQuest,
  deleteQuest,
  moveTasksToQuest,
  getQuestsWithTasks,
  getOrCreateMiscQuest,
} from '@/services/questsService';
import type { Quest, Task } from '@/app/types';
import { globalSuggestionStore } from '@/services/globalSuggestionStore';

interface TaskRelevanceItem {
    taskId: number;
    name: string;
    description: string;
    relevance: string;
}

interface QuestRelevanceItem {
    questId: number;
    isRelevant: boolean;
    relevance?: string | null;
    relevantTasks: TaskRelevanceItem[];
}

interface TaskMoveInfo {
    taskId: number;
    reason: string;
}

interface QuestMemo {
    id: string;
    content: string;
    created_at: string;
    source: string;
}

interface ContentAnalysis {
    questId: number;
    updates: {
        description_sugg?: string;
        analysis_sugg?: string;
    };
    confidence: number;
}

export class QuestAgent {
    private openai: OpenAI;
    private actuallyOAI: OpenAI;
    private genAI: GoogleGenerativeAI;
    private geminiModel: GenerativeModel;

    constructor() {
        this.openai = new OpenAI({
            apiKey: process.env.EXPO_PUBLIC_DEEPSEEK_API_KEY,
            baseURL: 'https://api.deepseek.com',
            dangerouslyAllowBrowser: true
        });
        this.actuallyOAI = new OpenAI({
            apiKey: process.env.EXPO_PUBLIC_OPENAI_API_KEY,
            dangerouslyAllowBrowser: true
        });
        
        // Initialize Gemini
        this.genAI = new GoogleGenerativeAI(process.env.EXPO_PUBLIC_GEMINI_API_KEY || '');
        this.geminiModel = this.genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
        
        console.log('🔧 [QuestAgent] Initialized with OpenAI, OpenAI actual, and Gemini models');
    }

    async createQuest(userId: string, questData: {
        title: string;
        tagline: string;
        description?: string;
        status?: 'Active' | 'On-Hold' | 'Completed';
        is_main?: boolean;
        analysis?: string;
        start_date?: string;
        end_date?: string;
        parent_quest_id?: number;
        tags?: string[];
        user_id?: string;
    }): Promise<Quest> {
        if (!userId) {
            console.error('User ID is required for createQuest');
            throw new Error('User ID is required');
        }
        
        try {
            console.log('🚀 Creating new quest:', questData.title);

            // Create the quest first
            const newQuest = await createQuest(userId, {
                ...questData,
                status: questData.status || 'Active',
                is_main: questData.is_main || false,
            });

            // Check misc quest for relevant tasks
            const miscQuest = await getOrCreateMiscQuest(userId);
            if (miscQuest.tasks && miscQuest.tasks.length > 0) {
                console.log('📋 Checking misc quest tasks for relevance to new quest');

                // Filter tasks by user_id
                const userTasks = miscQuest.tasks.filter(task => task.user_id === userId);

                if (userTasks.length > 0) {
                    const prompt = `

New Quest Details:
Title: ${questData.title}
Tagline: ${questData.tagline}
Description: ${questData.description || 'No description'}
Analysis: ${questData.analysis || 'No Analysis'}
Tags: ${questData.tags?.join(', ') || 'No tags'}

Misc Tasks to Analyze:
${userTasks.map(task => `ID: ${task.id}
Title: ${task.title}
Description: ${task.description || 'No description'}`).join('\n\n')}
.`;

                    try {
                        console.log('📤 Sending task analysis to AI');
                        const result = await this.openai.chat.completions.create({
                            model: "deepseek-chat",
                            messages: [
                                {
                                    role: "system",
                                    content: `You are analyzing tasks from a miscellaneous quest collection to see if they would be better suited for a newly created quest.
For each task, determine if it would be better suited in the new quest based on:
1. Direct relevance to the new quest's title or description
2. Thematic alignment with the quest's purpose
3. Similar tags or keywords
4. Logical grouping with the quest's scope

RESPOND ONLY WITH A JSON OBJECT IN THIS EXACT FORMAT:
{
  "tasksToMove": [
    {
      "taskId": number,
      "reason": "Clear explanation of why this task fits better in the new quest"
    }
  ]
}

Be SELECTIVE - only include tasks that have a CLEAR and STRONG connection to the new quest.`
                                },
                                {
                                    role: "user",
                                    content: prompt
                                }
                            ],
                            temperature: 0.7,
                            max_tokens: 2000
                        });
                        
                        const aiResponse = this.cleanResponseText(result.choices[0].message?.content ?? '');
                        
                        try {
                            const parsed = JSON.parse(aiResponse);
                            if (parsed.tasksToMove && Array.isArray(parsed.tasksToMove) && parsed.tasksToMove.length > 0) {
                                console.log(`🔄 Moving ${parsed.tasksToMove.length} tasks from misc to new quest`);
                                
                                // Move tasks one by one
                                const tasksToMove = parsed.tasksToMove
                                    .map((moveInfo: TaskMoveInfo) => moveInfo.taskId)
                                    .filter((taskId: number) => userTasks.some(t => t.id === taskId));

                                if (tasksToMove.length > 0) {
                                    await moveTasksToQuest(miscQuest.id, newQuest.id, userId, tasksToMove);
                                    console.log(`✅ Moved ${tasksToMove.length} tasks to new quest`);
                                }
                            }
                        } catch (parseError) {
                            console.error('❌ Error parsing AI response:', parseError);
                            // Don't throw - we still created the quest successfully
                        }
                    } catch (aiError) {
                        console.error('❌ Error analyzing tasks with AI:', aiError);
                        // Don't throw - we still created the quest successfully
                    }
                }
            }

            console.log('✅ Quest created successfully:', newQuest.id);
            return newQuest;
        } catch (error) {
            console.error('❌ Error creating quest:', error);
            throw error;
        }
    }

    async updateQuest(questId: number, userId: string, questData: {
        title?: string;
        tagline?: string;
        description?: string;
        description_sugg?: string;
        status?: 'Active' | 'On-Hold' | 'Completed';
        is_main?: boolean;
        analysis?: string;
        analysis_sugg?: string;
        start_date?: string;
        end_date?: string;
        parent_quest_id?: number;
        tags?: string[];
        user_id?: string;
    }): Promise<Quest> {
        // Check if userId exists
        if (!userId) {
            console.error('User ID is required for updateQuest');
            throw new Error('User ID is required');
        }
        
        try {
            console.log('🔄 Updating quest:', questId);

            // Use questsService instead of direct database call
            const quest = await updateQuest(questId, userId, questData);

            console.log('✅ Quest updated successfully:', quest.id);
            return quest;
        } catch (error) {
            console.error('❌ Error updating quest:', error);
            throw error;
        }
    }

    async deleteQuest(questId: number, userId: string): Promise<void> {
        // Check if userId exists
        if (!userId) {
            console.error('User ID is required for deleteQuest');
            throw new Error('User ID is required');
        }
        
        try {
            console.log('🗑️ Deleting quest:', questId);

            // Get the misc quest first to ensure it exists
            const miscQuest = await getOrCreateMiscQuest(userId);
            
            // First, move any tasks to the misc quest
            await moveTasksToQuest(questId, miscQuest.id, userId);
            
            // Then delete the quest
            await deleteQuest(questId, userId);
            
            console.log('✅ Quest deleted successfully');
        } catch (error) {
            console.error('❌ Error deleting quest:', error);
            throw error;
        }
    }

    private cleanResponseText(response: string): string {
        console.log('🧹 Cleaning response text of markdown/code markers');
        // Remove common markdown/code block markers
        return response
            .replace(/^```(?:json)?/gm, '') // Remove opening code block
            .replace(/```$/gm, '')          // Remove closing code block
            .replace(/^`{1,2}/gm, '')      // Remove inline code marks at start
            .replace(/`{1,2}$/gm, '')      // Remove inline code marks at end
            .trim();
    }

    private async analyzeRegularQuest(journalContent: string, quests: Quest[], userId: string): Promise<QuestRelevanceItem[]> {
        console.log(`\n🔎 Analyzing ${quests.length} quests for relevance using Gemini model`);
        
        try {
            // Define the schema for structured output that matches QuestRelevanceItem[]
            const questRelevanceSchema = {
                type: SchemaType.ARRAY as const,
                description: "Analysis of quests' relevance to journal entry",
                items: {
                    type: SchemaType.OBJECT as const,
                    properties: {
                        questId: {
                            type: SchemaType.INTEGER as const,
                            description: "ID of the quest being analyzed"
                        },
                        isRelevant: {
                            type: SchemaType.BOOLEAN as const,
                            description: "Whether the quest is relevant to the journal entry"
                        },
                        relevance: {
                            type: SchemaType.STRING as const,
                            description: "Explanation of why the quest is relevant, or null if not relevant",
                            nullable: true
                        },
                        relevantTasks: {
                            type: SchemaType.ARRAY as const,
                            description: "List of tasks from this quest that are relevant to the journal entry",
                            items: {
                                type: SchemaType.OBJECT as const,
                                properties: {
                                    taskId: {
                                        type: SchemaType.INTEGER as const,
                                        description: "ID of the relevant task"
                                    },
                                    name: {
                                        type: SchemaType.STRING as const,
                                        description: "Title of the task"
                                    },
                                    description: {
                                        type: SchemaType.STRING as const,
                                        description: "Description of the task"
                                    },
                                    relevance: {
                                        type: SchemaType.STRING as const,
                                        description: "Explanation of why this task is relevant to the journal entry"
                                    }
                                },
                            }
                        }
                    },
                    required: ["questId", "isRelevant", "relevantTasks", "relevance"]
                }
            };

            // Create a model with the schema for structured output
            const structuredModel = this.genAI.getGenerativeModel({
                model: "gemini-2.0-flash",
                generationConfig: {
                    temperature: 0.4,
                    responseMimeType: "application/json",
                    responseSchema: questRelevanceSchema
                }
            });

            // Prepare the prompt text
            const promptText = `Analyze this journal entry's relevance to these quests:

Journal Entry: "${journalContent}"

Quests to Analyze:
${quests.map(quest => `
Quest ID: ${quest.id}
Title: ${quest.title}
Description: ${quest.description || 'No description yet'}
Status: ${quest.status}
Is Main Quest: ${quest.is_main}
Tasks:
${quest.tasks?.map(task => `- Task ID: ${task.id}, Title: ${task.title}, Description: ${task.description || 'No description'}`).join('\n') || 'No tasks'}
---`).join('\n')}

Analyze criteria:
1. Direct mentions of quest title or related keywords
2. Strong connections to quest description
3. Clear references to related activities or goals
4. Current quest status relevance
5. Specific mentions related to individual tasks

IMPORTANT: Be VERY STRICT in your relevance criteria - only include quests or tasks with CLEAR, DIRECT connections, above 90% certainty.
For each quest, determine if it's relevant and which specific tasks are mentioned or implied in the journal entry.`;

            // Generate content with structured output
            const result = await structuredModel.generateContent(promptText);
            const responseText = result.response.text();
            
            if (!responseText) {
                console.log('⚠️ Empty response from Gemini for quest analysis');
                return [];
            }
            
            // Parse the JSON response - should already be well-structured
            try {
                const parsedResults = JSON.parse(responseText) as QuestRelevanceItem[];
                console.log(`✅ Gemini returned analysis for ${parsedResults.length} quests`);
                return parsedResults;
            } catch (parseError) {
                console.error('❌ Error parsing Gemini response:', parseError);
                console.error('Raw response:', responseText);
                return [];
            }
        } catch (error) {
            console.error('❌ Error analyzing quests with Gemini:', error);
            return [];
        }
    }

    async findRelevantQuests(journalContent: string, userId: string): Promise<Quest[]> {
        if (!userId) {
            console.error('User ID is required for findRelevantQuests');
            return [];
        }
        
        try {
            console.log('🔍 QuestAgent: Finding relevant quests for journal entry');
            
            const quests = await getQuestsWithTasks(userId);

            if (!quests || quests.length === 0) {
                console.log('❌ No quests found in database');
                return [];
            }

            console.log(`📋 Found ${quests.length} total quests to analyze`);

            // Get the misc quest and separate regular quests
            
            // Filter tasks by user_id for all quests
           
            // Store all relevant quest data
            let relevantQuestData: QuestRelevanceItem[] = [];

            // First analyze all regular quests together
            if (quests.length > 0) {
                console.log('📋 Analyzing all regular quests');
                const questAnalyses = await this.analyzeRegularQuest(journalContent, quests, userId);
                relevantQuestData.push(...questAnalyses);
            }

            // Clean up and return results
            const finalQuestData = relevantQuestData.filter(q => q.isRelevant || q.relevantTasks.length > 0);

            // Map back to Quest type with relevance data, maintaining main quest first if relevant
            const relevantQuests = quests
                .filter(quest => finalQuestData.some(data => data.questId === quest.id))
                .sort((a, b) => {
                    if (a.is_main) return -1;
                    if (b.is_main) return 1;
                    return 0;
                })
                .map(quest => ({
                    ...quest,
                    tasks: quest.tasks?.filter(task => task.user_id === userId) || [],
                    relevance: finalQuestData.find(data => data.questId === quest.id)?.relevance || undefined,
                    relevantTasks: finalQuestData.find(data => data.questId === quest.id)?.relevantTasks || []
                }));

            console.log(`\n✨ Found ${relevantQuests.length} relevant quests:`, 
                relevantQuests.map(q => ({ title: q.title, isMain: q.is_main, taskCount: q.relevantTasks?.length })));
            return relevantQuests;

        } catch (error) {
            console.error('❌ Error in findRelevantQuests:', error);
            throw error;
        }
    }

    async analyzeContentForQuest(content: string, questId: number, userId: string, source: string): Promise<ContentAnalysis | null> {
        if (!userId) {
            console.error('User ID is required for analyzeContentForQuest');
            return null;
        }

        // Only proceed if this is an end of day entry
        if (source !== 'end-of-day') {
            console.log('Skipping quest analysis - not an end of day entry');
            return null;
        }

        try {
            console.log('🔍 Analyzing content for quest updates:', questId);

            // Get the quest
            const quests = await getQuestsWithTasks(userId);
            const quest = quests.find(q => q.id === questId);

            if (!quest) {
                console.error('Quest not found');
                return null;
            }

            const result = await this.openai.chat.completions.create({
                model: "deepseek-reasoner",
                messages: [
                    {
                        role: "system",
                        content: `You are analyzing an end-of-day journal entry to suggest updates to a quest's description and analysis.
1. Information that could update the quest's description
2. New context or insights about the quest that advances its narrative

Generate suggested updates - these will be saved separately and reviewed by the user.
Don't try to maintain the exact existing narrative - instead, focus on incorporating the new information
in a way that adds value.`
                    },
                    {
                        role: "user",
                        content: `Analyze this end-of-day journal entry in relation to an existing quest:

Quest Details:
Title: ${quest.title}
Current Description: ${quest.description || 'No description'}
Current Analysis: ${quest.analysis || 'No analysis'}

New Content to Analyze:
${content}

Generate suggested updates that the user can review. Reply ONLY with a JSON object in this exact format:
{
    "questId": ${quest.id},
    "updates": {
        "description_sugg": "Suggested updated description incorporating new information from today's reflection",
        "analysis_sugg": "Suggested new analysis incorporating today's insights"
    },
    "confidence": 0.0 to 1.0
}`
                    }
                ],
                temperature: 0.7,
                max_tokens: 8000
            });

            const aiResponse = this.cleanResponseText(result.choices[0].message?.content ?? '');

            try {
                const parsed = JSON.parse(aiResponse) as ContentAnalysis;
                console.log('📊 Confidence level:', parsed.confidence);
                
                // Track changes made to report back
                const changes = {
                    updatedDescriptionSugg: false,
                    updatedAnalysisSugg: false,
                    errors: [] as string[]
                };

                // Only save suggestions if confidence is high
                if (parsed.confidence >= 0.8) {
                    console.log('🔄 Saving high-confidence update suggestions to database');
                    
                    // Update quest fields if provided
                    if (parsed.updates.description_sugg || parsed.updates.analysis_sugg) {
                        try {
                            const updateData: {description_sugg?: string, analysis_sugg?: string} = {};
                            
                            if (parsed.updates.description_sugg) {
                                updateData.description_sugg = parsed.updates.description_sugg;
                                changes.updatedDescriptionSugg = true;
                                console.log('📝 Saved suggested quest description');
                            }
                            
                            if (parsed.updates.analysis_sugg) {
                                updateData.analysis_sugg = parsed.updates.analysis_sugg;
                                changes.updatedAnalysisSugg = true;
                                console.log('📊 Saved suggested quest analysis');
                            }
                            
                            if (Object.keys(updateData).length > 0) {
                                const updatedQuest = await this.updateQuest(questId, userId, updateData);
                                console.log('✅ Quest suggestions saved successfully in database:', updatedQuest.id);
                            }
                        } catch (updateError) {
                            console.error('❌ Error saving quest suggestions to database:', updateError);
                            changes.errors.push(`Failed to save suggestions: ${updateError instanceof Error ? updateError.message : 'Unknown error'}`);
                        }
                    }

                    // Log summary of changes
                    console.log('📋 Summary of changes:');
                    console.log(`- Description suggestion saved: ${changes.updatedDescriptionSugg}`);
                    console.log(`- Analysis suggestion saved: ${changes.updatedAnalysisSugg}`);
                    if (changes.errors.length > 0) {
                        console.log(`- Errors: ${changes.errors.length}`);
                        changes.errors.forEach(err => console.log(`  - ${err}`));
                    }
                } else {
                    console.log(`⚠️ Confidence level too low (${parsed.confidence}), no suggestions saved`);
                }

                return {
                    ...parsed,
                    meta: {
                        actualChanges: changes
                    }
                } as ContentAnalysis & { meta: { actualChanges: typeof changes } };
            } catch (parseError) {
                console.error('Error parsing AI response:', parseError);
                return null;
            }
        } catch (error) {
            console.error('Error in analyzeContentForQuest:', error);
            return null;
        }
    }

}

================
File: services/questsService.ts
================
import { useState, useEffect } from 'react';
import { supabase } from '@/lib/supabase';
import type { Quest } from '@/app/types';
import { RealtimePostgresChangesPayload } from '@supabase/supabase-js';
import { useSupabase } from '@/contexts/SupabaseContext';

interface QuestUpdate {
  id: number;
  title: string;
  tagline: string;
  description?: string;
  description_sugg?: string;
  is_main: boolean;
  status: 'Active' | 'On-Hold' | 'Completed';
  analysis?: string;
  analysis_sugg?: string;
  parent_quest_id?: number;
  start_date?: string;
  end_date?: string;
  tags?: string[];
  user_id: string;
}

interface QuestInput extends Omit<Quest, 'id' | 'created_at' | 'updated_at' | 'tasks'> {
  description?: string;
  user_id: string;
}

// Update type definition for update operations to allow partial data
type QuestUpdateInput = Partial<Omit<QuestInput, 'user_id'>> & {
  description_sugg?: string;
  analysis_sugg?: string;
};

type QuestRealtimePayload = RealtimePostgresChangesPayload<QuestUpdate>;


// Database operations
export async function fetchQuests(userId: string): Promise<Quest[]> {
  if (!userId) {
    console.error('fetchQuests called without userId');
    return [];
  }

  console.log(`[questsService] Fetching quests for user: ${userId}`);
  
  try {
    // Verify supabase client is initialized
    if (!supabase) {
      console.error('[questsService] Supabase client not initialized');
      return [];
    }

    const { data, error } = await supabase
      .from('quests')
      .select(`
        id,
        created_at,
        updated_at,
        tags,
        title,
        tagline,
        description,
        description_sugg,
        is_main,
        status,
        start_date,
        end_date,
        analysis,
        analysis_sugg,
        parent_quest_id,
        user_id,
        tasks (*)
      `)
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    if (error) {
      console.error('[questsService] Error fetching quests:', error);
      throw error;
    }

    console.log(`[questsService] Successfully fetched ${data?.length || 0} quests`);
    return data || [];
  } catch (error) {
    console.error('[questsService] Unexpected error in fetchQuests:', error);
    
    // In production, return empty array instead of throwing to prevent UI crashes
    if (process.env.NODE_ENV === 'production') {
      return [];
    }
    throw error;
  }
}

// Renamed function to be more descriptive of what it returns
async function getQuestsWithTasks(userId: string): Promise<Quest[]> {
  return fetchQuests(userId);
}

// Remove the export keyword here since we'll export at the bottom
async function createQuest(userId: string, questData: Omit<QuestInput, 'user_id'>): Promise<Quest> {
  const fullQuestData: QuestInput = {
    ...questData,
    user_id: userId
  };

  const cleanedFields = Object.fromEntries(
    Object.entries(fullQuestData).map(([key, value]) => {
      if ((key === 'start_date' || key === 'end_date') && value === '') {
        return [key, null];
      }
      return [key, value];
    })
  );

  const { data: quest, error: questError } = await supabase
    .from('quests')
    .insert({
      ...cleanedFields,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    })
    .select()
    .single();

  if (questError) throw questError;
  return quest;
}

// Remove the export keyword here since we'll export at the bottom
// Update to accept partial data for updates
async function updateQuest(questId: number, userId: string, questData: QuestUpdateInput): Promise<Quest> {
  // First verify ownership
  const { data: quest, error: fetchError } = await supabase
    .from('quests')
    .select('user_id')
    .eq('id', questId)
    .single();

  if (fetchError) {
    console.error('Error verifying quest ownership:', fetchError);
    throw new Error(`Failed to verify quest ownership: ${fetchError.message}`);
  }

  if (!quest || quest.user_id !== userId) {
    console.error('Cannot update quest: User does not own this quest');
    throw new Error('You do not have permission to update this quest');
  }

  const fullQuestData = {
    ...questData,
    user_id: userId
  };

  const cleanedFields = Object.fromEntries(
    Object.entries(fullQuestData).map(([key, value]) => {
      if ((key === 'start_date' || key === 'end_date') && value === '') {
        return [key, null];
      }
      return [key, value];
    })
  );

  const { data, error: updateError } = await supabase
    .from('quests')
    .update({
      ...cleanedFields,
      updated_at: new Date().toISOString()
    })
    .eq('id', questId)
    .eq('user_id', userId)
    .select('*')
    .single();

  if (updateError) throw updateError;
  return data;
}

// New function to delete a quest
async function deleteQuest(questId: number, userId: string): Promise<void> {
  // First verify ownership
  const { data: quest, error: fetchError } = await supabase
    .from('quests')
    .select('user_id')
    .eq('id', questId)
    .single();

  if (fetchError) {
    console.error('Error verifying quest ownership:', fetchError);
    throw new Error(`Failed to verify quest ownership: ${fetchError.message}`);
  }

  if (!quest || quest.user_id !== userId) {
    console.error('Cannot delete quest: User does not own this quest');
    throw new Error('You do not have permission to delete this quest');
  }

  // Delete the quest
  const { error } = await supabase
    .from('quests')
    .delete()
    .eq('id', questId)
    .eq('user_id', userId);

  if (error) throw error;
}

// Add functions to handle misc quests
async function getMiscQuest(userId: string): Promise<Quest | null> {
  const { data, error } = await supabase
    .from('quests')
    .select(`
      id,
      created_at,
      updated_at,
      tags,
      title,
      tagline,
      description,
      description_sugg,
      is_main,
      status,
      start_date,
      end_date,
      analysis,
      analysis_sugg,
      parent_quest_id,
      user_id,
      tasks (*)
    `)
    .eq('user_id', userId)
    .eq('title', 'Misc')
    .single();

  if (error) {
    if (error.code === 'PGSQL_ERROR_NO_DATA_FOUND') {
      return null;
    }
    throw error;
  }

  return data;
}

async function createMiscQuest(userId: string): Promise<Quest> {
  const miscQuest = await createQuest(userId, {
    title: 'Misc',
    tagline: 'Miscellaneous tasks',
    description: 'A collection of tasks that don\'t belong to any specific quest',
    status: 'Active',
    is_main: false
  });

  return miscQuest;
}

async function getOrCreateMiscQuest(userId: string): Promise<Quest> {
  let miscQuest = await getMiscQuest(userId);
  
  if (!miscQuest) {
    miscQuest = await createMiscQuest(userId);
  }

  return miscQuest;
}

// Update the moveTasksToQuest function to handle moving to misc quest
async function moveTasksToQuest(fromQuestId: number, toQuestId: number | null, userId: string, taskIds?: number[]): Promise<void> {
  // If toQuestId is null, we need to move to the misc quest
  const actualToQuestId = toQuestId ?? (await getOrCreateMiscQuest(userId)).id;

  let query = supabase
    .from('tasks')
    .update({ quest_id: actualToQuestId })
    .eq('quest_id', fromQuestId)
    .eq('user_id', userId);

  // If specific taskIds are provided, only move those tasks
  if (taskIds && taskIds.length > 0) {
    query = query.in('id', taskIds);
  }

  const { error } = await query;
  if (error) throw error;
}

async function updateMainQuest(questId: number, userId: string): Promise<void> {
  // First verify ownership
  const { data: quest, error: fetchError } = await supabase
    .from('quests')
    .select('user_id')
    .eq('id', questId)
    .single();

  if (fetchError) {
    console.error('Error verifying quest ownership:', fetchError);
    throw new Error(`Failed to verify quest ownership: ${fetchError.message}`);
  }

  if (!quest || quest.user_id !== userId) {
    console.error('Cannot update main quest: User does not own this quest');
    throw new Error('You do not have permission to update this quest');
  }

  const { error } = await supabase.rpc('update_main_quest', { 
    p_quest_id: questId,
    p_user_id: userId
  });
  
  if (error) {
    console.error('Error updating main quest via RPC:', error);
    throw error;
  }
}


// Export all database operation functions together
export { 
  createQuest, 
  updateQuest, 
  deleteQuest, 
  moveTasksToQuest, 
  updateMainQuest, 
  getQuestsWithTasks,
  getOrCreateMiscQuest,
};

// React Hook
export function useQuests() {
  const [quests, setQuests] = useState<Quest[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const { session } = useSupabase();

  const loadQuests = async () => {
    if (!session?.user?.id) return;
    try {
      setLoading(true);
      const allQuests = await fetchQuests(session.user.id);
      setQuests(allQuests);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load quests');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (!session?.user?.id) return;
    
    loadQuests();

    const subscription = supabase
      .channel('quests_changes')
      .on('postgres_changes', 
        { 
          event: '*', 
          schema: 'public', 
          table: 'quests',
          filter: `user_id=eq.${session.user.id}`
        },
        (payload: QuestRealtimePayload) => {
          console.log('Quest change received:', payload);
          loadQuests();
        }
      )
      .subscribe();

    return () => {
      subscription.unsubscribe();
    };
  }, [session?.user?.id]);

  return {
    mainQuest: quests.find(q => q.is_main) || null,
    quests,
    setQuestAsMain: async (questId: number) => {
      if (!session?.user?.id) return;
      try {
        setQuests(currentQuests => 
          currentQuests.map(quest => ({
            ...quest,
            is_main: quest.id === questId
          }))
        );
        
        await updateMainQuest(questId, session.user.id);
      } catch (err) {
        console.error('Failed to set main quest:', err);
        setError(err instanceof Error ? err.message : 'Failed to update main quest');
        await loadQuests();
      }
    },
    loading,
    error,
    reload: loadQuests
  };
}

================
File: services/tasksService.ts
================
import { useState, useEffect } from 'react';
import { supabase } from '@/lib/supabase';
import type { Task } from '@/app/types';
import { useSupabase } from '@/contexts/SupabaseContext';

// Define types for status
export type TaskStatus = 'ToDo' | 'InProgress' | 'Done';

// Database operations
export async function fetchTasks(userId: string): Promise<Task[]> {
  console.log('Fetching tasks...');
  const { data, error } = await supabase
    .from('tasks')
    .select(`
      *,
      quest:quests!quest_id (
        id,
        title,
        tagline,
        is_main,
        status,
        start_date,
        end_date
      )
    `)
    .eq('user_id', userId)
    .order('scheduled_for', { ascending: true });

  if (error) {
    console.error('Error fetching tasks:', error);
    throw error;
  }

  console.log('Fetched tasks:', data);
  return data as Task[];
}

export async function fetchTasksByQuest(questId: number, userId: string): Promise<Task[]> {
  const { data, error } = await supabase
    .from('tasks')
    .select('*')
    .eq('quest_id', questId)
    .eq('user_id', userId)
    .order('scheduled_for', { ascending: true });

  if (error) throw error;
  return data || [];
}

export async function getTasksByDate(date: string, userId: string): Promise<Task[]> {
  console.log('Fetching tasks for date:', date);
  const startOfDay = `${date}T00:00:00`;
  const endOfDay = `${date}T23:59:59`;

  const { data, error } = await supabase
    .from('tasks')
    .select(`
      *,
      quest:quests!quest_id (
        id,
        title,
        tagline,
        is_main,
        status,
        start_date,
        end_date
      )
    `)
    .eq('user_id', userId)
    .gte('scheduled_for', startOfDay)
    .lte('scheduled_for', endOfDay)
    .order('scheduled_for', { ascending: true });

  if (error) {
    console.error('Error fetching tasks by date:', error);
    throw error;
  }

  return data || [];
}

/**
 * Update a task with specified fields
 * @param taskId ID of the task to update
 * @param updateData Object containing fields to update
 * @param userId User ID for ownership verification
 * @returns The updated task
 */
export async function updateTask(taskId: number, updateData: Record<string, any>, userId: string): Promise<Task> {
  console.log('[tasksService] Updating task:', { taskId, fields: Object.keys(updateData) });
  
  // First verify ownership
  const { data: task, error: fetchError } = await supabase
    .from('tasks')
    .select('user_id')
    .eq('id', taskId)
    .single();

  if (fetchError) {
    console.error('[tasksService] Error verifying task ownership:', fetchError);
    throw new Error(`Failed to verify task ownership: ${fetchError.message}`);
  }

  if (!task || task.user_id !== userId) {
    console.error('[tasksService] Cannot update task: User does not own this task');
    throw new Error('You do not have permission to update this task');
  }
  
  // Add updated_at timestamp if not provided
  if (!updateData.updated_at) {
    updateData.updated_at = new Date().toISOString();
  }
  
  // Perform the update
  const { data, error } = await supabase
    .from('tasks')
    .update(updateData)
    .eq('id', taskId)
    .eq('user_id', userId)
    .select()
    .single();
  
  if (error) {
    console.error('[tasksService] Error updating task:', error);
    throw new Error(`Failed to update task: ${error.message}`);
  }
  
  if (!data) {
    throw new Error('Failed to retrieve updated task data');
  }
  
  return data as Task;
}

// New function to update task status in Supabase
export async function updateTaskStatus(taskId: number, newStatus: TaskStatus, userId: string): Promise<void> {
  // First verify ownership
  const { data: task, error: fetchError } = await supabase
    .from('tasks')
    .select('user_id')
    .eq('id', taskId)
    .single();

  if (fetchError) {
    console.error('Error verifying task ownership:', fetchError);
    throw new Error(`Failed to verify task ownership: ${fetchError.message}`);
  }

  if (!task || task.user_id !== userId) {
    console.error('Cannot update task: User does not own this task');
    throw new Error('You do not have permission to update this task');
  }
  
  const { error } = await supabase
    .from('tasks')
    .update({ status: newStatus, updated_at: new Date().toISOString() })
    .eq('id', taskId)
    .eq('user_id', userId);
  
  if (error) {
    console.error('Error updating task status:', error);
    throw new Error(`Failed to update task status: ${error.message}`);
  }
  
  return Promise.resolve();
}

// New function to create a task in Supabase
export async function createTask(taskData: {
  title: string;
  description?: string;
  status: TaskStatus;
  quest_id: number;
  scheduled_for: string;
  deadline?: string;
  location?: string;
  priority: 'high' | 'medium' | 'low';
  subtasks?: string;
  tags?: string[];
  user_id: string;
}): Promise<Task> {
  console.log('Creating new task:', taskData);
  
  const newTask = {
    ...taskData,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString()
  };
  
  const { data, error } = await supabase
    .from('tasks')
    .insert(newTask)
    .select()
    .single();
  
  if (error) {
    console.error('Error creating task:', error);
    throw new Error(`Failed to create task: ${error.message}`);
  }
  
  if (!data) {
    throw new Error('Failed to retrieve created task');
  }
  
  return data as Task;
}

// Helper function to get the next status in the cycle
export function getNextStatus(currentStatus: string): TaskStatus {
  switch (currentStatus) {
    case 'ToDo':
      return 'InProgress';
    case 'InProgress':
      return 'Done';
    case 'Done':
    default:
      return 'ToDo';
  }
}

// New function to fetch quest tasks in Supabase
export async function fetchQuestTasks(questId: number, userId: string) {
  // First verify quest ownership
  const { data: quest, error: questError } = await supabase
    .from('quests')
    .select('user_id')
    .eq('id', questId)
    .single();

  if (questError) {
    console.error('Error verifying quest ownership:', questError);
    throw new Error(`Failed to verify quest ownership: ${questError.message}`);
  }

  if (!quest || quest.user_id !== userId) {
    console.error('Cannot fetch tasks: User does not own this quest');
    throw new Error('You do not have permission to view these tasks');
  }

  const { data: tasks, error } = await supabase
    .from('tasks')
    .select('*')
    .eq('quest_id', questId)
    .eq('user_id', userId)
    .order('scheduled_for', { ascending: true });

  if (error) throw error;
  return tasks || [];
}

// Delete task function
export async function deleteTask(taskId: number, userId: string): Promise<void> {
  console.log('[tasksService] Starting task deletion process', { taskId, userId });
  
  // First verify ownership
  console.log('[tasksService] Verifying task ownership');
  const { data: task, error: fetchError } = await supabase
    .from('tasks')
    .select('user_id')
    .eq('id', taskId)
    .single();

  if (fetchError) {
    console.error('[tasksService] Error verifying task ownership:', fetchError);
    throw new Error(`Failed to verify task ownership: ${fetchError.message}`);
  }

  if (!task) {
    console.error('[tasksService] No task found with ID:', taskId);
    throw new Error('Task not found');
  }

  if (task.user_id !== userId) {
    console.error('[tasksService] Task ownership verification failed', { 
      taskUserId: task.user_id, 
      requestingUserId: userId 
    });
    throw new Error('You do not have permission to delete this task');
  }

  console.log('[tasksService] Task ownership verified, proceeding with deletion');
  
  const { error } = await supabase
    .from('tasks')
    .delete()
    .eq('id', taskId)
    .eq('user_id', userId);
  
  if (error) {
    console.error('[tasksService] Error during task deletion:', error);
    throw new Error(`Failed to delete task: ${error.message}`);
  }
  
  console.log('[tasksService] Task deleted successfully');
  return Promise.resolve();
}

// New function to fetch tasks by status
export async function fetchTasksByStatus(userId: string, statuses: TaskStatus[]): Promise<Task[]> {
  console.log('Fetching tasks with statuses:', statuses);
  
  const { data, error } = await supabase
    .from('tasks')
    .select(`
      *,
      quest:quests!quest_id (
        id,
        title,
        tagline,
        is_main,
        status,
        start_date,
        end_date
      )
    `)
    .eq('user_id', userId)
    .in('status', statuses)
    .order('scheduled_for', { ascending: true });

  if (error) {
    console.error('Error fetching tasks by status:', error);
    throw error;
  }

  return data || [];
}

// Helper function to get only active tasks (ToDo and InProgress)
export async function fetchActiveTasks(userId: string): Promise<Task[]> {
  return fetchTasksByStatus(userId, ['ToDo', 'InProgress']);
}

// React Hook
export function useTasks(providedUserId?: string) {
  const [tasks, setTasks] = useState<Task[]>([]);
  const [taskListVisible, setTaskListVisible] = useState(true);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const { session } = useSupabase();

  // Use provided userId if available, otherwise fall back to session user
  const userId = providedUserId || session?.user?.id;

  // Load tasks
  const loadTasks = async () => {
    if (!userId) {
      console.warn("useTasks: No userId provided, skipping task load");
      return;
    }
    
    try {
      setLoading(true);
      const data = await fetchTasks(userId);
      setTasks(data);
    } catch (err) {
      console.error('Error loading tasks:', err);
      setError(err instanceof Error ? err.message : 'Failed to load tasks');
    } finally {
      setLoading(false);
    }
  };

  // Initial load and subscription setup
  useEffect(() => {
    if (!userId) return;
    
    loadTasks();

    // Set up real-time subscription for this user's tasks
    const subscription = supabase
      .channel('tasks_changes')
      .on('postgres_changes', 
        { 
          event: '*', 
          schema: 'public', 
          table: 'tasks',
          filter: `user_id=eq.${userId}`
        },
        (payload) => {
          console.log('Task change received:', payload);
          loadTasks(); // Reload all tasks when any change occurs
        }
      )
      .subscribe();

    return () => {
      subscription.unsubscribe();
    };
  }, [userId]);

  return {
    tasks,
    taskListVisible,
    setTaskListVisible,
    loading,
    error,
    reload: loadTasks
  };
}

================
File: components/chat/ChatInterface.tsx
================
import React, { useState, useRef, useEffect } from 'react';
import { 
  View, 
  Text, 
  TextInput, 
  TouchableOpacity, 
  ScrollView, 
  KeyboardAvoidingView, 
  Platform,
  Animated,
  FlatList
} from 'react-native';
import { Card } from 'react-native-paper';
import { MaterialIcons } from '@expo/vector-icons';
import styles, { colors } from '@/app/styles/global';
import { ChatMessage } from '@/app/types';
import { useTheme } from '@/contexts/ThemeContext';
import { useSuggestions } from '@/contexts/SuggestionContext';
import TriangularSpinner from '../loading/TriangularSpinner';
import CompactTaskSuggestion from '../suggestions/CompactTaskSuggestion';
import { TaskSuggestion, QuestSuggestion } from '@/services/agents/SuggestionAgent';
import { CreateTaskModal } from '@/components/modals/CreateTaskModal';
import { fetchQuests } from '@/services/questsService';
import { useSupabase } from '@/contexts/SupabaseContext';
import { personalityService } from '@/services/personalityService';

interface Props {
  recentMessages: ChatMessage[];
  onSendMessage?: (message: string, userId: string) => Promise<void>;
  handleTyping?: (text: string) => void;
  isTyping?: boolean;
  sessionEnded?: boolean;
  checkupCreated?: boolean;
  onEndSession?: () => void;
  onDeleteMessages?: () => void;
  userId: string;
}

export function ChatInterface({ 
  recentMessages,
  onSendMessage, 
  handleTyping,
  isTyping, 
  sessionEnded,
  checkupCreated,
  onEndSession,
  onDeleteMessages,
  userId
}: Props) {
  const [message, setMessage] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [isProcessingSession, setIsProcessingSession] = useState(false);
  const [isEndingSession, setIsEndingSession] = useState(false);
  const scrollViewRef = useRef<ScrollView>(null);
  const { themeColor, secondaryColor } = useTheme();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [currentTaskModal, setCurrentTaskModal] = useState<TaskSuggestion | null>(null);
  const [showTaskModal, setShowTaskModal] = useState(false);
  const [quests, setQuests] = useState<Array<{ id: number; title: string }>>([]);
  const { session } = useSupabase();
  const [personalityName, setPersonalityName] = useState('ASSISTANT');

  // Define message status colors
  const messageColors = {
    user: themeColor,
    assistant: secondaryColor,
    error: '#FF6B6B',
    info: '#64B5F6'
  };

  // Get task and quest suggestions from context
  const { 
    taskSuggestions, 
    questSuggestions,
    acceptTaskSuggestion, 
    rejectTaskSuggestion, 
    upgradeTaskToQuest,
    rejectQuestSuggestion,
    acceptQuestSuggestion,
  } = useSuggestions();

  // Load quests for task modal
  useEffect(() => {
    const loadQuests = async () => {
      if (userId) {
        try {
          const loadedQuests = await fetchQuests(userId);
          setQuests(loadedQuests);
        } catch (err) {
          console.error('Error loading quests:', err);
        }
      }
    };
    
    loadQuests();
  }, [userId]);

  // Add logging when suggestions change
  useEffect(() => {
    console.log('🎯 [ChatInterface] Suggestion state updated:', {
      taskCount: taskSuggestions.length,
      questCount: questSuggestions.length,
    });
  }, [taskSuggestions, questSuggestions]);
  
  // Handle task suggestion actions with logging
  const handleAcceptTask = (task: TaskSuggestion) => {
    console.log('✅ [ChatInterface] Accepting task:', task.title);
    if (userId) {
      setIsSubmitting(true);
      acceptTaskSuggestion(task)
        .finally(() => {
          setIsSubmitting(false);
        });
    }
  };
  
  const handleRejectTask = (taskId: string) => {
    console.log('❌ [ChatInterface] Rejecting task:', taskId);
    rejectTaskSuggestion(taskId);
  };
  
  const handleUpgradeTask = (task: TaskSuggestion) => {
    console.log('⬆️ [ChatInterface] Upgrading task to quest:', task.title);
    upgradeTaskToQuest(task);
  };

  // New method to handle expanding a task suggestion to show details modal
  const handleExpandTask = (task: TaskSuggestion) => {
    console.log('🔍 [ChatInterface] Expanding task suggestion:', task.title);
    setCurrentTaskModal(task);
    setShowTaskModal(true);
  };

  // Handle creating a task from the suggestion in the modal
  const handleCreateTaskFromSuggestion = async (formData: any) => {
    try {
      setIsSubmitting(true);
      console.log('📝 [ChatInterface] Creating task from suggestion with form data:', formData);
      
      if (currentTaskModal) {
        // Pass the form data rather than the original suggestion
        await acceptTaskSuggestion({
          ...currentTaskModal,
          ...formData
        });
        setCurrentTaskModal(null);
        setShowTaskModal(false);
      }
    } catch (error) {
      console.error('Error creating task from suggestion:', error);
    } finally {
      setIsSubmitting(false);
    }
  };

  // Handle quest suggestion actions with logging
  const handleAcceptQuest = (quest: QuestSuggestion) => {
    console.log('✅ [ChatInterface] Accepting quest:', quest.title);
    if (userId) {
      acceptQuestSuggestion(quest);
    }
  };
  
  const handleRejectQuest = (questId: string) => {
    console.log('❌ [ChatInterface] Rejecting quest:', questId);
    rejectQuestSuggestion(questId);
  };

  // Clear message when session ends
  useEffect(() => {
    if (sessionEnded) {
      setMessage('');
    }
  }, [sessionEnded]);
  
  // Scroll to bottom when new messages arrive
  useEffect(() => {
    if (scrollViewRef.current) {
      scrollViewRef.current.scrollToEnd({ animated: true });
    }
  }, [recentMessages]);
  
  // Get bright accent color for better visibility
  const getBrightAccent = (baseColor: string) => {
    const hex = baseColor.replace('#', '');
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    
    if (r + g + b > 500) {
      return baseColor;
    }
    
    const brightR = Math.min(255, r + 100);
    const brightG = Math.min(255, g + 100);
    const brightB = Math.min(255, b + 100);
    
    return `#${brightR.toString(16).padStart(2, '0')}${
      brightG.toString(16).padStart(2, '0')}${
      brightB.toString(16).padStart(2, '0')}`;
  };
  
  const brightAccent = getBrightAccent(themeColor);

  const handleSend = async () => {
    if (message.trim() === '') return;
    
    if (!userId) {
      console.warn("User not logged in. Cannot send message.");
      setError("You must be logged in to send messages");
      return;
    }
    
    const messageToSend = message;
    setMessage('');
    
    if (onSendMessage) {
      try {
        await onSendMessage(messageToSend, userId);
      } catch (err) {
        console.error("Error sending message:", err);
        setError("Failed to send message");
      }
    }
  };

  const handleMessageChange = (text: string) => {
    setMessage(text);
    if (handleTyping) {
      handleTyping(text);
    }
  };

  const handleKeyPress = (e: any) => {
    if (e.nativeEvent.key === 'Enter' && !e.nativeEvent.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  const formatTimestamp = (timestamp: string) => {
    try {
      const date = new Date(timestamp);
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    } catch (e) {
      return '';
    }
  };

  // Debug information for suggestions
  useEffect(() => {
    console.log("Available suggestions:", {
      taskCount: taskSuggestions.length,
      questCount: questSuggestions.length, 
    });
  }, [taskSuggestions, questSuggestions]);
  // Check if we have any suggestions to show
  const hasSuggestions = taskSuggestions.length > 0 || questSuggestions.length > 0 ;

  // Update session processing state when session ends
  useEffect(() => {
    if (sessionEnded && !checkupCreated) {
      setIsProcessingSession(true);
    } else if (checkupCreated) {
      setIsProcessingSession(false);
    }
  }, [sessionEnded, checkupCreated]);

  // Add a wrapper for the onEndSession callback
  const handleEndSession = () => {
    if (!isEndingSession && onEndSession) {
      setIsEndingSession(true);
      onEndSession();
    }
  };

  useEffect(() => {
    if (session?.user?.id) {
      personalityService.getUserPersonality(session.user.id)
        .then(personality => {
          switch(personality) {
            case 'genericAssistant':
              setPersonalityName('ASSISTANT');
              break;
            default:
              setPersonalityName('ASSISTANT');
          }
        })
        .catch(error => {
          console.error('Error getting personality:', error);
          setPersonalityName('ASSISTANT'); // Fallback to default
        });
    }
  }, [session?.user?.id]);

  return (
    <>
      <Card style={{
        flex: 1,
        backgroundColor: '#1E1E1E',
        borderRadius: 8,
        borderWidth: 1, 
        borderColor: '#333333', 
        overflow: 'hidden',
        shadowColor: '#000',
        shadowOffset: {
          width: 0,
          height: 3,
        },
        shadowOpacity: 0.2,
        shadowRadius: 3,
        elevation: 2,
      }}>
        {/* Chat header */}
        <View style={{ 
          flexDirection: 'row',
          alignItems: 'center',
          justifyContent: 'space-between',
          paddingHorizontal: 15,
          paddingVertical: 15,
          borderBottomWidth: 1,
          borderBottomColor: '#333333',
          backgroundColor: '#252525',
        }}>
          <View style={{ flexDirection: 'row', alignItems: 'center', flex: 1 }}>
            <Text style={{ 
              fontSize: 18,
              fontWeight: 'bold',
              color: '#EEEEEE',
              letterSpacing: 0.5,
            }}>
              Chat Assistant
            </Text>
            <View style={{
              height: 3,
              width: 20,
              backgroundColor: themeColor,
              marginLeft: 8,
              borderRadius: 2,
            }} />
            
            <TouchableOpacity 
              style={{
                marginLeft: 15,
                backgroundColor: 'rgba(33, 150, 243, 0.1)',
                borderWidth: 1,
                borderColor: secondaryColor,
                borderRadius: 4,
                paddingVertical: 4,
                paddingHorizontal: 8,
                flexDirection: 'row',
                alignItems: 'center',
                opacity: isEndingSession ? 0.5 : 1,
              }}
              onPress={handleEndSession}
              disabled={!userId || isEndingSession}
            >
              <MaterialIcons 
                name="timer-off" 
                size={16} 
                color={secondaryColor} 
                style={{ marginRight: 4 }} 
              />
              <Text style={{
                color: secondaryColor,
                fontSize: 12,
                fontWeight: 'bold',
              }}>
                End Session
              </Text>
            </TouchableOpacity>

            <TouchableOpacity 
              style={{
                marginLeft: 15,
                backgroundColor: 'rgba(255, 107, 107, 0.1)',
                borderWidth: 1,
                borderColor: '#FF6B6B',
                borderRadius: 4,
                paddingVertical: 4,
                paddingHorizontal: 8,
                flexDirection: 'row',
                alignItems: 'center',
              }}
              onPress={onDeleteMessages}
              disabled={!userId}
            >
              <MaterialIcons 
                name="delete" 
                size={16} 
                color="#FF6B6B"
                style={{ marginRight: 4 }} 
              />
              <Text style={{
                color: '#FF6B6B',
                fontSize: 12,
                fontWeight: 'bold',
              }}>
                Delete Chat
              </Text>
            </TouchableOpacity>
          </View>
        </View>

        <KeyboardAvoidingView 
          style={{ flex: 1 }}
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'} 
        >
          {/* Main content area - split into chat messages and suggestions */}
          <View style={{ flex: 1, flexDirection: 'column' }}>
            {/* Chat messages area - takes up most of the space */}
            <ScrollView 
              style={{ padding: 10, flex: 1, backgroundColor: '#1A1A1A' }} 
              contentContainerStyle={{ paddingBottom: 20 }}
              ref={scrollViewRef}
            >
              {/* Error message */}
              {error && (
                <View style={{
                  padding: 12,
                  marginVertical: 5,
                  borderRadius: 5,
                  backgroundColor: 'rgba(255, 107, 107, 0.1)',
                  borderWidth: 1,
                  borderColor: '#FF6B6B',
                  marginBottom: 16,
                  borderLeftWidth: 3,
                  borderLeftColor: '#FF6B6B',
                }}>
                  <Text style={{
                    color: '#FF6B6B',
                    fontSize: 14,
                    textAlign: 'center',
                  }}>
                    {error}
                  </Text>
                </View>
              )}

              {/* Messages */}
              {recentMessages.map((msg, index) => {
                let messageText = msg.message;
                if (!msg.is_user && messageText) {
                  messageText = messageText.replace(/^["']|["']$/g, '');
                  messageText = messageText.replace(/^Johnny Silverhand's response:\s*/i, '');
                }
                
                return (
                  <View 
                    key={`${msg.id}-${index}`}
                    style={[
                      {
                        padding: 12,
                        marginVertical: 5,
                        borderRadius: 5,
                        maxWidth: '85%',
                        backgroundColor: msg.is_user ? '#252525' : '#2C2C2C',
                        shadowColor: '#000',
                        shadowOffset: { width: 0, height: 1 },
                        shadowOpacity: 0.2,
                        shadowRadius: 2,
                        elevation: 1,
                      },
                      !msg.is_user 
                        ? {
                            alignSelf: 'flex-start',
                            borderLeftWidth: 3,
                            borderColor: secondaryColor,
                            marginRight: '15%',
                            backgroundColor: 'rgba(33, 150, 243, 0.05)',
                          }
                        : {
                            alignSelf: 'flex-end',
                            borderLeftWidth: 3,
                            borderColor: themeColor,
                            marginLeft: '15%',
                            backgroundColor: 'rgba(76, 175, 80, 0.05)',
                          }
                    ]}
                  >
                    <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                      <Text style={{ 
                        color: !msg.is_user ? secondaryColor : themeColor,
                        fontWeight: 'bold',
                        fontSize: 12,
                        letterSpacing: 0.5,
                      }}>
                        {!msg.is_user ? personalityName : 'YOU'}
                      </Text>
                      <Text style={{ color: '#888888', fontSize: 10 }}>
                        {formatTimestamp(msg.updated_at)}
                      </Text>
                    </View>
                    <Text style={{ 
                      fontSize: 15,
                      color: '#DDDDDD',
                      lineHeight: 20,
                    }}>
                      {messageText}
                    </Text>
                  </View>
                );
              })}
              
              {/* Typing indicator */}
              {isTyping && (
                <View 
                  style={[
                    {
                      padding: 12,
                      marginVertical: 5,
                      borderRadius: 5,
                      maxWidth: '85%',
                      backgroundColor: 'rgba(33, 150, 243, 0.05)',
                      shadowColor: '#000',
                      shadowOffset: { width: 0, height: 1 },
                      shadowOpacity: 0.2,
                      shadowRadius: 2,
                      elevation: 1,
                      alignSelf: 'flex-start',
                      borderLeftWidth: 3,
                      borderColor: secondaryColor,
                      marginRight: '15%',
                    },
                  ]}
                >
                  <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                    <Text style={{ 
                      color: secondaryColor,
                      fontWeight: 'bold',
                      fontSize: 12,
                      letterSpacing: 0.5,
                    }}>
                      {personalityName}
                    </Text>
                  </View>
                  <View style={{ flexDirection: 'row', alignItems: 'center', paddingVertical: 4 }}>
                    <TriangularSpinner size={24} color={secondaryColor} />
                    <Text style={{ 
                      fontSize: 15,
                      color: '#BBBBBB',
                      marginLeft: 8,
                    }}>
                      typing
                    </Text>
                  </View>
                </View>
              )}
              
              {/* Session ended notification */}
              {sessionEnded && (
                <View style={{
                  marginTop: 20,
                  padding: 12,
                  borderRadius: 5,
                  backgroundColor: '#282828',
                  borderWidth: 1,
                  borderColor: '#444444',
                  borderLeftWidth: 3,
                  borderLeftColor: messageColors.info,
                }}>
                  <Text style={{
                    color: '#BBBBBB',
                    fontSize: 16,
                    textAlign: 'center',
                    marginBottom: 8,
                  }}>
                    Session ended
                  </Text>
                  
                  {isProcessingSession ? (
                    <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'center', marginTop: 8 }}>
                      <TriangularSpinner size={16} color={messageColors.info} />
                      <Text style={{
                        color: '#999999',
                        fontSize: 14,
                        textAlign: 'center',
                        marginLeft: 8,
                      }}>
                        Processing conversation...
                      </Text>
                    </View>
                  ) : checkupCreated && (
                    <View style={{ marginTop: 8 }}>
                      <Text style={{
                        color: '#BBBBBB',
                        fontSize: 14,
                        textAlign: 'center',
                        marginBottom: 8,
                      }}>
                        A checkup entry has been created in your journal based on this conversation.
                      </Text>
                    </View>
                  )}
                </View>
              )}
            </ScrollView>
            
            {/* Suggestions list area - displayed only when there are suggestions */}
            {hasSuggestions && (
              <View style={{
                maxHeight: 220,
                borderTopWidth: 1,
                borderTopColor: '#333333',
                backgroundColor: '#232323',
              }}>
                <View style={{ 
                  flexDirection: 'row',
                  justifyContent: 'space-between',
                  alignItems: 'center',
                  paddingHorizontal: 15,
                  paddingVertical: 8,
                  backgroundColor: '#252525',
                  borderBottomWidth: 1,
                  borderBottomColor: '#333333',
                }}>
                  <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                    <MaterialIcons name="lightbulb" size={16} color="#FFD700" />
                    <Text style={{ 
                      marginLeft: 6,
                      color: '#EEEEEE',
                      fontWeight: 'bold',
                      fontSize: 14,
                    }}>
                      Suggestions ({taskSuggestions.length + questSuggestions.length})
                    </Text>
                  </View>
                </View>
                
                <ScrollView 
                  horizontal={false}
                  style={{ 
                    maxHeight: 180,
                    backgroundColor: '#1A1A1A',
                  }}
                  contentContainerStyle={{
                    padding: 10,
                    paddingBottom: 15,
                  }}
                >
                  {/* Task Suggestions */}
                  {taskSuggestions.length > 0 && (
                    <View style={{ marginBottom: 12 }}>
                      <View style={{ 
                        flexDirection: 'row', 
                        alignItems: 'center', 
                        marginBottom: 8,
                        paddingHorizontal: 4,
                      }}>
                        <Text style={{ 
                          color: '#AAAAAA', 
                          fontSize: 12, 
                          fontWeight: 'bold',
                        }}>
                          TASKS
                        </Text>
                        <View style={{
                          height: 2,
                          width: 16,
                          backgroundColor: '#2196F3',
                          marginLeft: 6,
                          borderRadius: 1,
                        }} />
                      </View>
                      
                      {taskSuggestions.map((task) => (
                        <View key={task.id} style={{ marginBottom: 8 }}>
                          <CompactTaskSuggestion
                            suggestion={task}
                            onAccept={() => handleAcceptTask(task)}
                            onReject={() => handleRejectTask(task.id)}
                            onExpand={() => handleExpandTask(task)}
                            onUpgradeToQuest={() => handleUpgradeTask(task)}
                          />
                        </View>
                      ))}
                    </View>
                  )}
                  
                  {/* Quest Suggestions */}
                  {questSuggestions.length > 0 && (
                    <View>
                      <View style={{ 
                        flexDirection: 'row', 
                        alignItems: 'center', 
                        marginBottom: 8,
                        paddingHorizontal: 4,
                      }}>
                        <Text style={{ 
                          color: '#AAAAAA', 
                          fontSize: 12, 
                          fontWeight: 'bold',
                        }}>
                          QUESTS
                        </Text>
                        <View style={{
                          height: 2,
                          width: 16,
                          backgroundColor: '#FF9800',
                          marginLeft: 6,
                          borderRadius: 1,
                        }} />
                      </View>
                      
                      {questSuggestions.map((quest) => (
                        <View key={quest.id} style={{ marginBottom: 8 }}>
                          <View style={{
                            backgroundColor: 'rgba(255, 152, 0, 0.05)',
                            borderRadius: 6,
                            borderLeftWidth: 3,
                            borderColor: '#FF9800',
                            shadowColor: '#000',
                            shadowOffset: { width: 0, height: 1 },
                            shadowOpacity: 0.2,
                            shadowRadius: 2,
                            elevation: 1,
                            overflow: 'hidden',
                          }}>
                            <View style={{
                              flexDirection: 'row',
                              alignItems: 'center',
                              padding: 10,
                              paddingHorizontal: 12,
                              borderBottomWidth: 1,
                              borderBottomColor: '#333333',
                            }}>
                              <MaterialIcons name="emoji-events" size={16} color="#FF9800" />
                              <Text style={{
                                fontSize: 12,
                                fontWeight: 'bold',
                                marginLeft: 6,
                                flex: 1,
                                color: '#DDDDDD',
                              }}>
                                {quest.title}
                              </Text>
                              <TouchableOpacity style={{ padding: 2 }} onPress={() => handleRejectQuest(quest.id)}>
                                <MaterialIcons name="close" size={16} color="#999999" />
                              </TouchableOpacity>
                            </View>
                            
                            <View style={{ padding: 12 }}>
                              <Text style={{
                                color: '#AAAAAA',
                                fontSize: 12,
                                marginBottom: 8
                              }}>
                                {quest.tagline}
                              </Text>
                            </View>
                            
                            <View style={{
                              flexDirection: 'row',
                              borderTopWidth: 1,
                              borderTopColor: '#333333',
                            }}>
                              <TouchableOpacity
                                style={{
                                  flexDirection: 'row',
                                  alignItems: 'center',
                                  justifyContent: 'center',
                                  padding: 8,
                                  backgroundColor: 'rgba(255, 152, 0, 0.2)',
                                  flex: 1
                                }}
                                onPress={() => handleAcceptQuest(quest)}
                              >
                                <MaterialIcons name="check" size={14} color="#FF9800" />
                                <Text style={{
                                  color: '#FF9800',
                                  fontSize: 12,
                                  marginLeft: 4,
                                  fontWeight: 'bold'
                                }}>
                                  Accept
                                </Text>
                              </TouchableOpacity>
                            </View>
                          </View>
                        </View>
                      ))}
                    </View>
                  )}
                </ScrollView>
              </View>
            )}
            {/* Chat input */}
            <View style={{
              flexDirection: 'row',
              padding: 10,
              borderTopWidth: 1,
              borderTopColor: '#333333',
              backgroundColor: '#252525'
            }}>
              <TextInput
                style={{
                  flex: 1,
                  padding: 12,
                  backgroundColor: '#1E1E1E',
                  color: '#DDDDDD',
                  borderRadius: 4,
                  fontSize: 15,
                  marginRight: 10,
                  borderWidth: 1,
                  borderColor: '#444444',
                  textAlignVertical: 'center',
                  maxHeight: 100,
                }}
                value={message}
                onChangeText={handleMessageChange}
                onKeyPress={handleKeyPress}
                placeholder={!userId ? "Please log in to chat" : "Type your message..."}
                placeholderTextColor="#666666"
                blurOnSubmit={false}
                multiline={false}
                editable={!sessionEnded && !!userId}
              />
              <TouchableOpacity 
                style={{
                  justifyContent: 'center',
                  alignItems: 'center',
                  backgroundColor: themeColor,
                  borderRadius: 4,
                  paddingHorizontal: 15,
                  shadowColor: '#000',
                  shadowOffset: { width: 0, height: 1 },
                  shadowOpacity: 0.2,
                  shadowRadius: 2,
                  elevation: 1,
                  opacity: sessionEnded || !userId ? 0.5 : 1,
                }} 
                onPress={handleSend}
                disabled={sessionEnded || !userId}
              >
                <MaterialIcons name="send" size={24} color="#FFFFFF" />
              </TouchableOpacity>
            </View>
          </View>
        </KeyboardAvoidingView>
      </Card>

      {/* Task Suggestion Modal */}
      <CreateTaskModal
        visible={showTaskModal}
        onClose={() => {
          setShowTaskModal(false);
          setCurrentTaskModal(null);
        }}
        onSubmit={handleCreateTaskFromSuggestion}
        isSubmitting={isSubmitting}
        quests={quests}
        userId={userId}
        initialData={currentTaskModal ? {
          title: currentTaskModal.title,
          description: currentTaskModal.description,
          scheduled_for: currentTaskModal.scheduled_for,
          deadline: currentTaskModal.deadline,
          location: currentTaskModal.location,
          status: 'ToDo',
          priority: currentTaskModal.priority || 'medium',
          subtasks: currentTaskModal.subtasks,
          user_id: userId
        } : undefined}
      />
    </>
  );
}

================
File: hooks/useChatData.ts
================
import { useState, useCallback, useEffect, useRef } from 'react';
import { ChatMessage } from '@/app/types';
import { useTheme } from '@/contexts/ThemeContext';
import { ChatAgent } from '@/services/agents/ChatAgent';
import { supabase } from '@/lib/supabase';
import { useSupabase } from '@/contexts/SupabaseContext';
import AsyncStorage from '@react-native-async-storage/async-storage';

const INACTIVITY_TIMEOUT = 5 * 60 * 1000;
const JOHNNY_RESPONSE_DELAY = 2000;
const MESSAGE_STAGGER_DELAY = 1000;
const LOCAL_STORAGE_KEY = 'chat_messages_local'; // key for local storage

// New database access functions for ChatAgent
export async function getCurrentMessagesFromDB(userId: string) {
  if (!userId) {
    throw new Error('User ID is required to fetch current messages');
  }
  
  const { data, error } = await supabase
    .from('chat_messages')
    .select('*')
    .is('chat_session_id', null)
    .eq('user_id', userId)
    .order('created_at', { ascending: true });
  
  if (error) {
    throw error;
  }
  
  return data || [];
}


export async function createChatSession(summary: string, tags: string[], userId: string) {
  if (!userId) {
    throw new Error('User ID is required to create a chat session');
  }
  
  const { data, error } = await supabase
    .from('chat_sessions')
    .insert([{ 
      summary,
      tags,
      user_id: userId
    }])
    .select('id')
    .single();
  
  if (error) {
    throw error;
  }
  
  return data;
}

export async function updateMessagesWithSessionId(messageIds: any[], sessionId: string, userId: string) {
  if (!userId || !sessionId || !messageIds || messageIds.length === 0) {
    throw new Error('User ID, session ID, and message IDs are required to update messages');
  }
  
  const { error } = await supabase
    .from('chat_messages')
    .update({ chat_session_id: sessionId })
    .in('id', messageIds)
    .eq('user_id', userId);
  
  if (error) {
    throw error;
  }
  
  return true;
}

export function useChatData() {
  const { themeColor } = useTheme();
  const { session } = useSupabase();
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isTyping, setIsTyping] = useState(false);
  const [currentSessionId, setCurrentSessionId] = useState<string | null>(null);
  const [sessionEnded, setSessionEnded] = useState(false);
  const [checkupCreated, setCheckupCreated] = useState(false);
  const [error, setError] = useState<string | null>(null); // Add error state for auth issues
  const chatAgent = new ChatAgent();
  const inactivityTimerRef = useRef<NodeJS.Timeout | null>(null);
  const currentSessionMessagesRef = useRef<ChatMessage[]>([]);
  const pendingMessagesRef = useRef<ChatMessage[]>([]);
  const johnnyResponseTimerRef = useRef<NodeJS.Timeout | null>(null);
  const lastMessageRef = useRef<string>('');

  // Keep track of current session messages
  const getCurrentSessionMessages = useCallback(() => {
    return messages.filter(msg => !msg.chat_session_id);
  }, [messages]);

  // Keep track of session messages
  useEffect(() => {
    currentSessionMessagesRef.current = getCurrentSessionMessages();
  }, [messages, getCurrentSessionMessages]);

  // Reset inactivity timer with stronger auth check
  const resetInactivityTimer = useCallback(() => {
    // Clear any existing error
    setError(null);
    
    // Strong guard clause for authentication
    if (!session?.user?.id) {
      console.error('Cannot reset inactivity timer: No user ID');
      setError('Authentication required');
      return;
    }

    if (inactivityTimerRef.current) {
      clearTimeout(inactivityTimerRef.current);
    }
    setSessionEnded(false);
    setCheckupCreated(false);

    inactivityTimerRef.current = setTimeout(async () => {
      const userId = session.user.id; // Cache userId for use in closure
      if (!userId) {
        console.error('User ID missing in timer execution');
        return;
      }
      
      const sessionMessages = currentSessionMessagesRef.current;
      if (sessionMessages.length > 0) {
        try {
          // Verify all messages belong to current user before proceeding
          const allMessagesOwnedByUser = sessionMessages.every(msg => 
            !msg.user_id || msg.user_id === userId);
            
          if (!allMessagesOwnedByUser) {
            console.error('Security issue: Found messages not owned by current user');
            return;
          }
          
          // All messages should have the same user_id
          const sessionMessagesWithUserId = sessionMessages.map(msg => ({
            ...msg,
            user_id: userId
          }));
          
          const sessionId = await chatAgent.summarizeAndStoreSession(sessionMessagesWithUserId);
          
          // Update local messages with new session ID
          setMessages(prev => prev.map(msg => 
            sessionMessages.some(sMsg => sMsg.id === msg.id) 
              ? { ...msg, chat_session_id: sessionId }
              : msg
          ));
          setCurrentSessionId(null);
          setSessionEnded(true);
          setCheckupCreated(true); // Mark that we've created a checkup
        } catch (error) {
          console.error('Error summarizing session:', error);
        }
      }
    }, INACTIVITY_TIMEOUT);
  }, [session?.user?.id]);

  // End session with stronger auth check
  const endSession = useCallback(async () => {
    // Strong guard clause for authentication
    if (!session?.user?.id) {
      console.error('Cannot end session: No user ID');
      setError('Authentication required to end session');
      return;
    }

    const userId = session.user.id;
    const sessionMessages = currentSessionMessagesRef.current;
    
    // Set session ended state immediately
    setSessionEnded(true);
    
    // If no messages, just end without creating a record
    if (sessionMessages.length === 0) {
      return;
    }
    
    try {
      // Verify all messages belong to current user
      const allMessagesOwnedByUser = sessionMessages.every(msg => 
        !msg.user_id || msg.user_id === userId);
        
      if (!allMessagesOwnedByUser) {
        console.error('Security issue: Found messages not owned by current user');
        setError('Cannot end session: Message ownership verification failed');
        return;
      }
      
      // Ensure all messages have user_id
      const sessionMessagesWithUserId = sessionMessages.map(msg => ({
        ...msg,
        user_id: userId
      }));
      
      const sessionId = await chatAgent.summarizeAndStoreSession(sessionMessagesWithUserId);
      
      // Update local messages with new session ID
      setMessages(prev => prev.map(msg => 
        sessionMessages.some(sMsg => sMsg.id === msg.id) 
          ? { ...msg, chat_session_id: sessionId }
          : msg
      ));
      setCurrentSessionId(null);
      setCheckupCreated(true); // Mark that we've created a checkup
    } catch (error) {
      console.error('Error summarizing session:', error);
      setError('Failed to end session: ' + (error instanceof Error ? error.message : 'Unknown error'));
    }
  }, [session?.user?.id]);

  // Remove real-time subscription useEffect block completely
  useEffect(() => {
    // Instead load messages from DB and local storage once
    setMessages([]);
    if (!session?.user?.id) {
      console.log('No active user session, skipping message loading');
      return;
    }
    const userId = session.user.id;
    
    const loadLocalMessages = async () => {
      try {
        const key = `${LOCAL_STORAGE_KEY}_${userId}`;
        const stored = await AsyncStorage.getItem(key);
        if (stored) {
          const parsed: ChatMessage[] = JSON.parse(stored);
          const valid = parsed.filter(msg => !msg.chat_session_id && msg.user_id === userId);
          setMessages(valid);
        }
      } catch (err) {
        console.error('Error loading messages from local storage:', err);
      }
    };
    
    const loadDatabaseMessages = async () => {
      try {
        const { data, error } = await supabase
          .from('chat_messages')
          .select('*')
          .eq('user_id', userId)
          .is('chat_session_id', null)
          .order('created_at', { ascending: true });
        if (error) {
          console.error('Error loading messages from database:', error);
          return;
        }
        const valid = data?.filter(msg => msg.user_id === userId) || [];
        setMessages(prev => {
          const map = new Map(prev.map(msg => [String(msg.id), msg]));
          valid.forEach(msg => map.set(String(msg.id), msg));
          return Array.from(map.values()).sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());
        });
      } catch (err) {
        console.error('Exception loading messages from DB:', err);
      }
    };
    
    loadLocalMessages().then(loadDatabaseMessages);
  }, [resetInactivityTimer, session?.user?.id]);

  // Save local messages whenever they change
  useEffect(() => {
    const saveLocal = async () => {
      if (!session?.user?.id) return;
      try {
        const key = `${LOCAL_STORAGE_KEY}_${session.user.id}`;
        await AsyncStorage.setItem(key, JSON.stringify(getCurrentSessionMessages()));
      } catch (err) {
        console.error('Error saving messages to local storage:', err);
      }
    };
    saveLocal();
  }, [messages, getCurrentSessionMessages, session?.user?.id]);

  // Add helper: sync unsynced messages to DB
  const syncMessages = useCallback(async () => {
    if (!session?.user?.id) return;
    const userId = session.user.id;
    try {
      // Read from local storage
      const key = `${LOCAL_STORAGE_KEY}_${userId}`;
      const stored = await AsyncStorage.getItem(key);
      if (!stored) return;
      const localMessages: ChatMessage[] = JSON.parse(stored);
      // For example, assume messages with string id starting with "client" are unsynced
      const unsynced = localMessages.filter(msg => String(msg.id).startsWith('client'));
      for (const msg of unsynced) {
        try {
          const { data, error } = await supabase
            .from('chat_messages')
            .insert([msg])
            .select()
            .single();
          if (error) throw error;
          // Update local state: replace client id with server id
          setMessages(prev => prev.map(m => (m.id === msg.id ? { ...data, id: data.id } : m)));
        } catch (syncError) {
          console.error('Error syncing message:', syncError);
        }
      }
    } catch (err) {
      console.error('Error in syncMessages:', err);
    }
  }, [session?.user?.id]);

  // Handle user typing
  const handleTyping = useCallback((text: string) => {
    // Clear Johnny's response timer if user is typing
    if (johnnyResponseTimerRef.current) {
      clearTimeout(johnnyResponseTimerRef.current);
    }
    // Update the last message reference
    lastMessageRef.current = text;
  }, []);

  // Modify sendMessage to only update local storage & state immediately for AI responses
  const sendMessage = useCallback(async (messageText: string, userId?: string) => {
    // Clear any existing errors first
    setError(null);
    
    // Strong auth check - prefer explicit userId parameter, fallback to session
    const authenticatedUserId = userId || session?.user?.id;
    
    if (!messageText.trim() || !authenticatedUserId) {
      const errorMsg = !authenticatedUserId 
        ? 'Authentication required to send messages'
        : 'Message cannot be empty';
        
      console.error(`Cannot send message: ${errorMsg}`);
      setError(errorMsg);
      return;
    }
    
    // Use a client-generated numeric id (negative) for optimistic update
    const clientUserId = -Date.now();
    const userMessage: ChatMessage = {
      id: clientUserId,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      is_user: true,
      message: messageText.trim(),
      chat_session_id: currentSessionId || undefined,
      user_id: authenticatedUserId
    };

    // OPTIMISTIC UPDATE: Add message to local state first for immediate UI update
    setMessages(prev => [...prev, userMessage]);
    
    // Add to pending messages for AI response
    pendingMessagesRef.current.push(userMessage);

    // Instead of awaiting DB insert immediately, let the sync function handle it later
    // (Optional: you can trigger syncMessages() after a delay if desired.)

    // Clear any existing timer
    if (johnnyResponseTimerRef.current) {
      clearTimeout(johnnyResponseTimerRef.current);
    }

    // Set new timer for Johnny's response
    johnnyResponseTimerRef.current = setTimeout(async () => {
      setIsTyping(true);
      try {
        // Get all pending messages and ensure they have user_id
        const pendingMessages = [...pendingMessagesRef.current].map(msg => ({
          ...msg,
          user_id: authenticatedUserId
        }));
        
        const combinedMessage = pendingMessages
          .map(msg => msg.message)
          .join('\n');

        // Clear pending messages
        pendingMessagesRef.current = [];

        // Pass userId explicitly to generateChatResponse
        const responseMessages = await chatAgent.generateChatResponse(combinedMessage, authenticatedUserId);
        
        // Process each message with a delay between them
        for (let i = 0; i < responseMessages.length; i++) {
          const sendAIMessage = async () => {
            const message = responseMessages[i];
            
            // Use a client-generated numeric id (negative) for AI message
            const clientAiId = -(Date.now() + i);
            const aiMessage: ChatMessage = {
              id: clientAiId,
              created_at: new Date().toISOString(),
              updated_at: new Date().toISOString(),
              is_user: false,
              message: message,
              chat_session_id: currentSessionId || undefined,
              user_id: authenticatedUserId // Explicit user ID assignment
            };
            
            // OPTIMISTIC UPDATE: Add AI message to local state immediately
            setMessages(prev => [...prev, aiMessage]);
            
            // Also let syncMessages() handle sending to DB later.
            if (i === responseMessages.length - 1) {
              setIsTyping(false);
            }
          };
          
          setTimeout(sendAIMessage, i * MESSAGE_STAGGER_DELAY);
        }

        resetInactivityTimer();
      } catch (error) {
        console.error('Error in Johnny\'s response:', error);
        
        // Handle error with proper user_id
        const clientErrorId = -Date.now();
        const errorMessage: ChatMessage = {
          id: clientErrorId,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
          is_user: false,
          message: "Damn netrunners must be messing with our connection. Try again in a bit.",
          chat_session_id: currentSessionId || undefined,
          user_id: authenticatedUserId // Explicit user ID assignment
        };

        // OPTIMISTIC UPDATE: Add error message to local state
        setMessages(prev => [...prev, errorMessage]);

        setIsTyping(false);
      }
    }, JOHNNY_RESPONSE_DELAY);

  }, [currentSessionId, resetInactivityTimer, session?.user?.id, getCurrentSessionMessages]);

  // Add a new function to delete current session messages
  const deleteCurrentMessages = useCallback(async () => {
    // Strong guard clause for authentication
    if (!session?.user?.id) {
      console.error('Cannot delete messages: No user ID');
      setError('Authentication required to delete messages');
      return;
    }

    const userId = session.user.id;
    
    try {
      // Clear local storage for current session
      const key = `${LOCAL_STORAGE_KEY}_${userId}`;
      await AsyncStorage.removeItem(key); // Use removeItem to clear the local storage
      await AsyncStorage.setItem(key, ''); // Use setItem to reset the local storage
      // Update state to remove current session messages
      setMessages(prev => prev.filter(msg => msg.chat_session_id !== null));
      
      console.log('Successfully deleted current chat messages');
      
      // End the session without creating a record
      setSessionEnded(true);
    } catch (error) {
      console.error('Error deleting current messages:', error);
      setError('Failed to delete messages: ' + (error instanceof Error ? error.message : 'Unknown error'));
    }
  }, [session?.user?.id]);

  // Cleanup timers on unmount
  useEffect(() => {
    return () => {
      if (johnnyResponseTimerRef.current) {
        clearTimeout(johnnyResponseTimerRef.current);
      }
      if (inactivityTimerRef.current) {
        clearTimeout(inactivityTimerRef.current);
      }
    };
  }, []);

  return {
    messages: getCurrentSessionMessages(), // Only return current session messages
    sendMessage,
    handleTyping,
    endSession,
    isTyping,
    sessionEnded,
    checkupCreated,
    error, // Expose error state for UI feedback
    authenticated: !!session?.user?.id, // Add authentication status
    syncMessages, // Expose sync function so you can trigger it externally if needed
    deleteCurrentMessages // Expose the new function
  };
}

================
File: services/agents/SuggestionAgent.ts
================
// filepath: c:\Users\ThinkPad\Code\QuestLogMockupsWL\QuestLog\services\agents\SuggestionAgent.ts
import OpenAI from 'openai';
import { GoogleGenerativeAI, type GenerativeModel, SchemaType } from "@google/generative-ai";
import { performanceLogger } from '@/utils/performanceLogger';
import { Quest, Task } from '@/app/types';
import { createTask, fetchTasks, updateTask, fetchTasksByQuest } from '@/services/tasksService'; // Import fetchTasksByQuest
import { createQuest, fetchQuests, getOrCreateMiscQuest } from '@/services/questsService';
import { personalityService } from '@/services/personalityService';
import { getPersonality } from '@/services/agents/PersonalityPrompts';
import { globalSuggestionStore } from '../globalSuggestionStore';

/**
 * Represents a task suggestion generated from user content
 */
export interface TaskSuggestion {
  id: string;
  sourceContent: string;
  timestamp: string;
  type: 'task';
  title: string;
  description: string;
  scheduled_for: string;
  deadline?: string;
  location?: string;
  status: 'ToDo';
  tags?: string[];
  quest_id?: number;
  priority: 'high' | 'medium' | 'low';
  subtasks?: string;
  // Add a flag to indicate if this is an edit suggestion for an existing task
  isEditSuggestion?: boolean;
  existingTaskId?: number;
  // Remove editFields property and rely solely on updateValues
  updateValues?: {
    title?: string;
    status?: 'ToDo' | 'InProgress' | 'Done';
    description?: string;
    deadline?: string;
    scheduled_for?: string;
    location?: string;
    priority?: 'high' | 'medium' | 'low';
  };
  previousTaskId?: number; // Reference to the previous task for continuation
  continuesFromTask?: Task; // Reference to the task this suggestion continues from
}

/**
 * Represents a quest suggestion generated from user content
 */
export interface QuestSuggestion {
  id: string;
  sourceContent: string;
  timestamp: string;
  type: 'quest';
  title: string;
  quest_id?: number;
  tagline: string;
  description: string;
  status: 'Active';
  start_date?: string;
  end_date?: string;
  is_main: boolean;
  relatedTasks?: TaskSuggestion[];
}


export interface ConversationMessage {
  role: "user" | "assistant";
  content: string;
  timestamp: string;
}

export interface ConversationData {
  messages: ConversationMessage[];
  metadata: {
    startTime: string;
    endTime: string;
    totalMessages: number;
  };
}


interface TaskContext {
  sourceMessage: string;
  relatedMessages: string[];
  confidence: number;
  dependencies?: string[];
  timing?: string;
}

// Interface to represent task similarity comparison results
interface TaskSimilarityResult {
  isMatch: boolean;
  existingTask: Task | null;
  matchConfidence: number; // 0 to 1
  isContinuation?: boolean; // New field to indicate if this is a continuation
  continuationReason?: string; // Explanation of why this is considered a continuation
}

// Interface for task update field generation
interface TaskUpdateFields {
  shouldUpdate: boolean;
  updateFields: string[];
  updateValues: {
    title?: string;
    status?: 'ToDo' | 'InProgress' | 'Done';
    description?: string;
    deadline?: string;
    scheduled_for?: string;
    location?: string;
    priority?: 'high' | 'medium' | 'low';
  };
}

type Suggestion = TaskSuggestion | QuestSuggestion;

interface TaskGroup {
  content: string;
  context: TaskContext;
}

interface QuestPattern {
  content: string;
  context: {
    sourceMessage: string;
    relatedMessages: string[];
    confidence: number;
  };
}

/**
 * SuggestionAgent handles AI/LLM operations for generating task and quest suggestions.
 * State management is handled by SuggestionContext.
 */
export class SuggestionAgent {
  private genAI: GoogleGenerativeAI;
  private model: GenerativeModel;
  private openai: OpenAI;
  // Add a static instance to implement proper singleton pattern
  private static instance: SuggestionAgent;

  constructor() {
    // Initialize both APIs
    this.genAI = new GoogleGenerativeAI(process.env.EXPO_PUBLIC_GEMINI_API_KEY || '');
    this.model = this.genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
    
    this.openai = new OpenAI({
      apiKey: process.env.EXPO_PUBLIC_DEEPSEEK_API_KEY,
      baseURL: 'https://api.deepseek.com',
      dangerouslyAllowBrowser: true
    });

    console.log("🔧 [SuggestionAgent] Created new agent instance");
  }

  // Static method to get the singleton instance
  public static getInstance(): SuggestionAgent {
    if (!SuggestionAgent.instance) {
      SuggestionAgent.instance = new SuggestionAgent();
      console.log("🔧 Created new SuggestionAgent singleton instance");
    }
    return SuggestionAgent.instance;
  }


  /**
   * Generates a task suggestion from content
   * @param content The source content
   * @param userId The user's ID
   * @returns A task suggestion or null
   */
  public async generateTaskSuggestion(
    content: string,
    userId: string,
    context?: TaskContext
  ): Promise<TaskSuggestion[]> {
    performanceLogger.startOperation('generateTaskSuggestion');
    try {
      const currentDate = new Date().toISOString().split('T')[0];
      
      // Get current personality for task generation
      const personalityType = await personalityService.getUserPersonality(userId);
      const personality = getPersonality(personalityType);

      const prompt = `You are ${personality.name}. ${personality.description}
Current date is: ${currentDate}

Analyze this content and generate ONE OR MORE separate tasks. If multiple distinct tasks are mentioned, create a separate task for each one.

Content: "${content}"

${context ? `Context:
- Source Message: ${context.sourceMessage}
- Related Messages: ${context.relatedMessages.join('\n')}
- Confidence: ${context.confidence}` : ''}

Generate a JSON object with this EXACT format:
{
  "tasks": [
    {
      "title": "Brief task title for first task",
      "description": "Detailed description incorporating context",
      "scheduled_for": "YYYY-MM-DD format date when task should start (must be ${currentDate} or later)",
      "deadline": "YYYY-MM-DD format deadline if mentioned (must be ${currentDate} or later), otherwise null",
      "location": "Location if mentioned, otherwise null",
      "priority": "high, medium, or low based on urgency/importance",
      "tags": ["relevant", "keyword", "tags"],
      "subtasks": "Comma-separated list of subtasks if appropriate, otherwise empty string"
    }
  ]
}

IMPORTANT:
- Write descriptions in your characteristic voice and style
- Create SEPARATE tasks for distinct activities
- Each task should be focused and specific
- Do not combine unrelated tasks into one
- All dates must be ${currentDate} or later
- Never use dates from the past`;

      console.log(`🚀 Generating task suggestion(s). Content: ${JSON.stringify(content)} Context: ${JSON.stringify(context)}\n Prompt: ${prompt}`);

      const response = await this.openai.chat.completions.create({
        model: "deepseek-chat",
        messages: [
          { role: "system", content: prompt },
          { role: "user", content: content }
        ],
        temperature: 0.4,
        max_tokens: 3000,
        response_format: { type: "json_object" }
      });

      const responseText = response.choices[0].message?.content;
      if (!responseText) {
        throw new Error('Empty response from AI');
      }

      try {
        const parsed = JSON.parse(responseText);
        const timestamp = new Date().toISOString();

        // Return empty array if no tasks
        if (!parsed.tasks || parsed.tasks.length === 0) {
          console.log('No tasks generated from content');
          return [];
        }

        // Process all tasks
        const suggestions = parsed.tasks.map((taskData: {
          title: string;
          description: string;
          scheduled_for: string;
          deadline: string | null;
          location: string | null;
          priority: 'high' | 'medium' | 'low';
          tags: string[];
          subtasks: string;
        }) => ({
          id: `task-${timestamp}-${Math.random().toString(36).substring(2, 10)}`,
          sourceContent: content,
          timestamp,
          type: 'task',
          title: taskData.title,
          description: taskData.description,
          scheduled_for: taskData.scheduled_for,
          deadline: taskData.deadline === 'null' ? undefined : taskData.deadline,
          location: taskData.location === 'null' ? undefined : taskData.location,
          status: 'ToDo',
          tags: taskData.tags || [],
          priority: taskData.priority || 'medium',
          subtasks: taskData.subtasks || undefined
        } as TaskSuggestion));

        console.log('✅ Generated task suggestions:', suggestions.map((s: TaskSuggestion) => s.title));
        return suggestions;

      } catch (parseError) {
        console.error('Error parsing task suggestion:', parseError);
        return [];
      }
    } catch (error) {
      console.error('Error generating task suggestion:', error);
      return [];
    } finally {
      performanceLogger.endOperation('generateTaskSuggestion');
    }
  }

  /**
   * Upgrades a task suggestion to a quest suggestion using LLM analysis
   * @param task The task suggestion to upgrade
   * @returns A quest suggestion if successful, null otherwise
   */
  async upgradeTaskToQuest(task: TaskSuggestion, userId: string): Promise<QuestSuggestion | null> {
    performanceLogger.startOperation('upgradeTaskToQuest');
    try {
      const currentDate = new Date().toISOString().split('T')[0];
      
      // Get current personality for quest generation
      const personalityType = await personalityService.getUserPersonality(userId);
      const personality = getPersonality(personalityType);
      
      console.log('⬆️ Upgrading task to quest:', task.title);
      
      const prompt = `You are ${personality.name}. ${personality.description}
Current date is: ${currentDate}

Upgrade this task to a project (a larger goal that might require multiple tasks). 

Task Title: ${task.title}
Task Description: ${task.description}
Scheduled For: ${task.scheduled_for}
${task.deadline ? `Deadline: ${task.deadline}` : ''}
${task.location ? `Location: ${task.location}` : ''}
Priority: ${task.priority}
${task.tags && task.tags.length > 0 ? `Tags: ${task.tags.join(', ')}` : ''}
${task.subtasks ? `Subtasks: ${task.subtasks}` : ''}

Generate a JSON object with these EXACT fields, using your characteristic voice and perspective:
{
  "title": "Project title - can be based on the original task or expanded",
  "tagline": "Short, one-line description of the Project",
  "description": "Detailed description of the overall goal/objective",
  "start_date": "YYYY-MM-DD - must be ${currentDate} or later",
  "end_date": "YYYY-MM-DD - must be after start_date",
  "relatedTasks": [
    {
      "title": "First related task - include the original task here",
      "description": "Description of first task",
      "scheduled_for": "YYYY-MM-DD"
    }
  ]
}

IMPORTANT:
- Write in your unique voice and perspective
- Add subtasks of the original task to the related tasks
- Add 2-3 more related tasks that would help achieve this project
- Make the project a meaningful expansion of the original task
- All dates must be ${currentDate} or later
- Never use dates from the past`;

      const response = await this.openai.chat.completions.create({
        model: "deepseek-chat",
        messages: [
          { role: "system", content: prompt }
        ],
        temperature: 0.3,
        max_tokens: 1500,
        response_format: { type: "json_object" }
      });

      const responseText = response.choices[0].message?.content;
      if (!responseText) {
        throw new Error('Empty response from AI');
      }

      try {
        const parsed = JSON.parse(responseText);
        const timestamp = new Date().toISOString();
        
        // Convert related tasks to TaskSuggestions
        const relatedTasks: TaskSuggestion[] = parsed.relatedTasks.map((taskData: any) => ({
          id: `task-${timestamp}-${Math.random().toString(36).substring(2, 10)}`,
          sourceContent: task.sourceContent,
          timestamp,
          type: 'task',
          title: taskData.title,
          description: taskData.description,
          scheduled_for: taskData.scheduled_for,
          status: 'ToDo',
          priority: task.priority,
          tags: task.tags
        }));

        const suggestion: QuestSuggestion = {
          id: `quest-${timestamp}-${Math.random().toString(36).substring(2, 10)}`,
          sourceContent: task.sourceContent,
          timestamp,
          type: 'quest',
          title: parsed.title,
          tagline: parsed.tagline,
          description: parsed.description,
          status: 'Active',
          start_date: parsed.start_date,
          end_date: parsed.end_date,
          is_main: false,
          relatedTasks
        };

        console.log('✅ Successfully upgraded task to quest:', suggestion.title);
        return suggestion;
      } catch (parseError) {
        console.error('Error parsing upgraded quest:', parseError);
        return null;
      }
    } catch (error) {
      console.error('Error upgrading task to quest:', error);
      return null;
    } finally {
      performanceLogger.endOperation('upgradeTaskToQuest');
    }
  }

  /**
   * Creates a task in the database from a task suggestion
   * @param suggestion The task suggestion to create
   * @param userId The user's ID
   */
  async acceptTaskSuggestion(suggestion: TaskSuggestion, userId: string): Promise<Task | null> {
    try {
      // Check if this is an edit suggestion
      if (suggestion.isEditSuggestion && suggestion.existingTaskId) {
        console.log('📝 Updating existing task from edit suggestion:', suggestion.existingTaskId);
        
        // Get the original task to ensure we have the latest data
        const questId = suggestion.quest_id || (await getOrCreateMiscQuest(userId)).id;
        const questTasks = await fetchTasksByQuest(questId, userId);
        const existingTask = questTasks.find(t => t.id === suggestion.existingTaskId);
        
        if (!existingTask) {
          console.error('Could not find existing task to update');
          return null;
        }
        
        // If updateValues is missing, generate them now
        let updateData: Record<string, any> = {};
        
        if (!suggestion.updateValues) {
          const updateFields = await this.generateTaskUpdateFields(suggestion, existingTask, suggestion.sourceContent, userId);
          if (updateFields.updateValues) {
            updateData = { ...updateFields.updateValues };
          }
        } else {
          updateData = { ...suggestion.updateValues };
        }
        
        // Only perform the update if there are changes to make
        if (Object.keys(updateData).length > 0) {
          updateData.updated_at = new Date().toISOString();
          console.log('Updating task with values:', updateData);
          const updatedTask = await updateTask(suggestion.existingTaskId, updateData, userId);
          return updatedTask;
        } else {
          console.log('No changes needed for the existing task');
          return null;
        }
      }
      
      // If it's not an edit suggestion, proceed with regular task creation
      console.log('📝 Creating task from suggestion:', suggestion.title);
      
      // Get the quest ID, should be determined already during duplicate check
      const finalQuestId = suggestion.quest_id || 
        (await getOrCreateMiscQuest(userId)).id;
      
      const taskData = {
        title: suggestion.title,
        description: suggestion.description,
        scheduled_for: suggestion.scheduled_for,
        deadline: suggestion.deadline,
        location: suggestion.location,
        status: suggestion.status,
        tags: suggestion.tags,
        priority: suggestion.priority,
        subtasks: suggestion.subtasks,
        quest_id: finalQuestId,
        user_id: userId
      };
      
      return await createTask(taskData);
    } catch (error) {
      console.error('Error creating task from suggestion:', error);
      return null;
    }
  }

  /**
   * Find the best quest for a task using LLM analysis
   * @param suggestion The task suggestion
   * @param userId The user's ID
   * @returns Quest ID of the best matching quest, or misc quest if no good match
   */
  public async findBestQuestForTask(suggestion: TaskSuggestion, userId: string): Promise<number> {
    try {
      console.log('🔍 Finding best quest for task:', suggestion.title);
      
      // Get all user quests for analysis
      const quests = await fetchQuests(userId);
      if (!quests || quests.length === 0) {
        console.log('No quests found, using misc quest');
        const miscQuest = await getOrCreateMiscQuest(userId);
        return miscQuest.id;
      }
      
      // Create a task and quest information for the model
      const taskInfo = `Title: ${suggestion.title}
Description: ${suggestion.description || 'No description'}
${suggestion.scheduled_for ? `Scheduled for: ${suggestion.scheduled_for}` : ''}
${suggestion.deadline ? `Deadline: ${suggestion.deadline}` : ''}
${suggestion.location ? `Location: ${suggestion.location}` : ''}`;

      const questsInfo = quests.map(quest => `
ID: ${quest.id}
Title: ${quest.title}
Tagline: ${quest.tagline || 'No tagline'}
Description: ${quest.description || 'No description'}
Status: ${quest.status}
Is Main: ${quest.is_main ? 'Yes' : 'No'}
`).join('\n---\n');

      // Define the schema for structured output
      const questMatcherSchema = {
        type: SchemaType.OBJECT as const,
        description: "Quest matching analysis result",
        properties: {
          questId: {
            type: SchemaType.INTEGER as const,
            description: "The ID of the best matching quest, or null if no good match",
            nullable: true
          },
          confidence: {
            type: SchemaType.NUMBER as const,
            description: "How confident the model is in this match (0-1)",
          },
          reason: {
            type: SchemaType.STRING as const,
            description: "Brief explanation of why this quest is the best fit"
          }
        },
        required: ["questId", "confidence", "reason"]
      };

      // Create a model with the schema for structured output
      const structuredModel = this.genAI.getGenerativeModel({
        model: "gemini-2.0-flash",
        generationConfig: {
          temperature: 0.4,
          responseMimeType: "application/json",
          responseSchema: questMatcherSchema
        }
      });

      // Prepare the prompt text
      const promptText = `You are analyzing a new task to determine which existing quest it belongs to.
Consider these criteria:
1. Theme alignment - does the task directly relate to the quest's purpose?
2. Scope fit - is the task at the right level of detail for the quest?
3. Timeline alignment - does the task fit within the quest's timeframe?

Find the best quest for this task:

New Task:
${taskInfo}

Available Projects:
${questsInfo}`;

      // Generate content with structured output
      const result = await structuredModel.generateContent(promptText);
      const responseText = result.response.text();
      
      if (!responseText) {
        console.log('⚠️ Empty response from Gemini for quest matching');
        const miscQuest = await getOrCreateMiscQuest(userId);
        return miscQuest.id;
      }
      
      // Parse the JSON response - should already be well-structured
      try {
        const parsed = JSON.parse(responseText);
        console.log(`✅ Gemini returned quest match analysis with confidence: ${parsed.confidence}`);
        
        // If a quest was identified with good confidence, use it
        if (parsed.questId && parsed.confidence > 0.7) {
          console.log(`Found matching quest ID ${parsed.questId} with confidence ${parsed.confidence}`);
          console.log(`Reason: ${parsed.reason}`);
          return parsed.questId;
        } else {
          console.log('No confident quest match found. Using misc quest.');
          console.log(`Reason: ${parsed.reason}`);
          const miscQuest = await getOrCreateMiscQuest(userId);
          return miscQuest.id;
        }
      } catch (parseError) {
        console.error('❌ Error parsing Gemini response:', parseError);
        console.error('Raw response:', responseText);
        const miscQuest = await getOrCreateMiscQuest(userId);
        return miscQuest.id;
      }
    } catch (error) {
      console.error('❌ Error finding best quest for task:', error);
      const miscQuest = await getOrCreateMiscQuest(userId);
      return miscQuest.id;
    }
  }

  /**
   * Generates update fields for an existing task based on new source content
   * @param suggestion The new task suggestion
   * @param existingTask The existing task that was found to be a match
   * @param sourceContent The original source content that generated this suggestion
   * @returns Task update field recommendations
   */
  public async generateTaskUpdateFields(
    suggestion: TaskSuggestion, 
    existingTask: Task, 
    sourceContent: string,
    userId: string
  ): Promise<TaskUpdateFields> {
    performanceLogger.startOperation('generateTaskUpdateFields');
    try {
      // Get current personality for update analysis
      const personalityType = await personalityService.getUserPersonality(userId);
      const personality = getPersonality(personalityType);

      // Default result
      const defaultResult: TaskUpdateFields = {
        shouldUpdate: false,
        updateFields: [],
        updateValues: {}
      };
      
      // Check if there's source content to analyze
      if (!sourceContent || !existingTask) {
        console.log('Missing source content or existing task, cannot generate update fields');
        return defaultResult;
      }
      
      console.log(`Analyzing source content to generate updates for task: "${existingTask.title}"`);
      
      // Use Gemini 2.0 Flash to analyze the source content and suggest updates
      const prompt = `You are ${personality.name}. ${personality.description}

Analyze user message to determine how to update an existing task. Use your unique perspective to evaluate these changes.

Existing Task:
Title: ${existingTask.title}
Description: ${existingTask.description || 'None'}
Status: ${existingTask.status}
Scheduled for: ${existingTask.scheduled_for || 'None'}
Deadline: ${existingTask.deadline || 'None'}
Priority: ${existingTask.priority || 'None'}
Location: ${existingTask.location || 'None'}

User Message (that references this task):
"${sourceContent}"

New Task Suggestion Generated:
Title: ${suggestion.title}
Description: ${suggestion.description || 'None'}
Scheduled for: ${suggestion.scheduled_for}
Deadline: ${suggestion.deadline || 'None'}
Priority: ${suggestion.priority}
${suggestion.location ? `Location: ${suggestion.location}` : ''}

Based on the user message and the new suggestion, determine which fields should be updated in the existing task.

IMPORTANT GUIDELINES:
1. Use your characteristic perspective to evaluate changes
2. Only suggest updates for fields that have meaningful new information
3. Use the user message and context to determine what should be updated
4. Only include fields in updateValues that should actually change
5. For status, only use one of these exact values: "ToDo", "InProgress", or "Done"

Reply ONLY with a JSON object in this format:
{
  "shouldUpdate": true/false,
  "updateFields": ["title", "status", "description", "deadline", "scheduled_for", "location"],
  "updateValues": {
    "title": "The new title to use",
    "status": "ToDo/InProgress/Done",
    "description": "The new description to use",
    "deadline": "YYYY-MM-DD",
    "scheduled_for": "YYYY-MM-DD",
    "location": "The new location"
  }
}`;

      try {
        // Use Gemini model for analysis
        const result = await this.model.generateContent(prompt);
        const responseText = this.cleanResponseText(result.response.text().trim());
        
        if (!responseText) {
          console.log('Empty response from AI for update field generation');
          return defaultResult;
        }

        const parsed = JSON.parse(responseText);
        
        if (parsed.shouldUpdate) {
          console.log(`Suggested updates for task "${existingTask.title}":`, parsed.updateValues);
        }
        
        return {
          shouldUpdate: parsed.shouldUpdate || false,
          updateFields: parsed.updateFields || [],
          updateValues: parsed.updateValues || {}
        };
      } catch (parseError) {
        console.error('Error parsing update fields generation result:', parseError);
        return defaultResult;
      }
    } catch (error) {
      console.error('Error generating update fields:', error);
      return {
        shouldUpdate: false,
        updateFields: [],
        updateValues: {}
      };
    } finally {
      performanceLogger.endOperation('generateTaskUpdateFields');
    }
  }

  /**
   * Checks if a newly generated task suggestion is similar to existing tasks
   * @param suggestion The newly generated task suggestion
   * @param userId The user's ID
   * @returns TaskSimilarityResult with match information
   */
  public async checkForDuplicatesBeforeShowing(suggestion: TaskSuggestion, userId: string): Promise<TaskSimilarityResult> {
    try {
      console.log('🔍 Checking if task suggestion is similar to existing active tasks:', suggestion.title);
      
      const allUserTasks = await fetchTasks(userId);
      const activeTasks = allUserTasks.filter(task => 
        task.status === 'ToDo' || task.status === 'InProgress'
      );
      
      if (activeTasks.length === 0) {
        console.log('No active tasks found for comparison');
        return {
          isMatch: false,
          existingTask: null,
          matchConfidence: 0
        };
      }
      
      console.log(`Comparing new task suggestion against ${activeTasks.length} active tasks`);
      
      const prompt = `You are analyzing if a new task suggestion is semantically equivalent to or a continuation of any existing tasks.

New Task Suggestion:
Title: ${suggestion.title}
Description: ${suggestion.description || 'None'}
Scheduled for: ${suggestion.scheduled_for}
Deadline: ${suggestion.deadline || 'None'}
Priority: ${suggestion.priority}
${suggestion.location ? `Location: ${suggestion.location}` : ''}

Existing active tasks:
${activeTasks.map(task => `
Task ID: ${task.id}
Title: ${task.title}
Description: ${task.description || 'None'}
Status: ${task.status}
Scheduled for: ${task.scheduled_for}
Deadline: ${task.deadline || 'None'}
Priority: ${task.priority || 'None'}
${task.location ? `Location: ${task.location}` : ''}
`).join('\n---\n')}

CRITICAL EVALUATION GUIDELINES:
1. Look for SEMANTIC EQUIVALENCE (same task):
   - "Make dinner" and "Cook pasta for dinner" refer to the same task
   - "Bake a cake" and "Bake chocolate cake for tomorrow" refer to the same task

2. Look for TASK CONTINUATIONS (logical next step):
   - "Schedule doctor appointment" -> "Go to doctor appointment"
   - "Buy ingredients for cake" -> "Bake the cake"
   - "Draft email to client" -> "Send client email"

Determine:
1. Is the new task SEMANTICALLY THE SAME as any existing task?
2. If not, is it a LOGICAL CONTINUATION of any existing task?
3. If yes to either, which existing task is it related to?

Reply ONLY with a JSON object in this format:
{
  "isMatch": true/false,
  "matchingTaskId": task id of matching task or null if no match,
  "matchConfidence": 0.0 to 1.0,
  "isContinuation": true/false,
  "continuationReason": "Brief explanation of why this is a continuation, or null if not"
}`;

      try {
        const result = await this.model.generateContent(prompt);
        const responseText = this.cleanResponseText(result.response.text().trim());
        
        if (!responseText) {
          console.log('Empty response from AI for task comparison');
          return {
            isMatch: false,
            existingTask: null,
            matchConfidence: 0
          };
        }

        const parsed = JSON.parse(responseText);
        
        const matchingTask = parsed.isMatch && parsed.matchingTaskId ? 
          activeTasks.find(t => t.id === parsed.matchingTaskId) || 
          activeTasks.find(t => t.id === Number(parsed.matchingTaskId)) :
          null;
        
        return {
          isMatch: !!parsed.isMatch,
          existingTask: matchingTask || null,
          matchConfidence: parsed.matchConfidence || 0,
          isContinuation: !!parsed.isContinuation,
          continuationReason: parsed.continuationReason || null
        };
        
      } catch (parseError) {
        console.error('Error parsing task comparison result:', parseError);
        return {
          isMatch: false,
          existingTask: null,
          matchConfidence: 0
        };
      }
    } catch (error) {
      console.error('Error checking for duplicate tasks:', error);
      return {
        isMatch: false,
        existingTask: null,
        matchConfidence: 0
      };
    }
  }

  /**
   * Regenerates a task suggestion with context from its predecessor
   * @param suggestion Current task suggestion
   * @param previousTask The task this one continues from
   * @param questContext Optional quest context if the task belongs to a quest
   */
  public async regenerateTaskWithContinuationContext(
    suggestion: TaskSuggestion,
    previousTask: Task,
    questContext?: Quest
  ): Promise<TaskSuggestion | null> {
    try {
      const currentDate = new Date().toISOString().split('T')[0];
      console.log('♻️ Regenerating task suggestion with continuation context');
      
      const prompt = `Current date is: ${currentDate}

Generate an improved task description using the context of its predecessor task and Project.

Previous Task:
Title: ${previousTask.title}
Description: ${previousTask.description || 'None'}
Status: ${previousTask.status}
Priority: ${previousTask.priority || 'None'}

${questContext ? `Related Project:
Title: ${questContext.title}
Description: ${questContext.description || 'None'}
Status: ${questContext.status}` : ''}

Current Task Suggestion:
Title: ${suggestion.title}
Description: ${suggestion.description || 'None'}

This task is a continuation or next step after the previous task.
Generate a JSON object with these EXACT fields that incorporates this context:
{
  "title": "Improved task title that shows continuity",
  "description": "Enhanced description that references the previous task",
  "priority": "high/medium/low (based on previous task)",
  "scheduled_for": "YYYY-MM-DD (must be ${currentDate} or later)",
  "tags": ["relevant", "tags", "including", "continuation"]
}

IMPORTANT:
- All dates must be ${currentDate} or later
- Never use dates from the past`;

      const response = await this.openai.chat.completions.create({
        model: "deepseek-chat",
        messages: [
          { role: "system", content: prompt }
        ],
        temperature: 0.4,
        response_format: { type: "json_object" }
      });

      const responseText = response.choices[0].message?.content;
      if (!responseText) {
        throw new Error('Empty response from AI');
      }

      const parsed = JSON.parse(responseText);
      const timestamp = new Date().toISOString();

      // Create new suggestion with improved context
      const enhancedSuggestion: TaskSuggestion = {
        ...suggestion,
        id: `task-${timestamp}-${Math.random().toString(36).substring(2, 10)}`,
        title: parsed.title,
        description: parsed.description,
        scheduled_for: parsed.scheduled_for,
        priority: parsed.priority,
        tags: parsed.tags,
        timestamp,
        previousTaskId: previousTask.id, // Add reference to previous task
        quest_id: previousTask.quest_id // Carry over the quest ID from the previous task
      };

      console.log('✨ Generated enhanced continuation task:', enhancedSuggestion.title);
      return enhancedSuggestion;

    } catch (error) {
      console.error('Error regenerating task with continuation context:', error);
      return null;
    }
  }

  /**
   * Converts a task suggestion into an edit suggestion for an existing task
   * @param suggestion The original task suggestion
   * @param existingTask The existing task that was found to be similar
   * @returns The modified task suggestion as an edit suggestion
   */
  public async convertToEditSuggestion(suggestion: TaskSuggestion, existingTask: Task): Promise<TaskSuggestion> {
    try {
      // Generate update fields based on the source content
      const updateFields = await this.generateTaskUpdateFields(suggestion, existingTask, suggestion.sourceContent, existingTask.user_id);
      
      // Modify the suggestion to indicate it's an edit suggestion and preserve quest context
      suggestion.isEditSuggestion = true;
      suggestion.existingTaskId = existingTask.id;
      suggestion.quest_id = existingTask.quest_id; // Ensure quest_id is carried over
      suggestion.updateValues = updateFields.updateValues;
      
      // Update the title to indicate it's an edit
      suggestion.title = `Update: ${suggestion.title}`;
      
      if (existingTask.title) {
        // Create a more useful description that shows what's being updated
        const updateFieldsList = updateFields.updateValues ? 
          Object.keys(updateFields.updateValues).join(', ') : 
          'No specific fields';
          
        suggestion.description = `Edit to existing task "${existingTask.title}":\n\n${suggestion.description}\n\nFields to update: ${updateFieldsList}`;
      }
      
      // Log for tracking quest context
      console.log('Created edit suggestion with quest context:', {
        taskId: suggestion.id,
        questId: suggestion.quest_id,
        title: suggestion.title
      });
      

      return suggestion;
    } catch (error) {
      console.error('Error converting to edit suggestion:', error);
      // If there's an error, just return the original suggestion
      return suggestion;
    }
  }

  /**
   * Clean response text from model output
   * Handles JSON formatting issues from different model outputs
   */
  private cleanResponseText(text: string): string {
    // Extract JSON content if wrapped in markdown code blocks
    const jsonRegex = /```(?:json)?\s*([\s\S]*?)\s*```/;
    const match = text.match(jsonRegex);
    if (match && match[1]) {
      return match[1].trim();
    }
    
    // If no code block, return the original text
    return text;
  }

  /**
   * Creates a quest in the database from a quest suggestion
   * @param suggestion The quest suggestion to create
   * @param userId The user's ID
   */
  async acceptQuestSuggestion(suggestion: QuestSuggestion, userId: string): Promise<Quest | null> {
    try {
      console.log('📝 Creating quest from suggestion:', suggestion.title);
      
      const questData = {
        title: suggestion.title,
        tagline: suggestion.tagline,
        description: suggestion.description,
        status: suggestion.status,
        start_date: suggestion.start_date,
        end_date: suggestion.end_date,
        is_main: false,
        user_id: userId
      };
      
      const quest = await createQuest(userId, questData);
      
      // Create related tasks if they exist
      if (suggestion.relatedTasks && suggestion.relatedTasks.length > 0) {
        for (const taskSuggestion of suggestion.relatedTasks) {
          await createTask({
            title: taskSuggestion.title,
            description: taskSuggestion.description,
            scheduled_for: taskSuggestion.scheduled_for,
            status: 'ToDo',
            priority: taskSuggestion.priority,
            quest_id: quest.id,
            user_id: userId
          });
        }
      }
      
      return quest;
    } catch (error) {
      console.error('Error creating quest from suggestion:', error);
      return null;
    }
  }

  /**
   * Analyzes a complete conversation for task and quest suggestions
   * @param conversation Structured conversation data from chat session
   * @param userId The user's ID
   */
  public async analyzeConversation(conversation: ConversationData, userId: string): Promise<void> {
    performanceLogger.startOperation('analyzeConversation');
    console.log(`\n=== SuggestionAgent.analyzeConversation ===`);
    console.log(`Analyzing conversation with ${conversation.messages.length} messages`);
    
    try {
      // Get all user messages concatenated for context
      const userMessagesText = conversation.messages
        .filter(msg => msg.role === 'user')
        .map(msg => msg.content)
        .join('\n');
      
      console.log(`Processing ${conversation.messages.length} messages from conversation`);
      
      // Generate suggestions using the complete conversation context
      const [taskGroups, questPatterns] = await Promise.all([
        this.identifyTaskGroups(conversation),
        this.identifyQuestPatterns(conversation)
      ]);

      console.log(`Identified ${taskGroups.length} potential task groups and ${questPatterns.length} quest patterns`);
      
      // Process each identified task group
      for (const group of taskGroups) {
        console.log(`Generating task suggestion for: "${group.content.substring(0, 50)}..."`);
        const suggestions = await this.generateTaskSuggestion(
          group.content,
          userId,
          group.context
        );
        
        if (suggestions && suggestions.length > 0) {
          // Process each suggestion
          for (const suggestion of suggestions) {
            // Process suggestion through the normal pipeline including duplicate checking
            console.log('🔍 Checking for similar existing tasks:', suggestion.title);
            const similarityResult = await this.checkForDuplicatesBeforeShowing(suggestion, userId);
            
            // Handle similarity checks and add to queue as in analyzeJournalEntry
            if (similarityResult.isMatch && similarityResult.existingTask) {
              if (similarityResult.isContinuation) {
                console.log('🔄 Task identified as continuation:', similarityResult.continuationReason);
                
                // Get quest context if available
                const questContext = similarityResult.existingTask.quest_id ? 
                  await fetchQuests(userId).then(quests => 
                    quests.find(q => q.id === similarityResult.existingTask?.quest_id)
                  ) : undefined;
                
                const enhancedSuggestion = await this.regenerateTaskWithContinuationContext(
                  {
                    ...suggestion,
                    continuesFromTask: similarityResult.existingTask
                  },
                  similarityResult.existingTask,
                  questContext
                );
                
                if (enhancedSuggestion) {
                  console.log('✨ Adding continuation task suggestion from chat');
                  globalSuggestionStore.addSuggestion(enhancedSuggestion);
                }
              } else if (similarityResult.matchConfidence > 0.7) {
                console.log(`Found similar existing task (${similarityResult.matchConfidence.toFixed(2)} confidence). Converting to edit suggestion.`);
                const editSuggestion = await this.convertToEditSuggestion(suggestion, similarityResult.existingTask);
                
                globalSuggestionStore.addSuggestion(editSuggestion);
              }
            } else {
              // Find the best quest for this task
              console.log('🔄 Finding best quest match for new task from chat');
              const questId = await this.findBestQuestForTask(suggestion, userId);
              
              const finalSuggestion = {
                ...suggestion,
                quest_id: questId,
              };
              
              console.log('✨ Adding new task suggestion from chat');
              globalSuggestionStore.addSuggestion(finalSuggestion);
            }
          }
        }
      }

      // Process each identified quest pattern
      for (const pattern of questPatterns) {
        console.log(`Generating quest suggestion for: "${pattern.content.substring(0, 50)}..."`);
        
        // Create a quest suggestion directly - we'll use the existing upgradeTaskToQuest method
        // First create a temporary task suggestion to upgrade
        const tempTaskSuggestion: TaskSuggestion = {
          id: `temp-task-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`,
          sourceContent: pattern.content,
          timestamp: new Date().toISOString(),
          type: 'task',
          title: pattern.content.substring(0, 50) + (pattern.content.length > 50 ? '...' : ''),
          description: pattern.content,
          scheduled_for: new Date().toISOString().split('T')[0],
          status: 'ToDo',
          priority: 'medium',
        };
        
        // Upgrade the temporary task to a quest
        const questSuggestion = await this.upgradeTaskToQuest(tempTaskSuggestion, userId);
        
        if (questSuggestion) {
          console.log('✨ Adding new quest suggestion from chat');
          globalSuggestionStore.addSuggestion(questSuggestion);
        }
      }
    } catch (error) {
      console.error('Error in analyzeConversation:', error);
    } finally {
      performanceLogger.endOperation('analyzeConversation');
    }
  }

  /**
   * Identifies potential task groups from a conversation
   * @param conversation The conversation data to analyze
   * @returns Array of task groups
   */
  private async identifyTaskGroups(conversation: ConversationData): Promise<TaskGroup[]> {
    try {
      console.log('🔍 Identifying potential tasks from conversation');
      
      const currentDate = new Date().toISOString().split('T')[0];
      
      const prompt = `Analyze this conversation to identify potential tasks that should be tracked in a task management system.

Focus on identifying:
1. Direct user commitments ("I will...", "I need to...")
2. User agreeing to AI suggestions
3. Explicit task discussions
4. Implicit tasks embedded in conversation
5. Important deadlines or scheduled activities

For each task, extract:
1. The core action or task statement
2. The message that contains this task
3. Any related messages that provide context
4. A confidence score (0-1) indicating how likely this is a real task
5. Any dependencies or related tasks
6. The timing (immediate, short-term, or long-term)

Current date: ${currentDate}

Conversation:
${conversation.messages.map(msg => 
  `${msg.role.toUpperCase()}: ${msg.content}`
).join('\n')}

Return your findings in this exact JSON format:
{
  "tasks": [
    {
      "content": "Core task statement or action",
      "sourceMessage": "The original full message containing the task",
      "relatedMessages": ["First related message", "Second related message"],
      "confidence": 0.8,
      "dependencies": ["Optional related task"],
      "timing": "immediate | short-term | long-term"
    }
  ]
}`;

      console.log('Sending task identification prompt to AI');

      const response = await this.openai.chat.completions.create({
        model: "deepseek-chat",
        messages: [
          { role: "system", content: prompt }
        ],
        temperature: 0.3,
        max_tokens: 2000,
        response_format: { type: "json_object" }
      });

      try {
        // Get the response content
        const responseText = response.choices[0].message?.content || '{}';
        console.log('Task identification response received, parsing...');
        
        // Parse the JSON response
        const parsed = JSON.parse(responseText);
        
        // Check for tasks array in the response with a fallback to empty array
        const tasks = parsed.tasks || [];
        
        console.log(`Found ${tasks.length} potential tasks in conversation`);
        
        // Map the tasks to our TaskGroup format
        return tasks.map((task: any) => ({
          content: task.content || '',
          context: {
            sourceMessage: task.sourceMessage || '',
            relatedMessages: task.relatedMessages || [],
            confidence: task.confidence || 0.5,
            dependencies: task.dependencies,
            timing: task.timing
          }
        }));
      } catch (error) {
        console.error('Error parsing task groups:', error);
        console.error('Response content:', response.choices[0].message?.content);
        // Return empty array on error
        return [];
      }
    } catch (error) {
      console.error('Error identifying task groups:', error);
      return [];
    }
  }

  /**
   * Identifies potential quest patterns from a conversation
   * @param conversation The conversation data to analyze
   * @returns Array of quest patterns
   */
  private async identifyQuestPatterns(conversation: ConversationData): Promise<QuestPattern[]> {
    try {
      console.log('🔍 Identifying potential quests from conversation');
      
      const currentDate = new Date().toISOString().split('T')[0];
      
      const prompt = `Analyze this conversation to identify potential quests (larger goals or projects that could span multiple tasks).

Focus on identifying:
1. Long-term goals or projects mentioned by the user
2. Multi-step projects or initiatives
3. Larger objectives that might involve collaboration with others
4. Projects that will involve multiple separate tasks
5. User's expressed intentions about future achievements
6. AI suggestions that the user shows interest in pursuing

For each potential quest pattern, determine:
1. The core goal or objective (what would define success?)
2. All related messages that discuss this goal
3. Any specific tasks or steps mentioned
4. Timeline indicators (immediate, short-term, long-term)
5. User's level of commitment (0-1 confidence score)

Current date: ${currentDate}

Conversation:
${conversation.messages.map(msg => 
  `${msg.role.toUpperCase()}: ${msg.content}`
).join('\n')}

Return your findings in this exact JSON format:
{
  "quests": [
    {
      "content": "Core quest description or project goal",
      "sourceMessage": "The original full message containing the quest idea",
      "relatedMessages": ["First related message", "Second related message"],
      "confidence": 0.8
    }
  ]
}`;

      console.log('Sending quest identification prompt to AI');

      const response = await this.openai.chat.completions.create({
        model: "deepseek-chat",
        messages: [
          { role: "system", content: prompt }
        ],
        temperature: 0.3,
        max_tokens: 2000,
        response_format: { type: "json_object" }
      });

      try {
        // Get the response content
        const responseText = response.choices[0].message?.content || '{}';
        console.log('Quest identification response received, parsing...');
        
        // Parse the JSON response
        const parsed = JSON.parse(responseText);
        
        // Check for quests array in the response with a fallback to empty array
        const quests = parsed.quests || parsed.questPatterns || [];
        
        console.log(`Found ${quests.length} potential quests in conversation`);
        
        // Map the quests to our QuestPattern format
        return quests.map((quest: any) => ({
          content: quest.content || '',
          context: {
            sourceMessage: quest.sourceMessage || '',
            relatedMessages: quest.relatedMessages || [],
            confidence: quest.confidence || 0.5
          }
        }));
      } catch (error) {
        console.error('Error parsing quest patterns:', error);
        console.error('Response content:', response.choices[0].message?.content);
        // Return empty array on error
        return [];
      }
    } catch (error) {
      console.error('Error identifying quest patterns:', error);
      return [];
    }
  }
}

================
File: services/agents/ChatAgent.ts
================
import OpenAI from 'openai';
import { ChatMessage, JournalEntry, ChatSession, Quest } from '@/app/types';
import { ChatCompletionMessageParam } from 'openai/resources/chat';
import { QuestAgent } from './QuestAgent';
import { SuggestionAgent, ConversationData } from './SuggestionAgent';
import { performanceLogger } from '@/utils/performanceLogger';
import { 
  getCurrentMessagesFromDB, 
  createChatSession,
  updateMessagesWithSessionId
} from '@/hooks/useChatData';
import { PersonalityType, getPersonality } from './PersonalityPrompts';
import { personalityService } from '../personalityService';
import { eventsService, EVENT_NAMES } from '../eventsService';
import { fetchActiveTasks } from '../tasksService';
import {Task} from '@/app/types';
export class ChatAgent {
  private openai: OpenAI;
  private questAgent: QuestAgent;
  
  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.EXPO_PUBLIC_DEEPSEEK_API_KEY,
      baseURL: 'https://api.deepseek.com', // updated per docs
      dangerouslyAllowBrowser: true
    });
    this.questAgent = new QuestAgent();
  }
  
  async generateChatResponse(message: string, userId: string): Promise<string[]> { // Changed return type to string[]
    performanceLogger.startOperation('generateChatResponse');
    try {
      if (!userId) {
        console.error('User ID is required for generateChatResponse');
        return ["Authentication required. Please log in."];
      }

      // Get current personality for this call
      const personalityType = await personalityService.getUserPersonality(userId);
      const personality = getPersonality(personalityType);

      console.log('\n=== ChatAgent.generateChatResponse ===');
      console.log('Current message:', message);
      console.log ('Current Personality:', personality.name);
      // Get messages from localStorage instead of DB
      performanceLogger.startOperation('fetchCurrentMessages');
      let currentMessages: ChatMessage[] = [];
      try {
        const storedMessages = localStorage.getItem(`chat_messages_local_${userId}`);
        if (storedMessages) {
          currentMessages = JSON.parse(storedMessages);
        }
      } catch (currentError) {
        console.error('Error fetching chat messages from localStorage:', currentError);
        throw currentError;
      }
      performanceLogger.endOperation('fetchCurrentMessages');
        
      // First check for relevant quests based on the message
      let relevantQuests: Quest[] = [];
      console.log('Checking for relevant quests');
      performanceLogger.startOperation('findRelevantQuests');
      try {
        relevantQuests = await this.questAgent.findRelevantQuests(message, userId);
        console.log('Found relevant quests:', relevantQuests.map(q => q.title));
      } catch (error) {
        console.error('Error finding relevant quests:', error);
        relevantQuests = [];
      } finally {
        performanceLogger.endOperation('findRelevantQuests');
      }

      // Get active tasks alongside quests
      let activeTasks: Task[] = [];
      console.log('Fetching active tasks');
      performanceLogger.startOperation('fetchActiveTasks');
      try {
        activeTasks = await fetchActiveTasks(userId);
        console.log('Found active tasks:', activeTasks.length);
      } catch (error) {
        console.error('Error fetching active tasks:', error);
        activeTasks = [];
      } finally {
        performanceLogger.endOperation('fetchActiveTasks');
      }

      
      // Format quest context 
      performanceLogger.startOperation('buildContext');
      let questContext = '';
      if (relevantQuests.length > 0) {
        questContext = '\nRELEVANT PROJECT AND TASK DETAILS:\n' + relevantQuests.map(quest => {
          let questInfo = `\nProject: ${quest.title}\n`;
          questInfo += `Description: ${quest.description || 'No description available'}\n`;
          questInfo += `Current Status: ${quest.status || 'Unknown'}\n`;
          
          if (quest.relevantTasks && quest.relevantTasks.length > 0) {
            questInfo += '\nRelevant Tasks:\n';
            quest.relevantTasks.forEach(task => {
              questInfo += `- ${task.name}\n`;
              questInfo += `  Description: ${task.description}\n`;
              questInfo += `  Why Relevant: ${task.relevance}\n`;
            });
          }
          
          if (quest.relevance) {
            questInfo += `\nRelevance: ${quest.relevance}\n`;
          }
          console.log('Quest info:', questInfo);
          return questInfo;
        }).join('\n---\n');
      }

      // Add tasks context
      let tasksContext = '';
      if (activeTasks.length > 0) {
        tasksContext = '\nACTIVE / CURRENT TASKS (this is what the user is working on right now):\n' + activeTasks.map(task => {
          let taskInfo = `- ${task.title}\n`;
          if (task.description) {
            taskInfo += `  Description: ${task.description}\n`;
          }
          taskInfo += `  Status: ${task.status}\n`;
          if (task.quest?.title) {
            taskInfo += `  Part of Quest: ${task.quest.title}\n`;
          }
          console.log('Task info:', taskInfo);
          return taskInfo;
        }).join('\n');
      }

      // Format messages for chat history
      const chatMessages = currentMessages?.map(msg => ({
        role: msg.is_user ? ("user" as const) : ("assistant" as const),
        content: msg.message
      })) || [];
      performanceLogger.endOperation('buildContext');

      // Build the final messages array with personality-based system prompt
      const messages: ChatCompletionMessageParam[] = [
        {
          role: "system",
          content: personality.prompts.chat.system + `

Background context from possibly relevant projects (only if relevant to current conversation):
${questContext ? '\n' + questContext + '\n' : ''}
Background context from possibly relevant tasks (only if relevant to current conversation):
${tasksContext ? '\n' + tasksContext + '\n' : ''}`
        }
      ];
      
      // Add all previous messages from this chat session
      if (chatMessages.length > 0) {
        console.log('Adding previous messages to context:', chatMessages.length);
        messages.push(...chatMessages.map(msg => ({
          role: msg.role,
          content: msg.content
        })));
      }
      
      console.log('\n=== SENDING TO LLM ===');
      console.log('Full prompt data:', messages);
      
      // Get response from OpenAI with enhanced context
      performanceLogger.startOperation('aiResponse');
      const response = await this.openai.chat.completions.create({
        model: "deepseek-chat",
        messages: messages,
        temperature: 0.7,
        max_tokens: 400
      });
      performanceLogger.endOperation('aiResponse');

      // Get the response content and remove surrounding quotes if they exist
      performanceLogger.startOperation('processResponse');
      const responseText = response.choices[0].message?.content || "Listen up, got nothing to say right now. Come back when you've got something interesting.";
      console.log('Received AI response:', responseText);
      
      // Split response into separate messages by line breaks
      const cleanedResponse = responseText.replace(/^["'](.*)["']$/, '$1');
      const splitMessages = cleanedResponse
        .split(/\n+/) // Split on one or more newlines
        .map(msg => msg.trim())
        .filter(msg => msg.length > 0);
      performanceLogger.endOperation('processResponse');

      console.log('Split into messages:', splitMessages);
      
      return splitMessages;
    } catch (error) {
      console.error('Error in generateChatResponse:', error);
      return ["Error."];
    } finally {
      performanceLogger.endOperation('generateChatResponse');
    }
  }

  async summarizeAndStoreSession(messages: ChatMessage[]): Promise<string> {
    performanceLogger.startOperation('storeSession');

    // Get the user_id right away for the event
    const userId = messages[0]?.user_id;
    if (!userId) {
      throw new Error('No user_id found in messages');
    }

    try {
      if (!messages || messages.length === 0) {
        throw new Error('No messages to store');
      }

      // Verify all messages belong to the same user
      const invalidMessages = messages.filter(msg => msg.user_id !== userId);
      if (invalidMessages.length > 0) {
        throw new Error('Session contains messages from multiple users');
      }

      console.log('\n=== ChatAgent.storeSession ===');
      
      // Generate simple timestamp-based summary instead of using LLM
      const messageCount = messages.length;
      const timestamp = new Date().toLocaleString();
      const summary = `Chat session with ${messageCount} messages on ${timestamp}`;
      
      // Use basic message content keywords as tags instead of LLM-generated ones
      const userMessages = messages.filter(m => m.is_user).map(m => m.message).join(' ');
      const commonWords = ['the', 'and', 'to', 'a', 'of', 'I', 'you', 'is', 'in', 'it', 'that', 'for', 'was'];
      const potentialTags = userMessages
        .toLowerCase()
        .replace(/[^\w\s]/g, '')
        .split(/\s+/)
        .filter(word => word.length > 3 && !commonWords.includes(word))
        .filter((word, i, arr) => arr.indexOf(word) === i) // Unique only
        .slice(0, 5); // Limit to 5 tags

      performanceLogger.startOperation('dbOperations');
      // Create session in database
      let sessionData;
      try {
        sessionData = await createChatSession(summary, potentialTags, userId);
      } catch (sessionError) {
        throw sessionError;
      }

      // Update all messages with the session ID
      try {
        await updateMessagesWithSessionId(messages.map(m => m.id), sessionData.id, userId);
      } catch (updateError) {
        throw updateError;
      }
      performanceLogger.endOperation('dbOperations');
      
      // After successfully storing the session, analyze it for possible suggestions
      this.generateSuggestionsFromChatSession(messages, userId);

      return sessionData.id;
    } catch (error) {
      console.error('Error in storeSession:', error);
      throw error;
    } finally {
      performanceLogger.endOperation('storeSession');
    }
  }
  
  /**
   * Analyzes a completed chat session and generates task/quest suggestions
   * @param messages Array of chat messages from the session
   * @param userId User ID
   */
  private async generateSuggestionsFromChatSession(messages: ChatMessage[], userId: string): Promise<void> {
    if (!messages || messages.length === 0 || !userId) {
      console.log('No messages or user ID available for suggestion generation');
      return;
    }
    
    console.log(`\n=== ChatAgent.generateSuggestionsFromChatSession ===`);
    console.log(`Analyzing ${messages.length} messages for potential suggestions`);
    
    try {
      // Format the messages into a conversation data structure
      const conversationData: ConversationData = {
        messages: messages.map(msg => ({
          role: msg.is_user ? "user" as const : "assistant" as const,
          content: msg.message,
          timestamp: msg.created_at
        })),
        metadata: {
          startTime: messages[0]?.created_at || new Date().toISOString(),
          endTime: messages[messages.length - 1]?.created_at || new Date().toISOString(),
          totalMessages: messages.length
        }
      };
      
      // Get the suggestion agent singleton instance
      const suggestionAgent = SuggestionAgent.getInstance();
      
      // Analyze the conversation for task and quest suggestions
      await suggestionAgent.analyzeConversation(conversationData, userId);
      
    } catch (error) {
      console.error('Error generating suggestions from chat session:', error);
      // Don't throw the error to avoid breaking the session storage process
    }
  }
}



================================================================
End of Codebase
================================================================
