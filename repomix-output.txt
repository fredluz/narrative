This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: components/chat/ChatInterface.tsx, services/agents/ChatAgent.ts, services/agents/QuestAgent.ts, services/agents/SuggestionAgent.ts, services/tasksService.ts, services/questsService.ts
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
components/chat/ChatInterface.tsx
services/agents/ChatAgent.ts
services/agents/QuestAgent.ts
services/agents/SuggestionAgent.ts
services/questsService.ts
services/tasksService.ts

================================================================
Files
================================================================

================
File: services/agents/QuestAgent.ts
================
import OpenAI from 'openai';
import { GoogleGenerativeAI, type GenerativeModel, SchemaType } from "@google/generative-ai";
import { 
  createQuest,
  updateQuest,
  deleteQuest,
  moveTasksToQuest,
  getQuestsWithTasks,
  getOrCreateMiscQuest,
} from '@/services/questsService';
import type { Quest, Task } from '@/app/types';
import { globalSuggestionStore } from '@/services/globalSuggestionStore';

interface TaskRelevanceItem {
    taskId: number;
    name: string;
    description: string;
    relevance: string;
}

interface QuestRelevanceItem {
    questId: number;
    isRelevant: boolean;
    relevance?: string | null;
    relevantTasks: TaskRelevanceItem[];
}

interface TaskMoveInfo {
    taskId: number;
    reason: string;
}

interface QuestMemo {
    id: string;
    content: string;
    created_at: string;
    source: string;
}

interface ContentAnalysis {
    questId: number;
    updates: {
        description_sugg?: string;
        analysis_sugg?: string;
    };
    confidence: number;
}

export class QuestAgent {
    private openai: OpenAI;
    private actuallyOAI: OpenAI;
    private genAI: GoogleGenerativeAI;
    private geminiModel: GenerativeModel;

    constructor() {
        this.openai = new OpenAI({
            apiKey: process.env.EXPO_PUBLIC_DEEPSEEK_API_KEY,
            baseURL: 'https://api.deepseek.com',
            dangerouslyAllowBrowser: true
        });
        this.actuallyOAI = new OpenAI({
            apiKey: process.env.EXPO_PUBLIC_OPENAI_API_KEY,
            dangerouslyAllowBrowser: true
        });
        
        // Initialize Gemini
        this.genAI = new GoogleGenerativeAI(process.env.EXPO_PUBLIC_GEMINI_API_KEY || '');
        this.geminiModel = this.genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
        
        console.log('üîß [QuestAgent] Initialized with OpenAI, OpenAI actual, and Gemini models');
    }

    async createQuest(userId: string, questData: {
        title: string;
        tagline: string;
        description?: string;
        status?: 'Active' | 'On-Hold' | 'Completed';
        is_main?: boolean;
        analysis?: string;
        start_date?: string;
        end_date?: string;
        parent_quest_id?: number;
        tags?: string[];
        user_id?: string;
    }): Promise<Quest> {
        if (!userId) {
            console.error('User ID is required for createQuest');
            throw new Error('User ID is required');
        }
        
        try {
            console.log('üöÄ Creating new quest:', questData.title);

            // Create the quest first
            const newQuest = await createQuest(userId, {
                ...questData,
                status: questData.status || 'Active',
                is_main: questData.is_main || false,
            });

            // Check misc quest for relevant tasks
            const miscQuest = await getOrCreateMiscQuest(userId);
            if (miscQuest.tasks && miscQuest.tasks.length > 0) {
                console.log('üìã Checking misc quest tasks for relevance to new quest');

                // Filter tasks by user_id
                const userTasks = miscQuest.tasks.filter(task => task.user_id === userId);

                if (userTasks.length > 0) {
                    const prompt = `

New Quest Details:
Title: ${questData.title}
Tagline: ${questData.tagline}
Description: ${questData.description || 'No description'}
Analysis: ${questData.analysis || 'No Analysis'}
Tags: ${questData.tags?.join(', ') || 'No tags'}

Misc Tasks to Analyze:
${userTasks.map(task => `ID: ${task.id}
Title: ${task.title}
Description: ${task.description || 'No description'}`).join('\n\n')}
.`;

                    try {
                        console.log('üì§ Sending task analysis to AI');
                        const result = await this.openai.chat.completions.create({
                            model: "deepseek-chat",
                            messages: [
                                {
                                    role: "system",
                                    content: `You are analyzing tasks from a miscellaneous quest collection to see if they would be better suited for a newly created quest.
For each task, determine if it would be better suited in the new quest based on:
1. Direct relevance to the new quest's title or description
2. Thematic alignment with the quest's purpose
3. Similar tags or keywords
4. Logical grouping with the quest's scope

RESPOND ONLY WITH A JSON OBJECT IN THIS EXACT FORMAT:
{
  "tasksToMove": [
    {
      "taskId": number,
      "reason": "Clear explanation of why this task fits better in the new quest"
    }
  ]
}

Be SELECTIVE - only include tasks that have a CLEAR and STRONG connection to the new quest.`
                                },
                                {
                                    role: "user",
                                    content: prompt
                                }
                            ],
                            temperature: 0.7,
                            max_tokens: 2000
                        });
                        
                        const aiResponse = this.cleanResponseText(result.choices[0].message?.content ?? '');
                        
                        try {
                            const parsed = JSON.parse(aiResponse);
                            if (parsed.tasksToMove && Array.isArray(parsed.tasksToMove) && parsed.tasksToMove.length > 0) {
                                console.log(`üîÑ Moving ${parsed.tasksToMove.length} tasks from misc to new quest`);
                                
                                // Move tasks one by one
                                const tasksToMove = parsed.tasksToMove
                                    .map((moveInfo: TaskMoveInfo) => moveInfo.taskId)
                                    .filter((taskId: number) => userTasks.some(t => t.id === taskId));

                                if (tasksToMove.length > 0) {
                                    await moveTasksToQuest(miscQuest.id, newQuest.id, userId, tasksToMove);
                                    console.log(`‚úÖ Moved ${tasksToMove.length} tasks to new quest`);
                                }
                            }
                        } catch (parseError) {
                            console.error('‚ùå Error parsing AI response:', parseError);
                            // Don't throw - we still created the quest successfully
                        }
                    } catch (aiError) {
                        console.error('‚ùå Error analyzing tasks with AI:', aiError);
                        // Don't throw - we still created the quest successfully
                    }
                }
            }

            console.log('‚úÖ Quest created successfully:', newQuest.id);
            return newQuest;
        } catch (error) {
            console.error('‚ùå Error creating quest:', error);
            throw error;
        }
    }

    async updateQuest(questId: number, userId: string, questData: {
        title?: string;
        tagline?: string;
        description?: string;
        description_sugg?: string;
        status?: 'Active' | 'On-Hold' | 'Completed';
        is_main?: boolean;
        analysis?: string;
        analysis_sugg?: string;
        start_date?: string;
        end_date?: string;
        parent_quest_id?: number;
        tags?: string[];
        user_id?: string;
    }): Promise<Quest> {
        // Check if userId exists
        if (!userId) {
            console.error('User ID is required for updateQuest');
            throw new Error('User ID is required');
        }
        
        try {
            console.log('üîÑ Updating quest:', questId);

            // Use questsService instead of direct database call
            const quest = await updateQuest(questId, userId, questData);

            console.log('‚úÖ Quest updated successfully:', quest.id);
            return quest;
        } catch (error) {
            console.error('‚ùå Error updating quest:', error);
            throw error;
        }
    }

    async deleteQuest(questId: number, userId: string): Promise<void> {
        // Check if userId exists
        if (!userId) {
            console.error('User ID is required for deleteQuest');
            throw new Error('User ID is required');
        }
        
        try {
            console.log('üóëÔ∏è Deleting quest:', questId);

            // Get the misc quest first to ensure it exists
            const miscQuest = await getOrCreateMiscQuest(userId);
            
            // First, move any tasks to the misc quest
            await moveTasksToQuest(questId, miscQuest.id, userId);
            
            // Then delete the quest
            await deleteQuest(questId, userId);
            
            console.log('‚úÖ Quest deleted successfully');
        } catch (error) {
            console.error('‚ùå Error deleting quest:', error);
            throw error;
        }
    }

    private async validateAndRepairJson(rawResponse: string | object, questId: number): Promise<QuestRelevanceItem | null> {
        // If rawResponse is already an object, validate its structure directly
        if (typeof rawResponse === 'object') {
            console.log('üîç Validating JavaScript object');
            try {
                const response = rawResponse as QuestRelevanceItem;
                // Verify the required fields are present and of correct type
                if (typeof response.questId !== 'number' || 
                    typeof response.isRelevant !== 'boolean' || 
                    !Array.isArray(response.relevantTasks)) {
                    console.log('‚ùå Object is missing required fields or has wrong types');
                    return null;
                }
                console.log('‚úÖ Object validated successfully');
                return response;
            } catch (error) {
                console.error('‚ùå Error validating object:', error);
                return null;
            }
        }

        // If rawResponse is a string, proceed with LLM validation
        console.log('üîç Validating JSON response:', rawResponse);
        
        const prompt = `You are a JSON validator and repair system. Your job is to:
1. Check if the input is valid JSON
2. If it's valid, ensure it matches the expected format
3. If it's invalid but fixable, repair it
4. If it's beyond repair, return null

Expected JSON format:
{
  "questId": ${questId},
  "isRelevant": boolean,
  "relevance": string | null,
  "relevantTasks": [
    {
      "taskId": number,
      "name": string,
      "description": string,
      "relevance": string
    }
  ]
}

Input to validate: "${rawResponse}"

IMPORTANT: Your response must be EXACTLY in this format:
START JSON
{valid json object or the word 'null'}
END JSON

DO NOT add any backticks, quotes, or other markers around the JSON.`;

        try {
            console.log('üì§ Sending JSON validation request to AI');
            const result = await this.openai.chat.completions.create({
                model: "deepseek-chat",
                messages: [
                    {
                        role: "system",
                        content: "You are a JSON validator and repair system."
                    },
                    {
                        role: "user",
                        content: prompt
                    }
                ],
                temperature: 0.7,
                max_tokens: 2000
            });
            const validatedResponse = result.choices[0].message?.content ?? '';

            if (!validatedResponse) {
                console.log('‚ùå No response received from validator');
                return null;
            }

            // Extract content between markers
            const startMarker = "START JSON";
            const endMarker = "END JSON";
            const startIndex = validatedResponse.indexOf(startMarker);
            const endIndex = validatedResponse.indexOf(endMarker);

            if (startIndex === -1 || endIndex === -1) {
                console.log('‚ùå Validator response missing markers');
                return null;
            }

            const jsonContent = validatedResponse
                .substring(startIndex + startMarker.length, endIndex)
                .trim();

            if (jsonContent === 'null') {
                console.log('‚ùå JSON validation failed - response cannot be repaired');
                return null;
            }

            try {
                const parsed = JSON.parse(jsonContent) as QuestRelevanceItem;
                // Verify the required fields are present and of correct type
                if (typeof parsed.questId !== 'number' || 
                    typeof parsed.isRelevant !== 'boolean' || 
                    !Array.isArray(parsed.relevantTasks)) {
                    console.log('‚ùå Repaired JSON is missing required fields or has wrong types');
                    return null;
                }
                console.log('‚úÖ JSON validated and parsed successfully');
                return parsed;
            } catch (parseError) {
                console.error('‚ùå Error parsing validated JSON:', parseError);
                return null;
            }
        } catch (error) {
            console.error('‚ùå Error in JSON validation:', error);
            return null;
        }
    }

    private cleanResponseText(response: string): string {
        console.log('üßπ Cleaning response text of markdown/code markers');
        // Remove common markdown/code block markers
        return response
            .replace(/^```(?:json)?/gm, '') // Remove opening code block
            .replace(/```$/gm, '')          // Remove closing code block
            .replace(/^`{1,2}/gm, '')      // Remove inline code marks at start
            .replace(/`{1,2}$/gm, '')      // Remove inline code marks at end
            .trim();
    }

    private async analyzeMiscQuestTasks(journalContent: string, miscQuest: Quest, userId: string): Promise<QuestRelevanceItem | null> {
        console.log('üîç Analyzing Misc quest tasks specifically');
        
        if (!miscQuest.tasks || miscQuest.tasks.length === 0) {
            console.log('‚ùå No tasks found in Misc quest');
            return null;
        }

        // Filter tasks by user_id
        const userTasks = miscQuest.tasks;

        try {
            console.log('üì§ Sending misc tasks analysis to AI');
            const result = await this.actuallyOAI.responses.create({
                model: "gpt-4o-mini-2024-07-18",
                input: [
                    {
                        role: "developer",
                        content: [
                            {
                                type: "input_text", 
                                text: `You are analyzing tasks from a miscellaneous quest collection to determine their relevance to a journal entry.
Be VERY selective - only include tasks with clear, direct relevance to the journal entry.`
                            }
                        ]
                    },
                    {
                        role: "user",
                        content: `Review these tasks for relevance to this journal entry:

Journal Entry: "${journalContent}"

Tasks to analyze:
${userTasks.map(task => `ID: ${task.id}
Title: ${task.title}
Description: ${task.description || 'No description'}`).join('\n\n')}`
                    }
                ],
                text: {
                    
                    format: {
                        type: "json_schema",
                        name: "quest_relevance",
                        strict: true,
                        schema: {
                            type: "object",
                            properties: {
                                questId: { type: "number", enum: [miscQuest.id] },
                                isRelevant: { type: "boolean" },
                                relevance: { type: ["string", "null"] }, // Changed from nullable: true
                                relevantTasks: {
                                    type: "array",
                                    items: {
                                        type: "object",
                                        properties: {
                                            taskId: { type: "number" },
                                            name: { type: "string" },
                                            description: { type: "string" },
                                            relevance: { type: "string" }
                                        },
                                        required: ["taskId", "name", "description", "relevance"]
                                    }
                                }
                            },
                            required: ["questId", "isRelevant", "relevantTasks", "relevance"], // Added relevance to required fields
                            additionalProperties: false
                        },
                    },
                },
                temperature: 0.4
            });
            
            // The response is already a JSON object, no need to parse
            return result.output_text ? JSON.parse(result.output_text) : null;
        } catch (error) {
            console.error('‚ùå Error analyzing misc tasks:', error);
            return null;
        }
    }

    private async analyzeRegularQuest(journalContent: string, quests: Quest[], userId: string): Promise<QuestRelevanceItem[]> {
        console.log(`\nüîé Analyzing ${quests.length} quests for relevance using Gemini model`);
        
        try {
            // Define the schema for structured output that matches QuestRelevanceItem[]
            const questRelevanceSchema = {
                type: SchemaType.ARRAY as const,
                description: "Analysis of quests' relevance to journal entry",
                items: {
                    type: SchemaType.OBJECT as const,
                    properties: {
                        questId: {
                            type: SchemaType.INTEGER as const,
                            description: "ID of the quest being analyzed"
                        },
                        isRelevant: {
                            type: SchemaType.BOOLEAN as const,
                            description: "Whether the quest is relevant to the journal entry"
                        },
                        relevance: {
                            type: SchemaType.STRING as const,
                            description: "Explanation of why the quest is relevant, or null if not relevant",
                            nullable: true
                        },
                        relevantTasks: {
                            type: SchemaType.ARRAY as const,
                            description: "List of tasks from this quest that are relevant to the journal entry",
                            items: {
                                type: SchemaType.OBJECT as const,
                                properties: {
                                    taskId: {
                                        type: SchemaType.INTEGER as const,
                                        description: "ID of the relevant task"
                                    },
                                    name: {
                                        type: SchemaType.STRING as const,
                                        description: "Title of the task"
                                    },
                                    description: {
                                        type: SchemaType.STRING as const,
                                        description: "Description of the task"
                                    },
                                    relevance: {
                                        type: SchemaType.STRING as const,
                                        description: "Explanation of why this task is relevant to the journal entry"
                                    }
                                },
                            }
                        }
                    },
                    required: ["questId", "isRelevant", "relevantTasks", "relevance"]
                }
            };

            // Create a model with the schema for structured output
            const structuredModel = this.genAI.getGenerativeModel({
                model: "gemini-2.0-flash",
                generationConfig: {
                    temperature: 0.4,
                    responseMimeType: "application/json",
                    responseSchema: questRelevanceSchema
                }
            });

            // Prepare the prompt text
            const promptText = `Analyze this journal entry's relevance to these quests:

Journal Entry: "${journalContent}"

Quests to Analyze:
${quests.map(quest => `
Quest ID: ${quest.id}
Title: ${quest.title}
Description: ${quest.description || 'No description yet'}
Status: ${quest.status}
Is Main Quest: ${quest.is_main}
Tasks:
${quest.tasks?.map(task => `- Task ID: ${task.id}, Title: ${task.title}, Description: ${task.description || 'No description'}`).join('\n') || 'No tasks'}
---`).join('\n')}

Analyze criteria:
1. Direct mentions of quest title or related keywords
2. Strong connections to quest description
3. Clear references to related activities or goals
4. Current quest status relevance
5. Specific mentions related to individual tasks

IMPORTANT: Be VERY STRICT in your relevance criteria - only include quests or tasks with CLEAR, DIRECT connections, above 90% certainty.
For each quest, determine if it's relevant and which specific tasks are mentioned or implied in the journal entry.`;

            // Generate content with structured output
            const result = await structuredModel.generateContent(promptText);
            const responseText = result.response.text();
            
            if (!responseText) {
                console.log('‚ö†Ô∏è Empty response from Gemini for quest analysis');
                return [];
            }
            
            // Parse the JSON response - should already be well-structured
            try {
                const parsedResults = JSON.parse(responseText) as QuestRelevanceItem[];
                console.log(`‚úÖ Gemini returned analysis for ${parsedResults.length} quests`);
                return parsedResults;
            } catch (parseError) {
                console.error('‚ùå Error parsing Gemini response:', parseError);
                console.error('Raw response:', responseText);
                return [];
            }
        } catch (error) {
            console.error('‚ùå Error analyzing quests with Gemini:', error);
            return [];
        }
    }

    async findRelevantQuests(journalContent: string, userId: string): Promise<Quest[]> {
        if (!userId) {
            console.error('User ID is required for findRelevantQuests');
            return [];
        }
        
        try {
            console.log('üîç QuestAgent: Finding relevant quests for journal entry');
            
            const quests = await getQuestsWithTasks(userId);

            if (!quests || quests.length === 0) {
                console.log('‚ùå No quests found in database');
                return [];
            }

            console.log(`üìã Found ${quests.length} total quests to analyze`);

            // Get the misc quest and separate regular quests
            const miscQuest = await getOrCreateMiscQuest(userId);
            const regularQuests = quests.filter(q => q.id !== miscQuest.id);
            
            // Filter tasks by user_id for all quests
            regularQuests.forEach(quest => {
                quest.tasks = quest.tasks?.filter(task => task.user_id === userId) || [];
            });

            // Store all relevant quest data
            let relevantQuestData: QuestRelevanceItem[] = [];

            // First analyze all regular quests together
            if (regularQuests.length > 0) {
                console.log('üìã Analyzing all regular quests');
                const questAnalyses = await this.analyzeRegularQuest(journalContent, regularQuests, userId);
                relevantQuestData.push(...questAnalyses);
            }

            // Then analyze misc quest tasks if it exists and has tasks
            if (miscQuest.tasks && miscQuest.tasks.length > 0) {
                console.log('üìã Analyzing Misc quest tasks');
                miscQuest.tasks = miscQuest.tasks.filter(task => task.user_id === userId);
                const miscAnalysis = await this.analyzeMiscQuestTasks(journalContent, miscQuest, userId);
                if (miscAnalysis?.isRelevant) {
                    relevantQuestData.push(miscAnalysis);
                }
            }

            // Clean up and return results
            const finalQuestData = relevantQuestData.filter(q => q.isRelevant || q.relevantTasks.length > 0);

            // Map back to Quest type with relevance data, maintaining main quest first if relevant
            const relevantQuests = quests
                .filter(quest => finalQuestData.some(data => data.questId === quest.id))
                .sort((a, b) => {
                    if (a.is_main) return -1;
                    if (b.is_main) return 1;
                    return 0;
                })
                .map(quest => ({
                    ...quest,
                    tasks: quest.tasks?.filter(task => task.user_id === userId) || [],
                    relevance: finalQuestData.find(data => data.questId === quest.id)?.relevance || undefined,
                    relevantTasks: finalQuestData.find(data => data.questId === quest.id)?.relevantTasks || []
                }));

            console.log(`\n‚ú® Found ${relevantQuests.length} relevant quests:`, 
                relevantQuests.map(q => ({ title: q.title, isMain: q.is_main, taskCount: q.relevantTasks?.length })));
            return relevantQuests;

        } catch (error) {
            console.error('‚ùå Error in findRelevantQuests:', error);
            throw error;
        }
    }

    async analyzeContentForQuest(content: string, questId: number, userId: string, source: string): Promise<ContentAnalysis | null> {
        if (!userId) {
            console.error('User ID is required for analyzeContentForQuest');
            return null;
        }

        // Only proceed if this is an end of day entry
        if (source !== 'end-of-day') {
            console.log('Skipping quest analysis - not an end of day entry');
            return null;
        }

        try {
            console.log('üîç Analyzing content for quest updates:', questId);

            // Get the quest
            const quests = await getQuestsWithTasks(userId);
            const quest = quests.find(q => q.id === questId);

            if (!quest) {
                console.error('Quest not found');
                return null;
            }

            const result = await this.openai.chat.completions.create({
                model: "deepseek-reasoner",
                messages: [
                    {
                        role: "system",
                        content: `You are analyzing an end-of-day journal entry to suggest updates to a quest's description and analysis.
1. Information that could update the quest's description
2. New context or insights about the quest that advances its narrative

Generate suggested updates - these will be saved separately and reviewed by the user.
Don't try to maintain the exact existing narrative - instead, focus on incorporating the new information
in a way that adds value.`
                    },
                    {
                        role: "user",
                        content: `Analyze this end-of-day journal entry in relation to an existing quest:

Quest Details:
Title: ${quest.title}
Current Description: ${quest.description || 'No description'}
Current Analysis: ${quest.analysis || 'No analysis'}

New Content to Analyze:
${content}

Generate suggested updates that the user can review. Reply ONLY with a JSON object in this exact format:
{
    "questId": ${quest.id},
    "updates": {
        "description_sugg": "Suggested updated description incorporating new information from today's reflection",
        "analysis_sugg": "Suggested new analysis incorporating today's insights"
    },
    "confidence": 0.0 to 1.0
}`
                    }
                ],
                temperature: 0.7,
                max_tokens: 8000
            });

            const aiResponse = this.cleanResponseText(result.choices[0].message?.content ?? '');

            try {
                const parsed = JSON.parse(aiResponse) as ContentAnalysis;
                console.log('üìä Confidence level:', parsed.confidence);
                
                // Track changes made to report back
                const changes = {
                    updatedDescriptionSugg: false,
                    updatedAnalysisSugg: false,
                    errors: [] as string[]
                };

                // Only save suggestions if confidence is high
                if (parsed.confidence >= 0.8) {
                    console.log('üîÑ Saving high-confidence update suggestions to database');
                    
                    // Update quest fields if provided
                    if (parsed.updates.description_sugg || parsed.updates.analysis_sugg) {
                        try {
                            const updateData: {description_sugg?: string, analysis_sugg?: string} = {};
                            
                            if (parsed.updates.description_sugg) {
                                updateData.description_sugg = parsed.updates.description_sugg;
                                changes.updatedDescriptionSugg = true;
                                console.log('üìù Saved suggested quest description');
                            }
                            
                            if (parsed.updates.analysis_sugg) {
                                updateData.analysis_sugg = parsed.updates.analysis_sugg;
                                changes.updatedAnalysisSugg = true;
                                console.log('üìä Saved suggested quest analysis');
                            }
                            
                            if (Object.keys(updateData).length > 0) {
                                const updatedQuest = await this.updateQuest(questId, userId, updateData);
                                console.log('‚úÖ Quest suggestions saved successfully in database:', updatedQuest.id);
                            }
                        } catch (updateError) {
                            console.error('‚ùå Error saving quest suggestions to database:', updateError);
                            changes.errors.push(`Failed to save suggestions: ${updateError instanceof Error ? updateError.message : 'Unknown error'}`);
                        }
                    }

                    // Log summary of changes
                    console.log('üìã Summary of changes:');
                    console.log(`- Description suggestion saved: ${changes.updatedDescriptionSugg}`);
                    console.log(`- Analysis suggestion saved: ${changes.updatedAnalysisSugg}`);
                    if (changes.errors.length > 0) {
                        console.log(`- Errors: ${changes.errors.length}`);
                        changes.errors.forEach(err => console.log(`  - ${err}`));
                    }
                } else {
                    console.log(`‚ö†Ô∏è Confidence level too low (${parsed.confidence}), no suggestions saved`);
                }

                return {
                    ...parsed,
                    meta: {
                        actualChanges: changes
                    }
                } as ContentAnalysis & { meta: { actualChanges: typeof changes } };
            } catch (parseError) {
                console.error('Error parsing AI response:', parseError);
                return null;
            }
        } catch (error) {
            console.error('Error in analyzeContentForQuest:', error);
            return null;
        }
    }

}

================
File: services/tasksService.ts
================
import { useState, useEffect } from 'react';
import { supabase } from '@/lib/supabase';
import type { Task } from '@/app/types';
import { useSupabase } from '@/contexts/SupabaseContext';

// Define types for status
export type TaskStatus = 'ToDo' | 'InProgress' | 'Done';

// Database operations
export async function fetchTasks(userId: string): Promise<Task[]> {
  console.log('Fetching tasks...');
  const { data, error } = await supabase
    .from('tasks')
    .select(`
      *,
      quest:quests!quest_id (
        id,
        title,
        tagline,
        is_main,
        status,
        start_date,
        end_date
      )
    `)
    .eq('user_id', userId)
    .order('scheduled_for', { ascending: true });

  if (error) {
    console.error('Error fetching tasks:', error);
    throw error;
  }

  console.log('Fetched tasks:', data);
  return data as Task[];
}

export async function fetchTasksByQuest(questId: number, userId: string): Promise<Task[]> {
  const { data, error } = await supabase
    .from('tasks')
    .select('*')
    .eq('quest_id', questId)
    .eq('user_id', userId)
    .order('scheduled_for', { ascending: true });

  if (error) throw error;
  return data || [];
}

export async function getTasksByDate(date: string, userId: string): Promise<Task[]> {
  console.log('Fetching tasks for date:', date);
  const startOfDay = `${date}T00:00:00`;
  const endOfDay = `${date}T23:59:59`;

  const { data, error } = await supabase
    .from('tasks')
    .select(`
      *,
      quest:quests!quest_id (
        id,
        title,
        tagline,
        is_main,
        status,
        start_date,
        end_date
      )
    `)
    .eq('user_id', userId)
    .gte('scheduled_for', startOfDay)
    .lte('scheduled_for', endOfDay)
    .order('scheduled_for', { ascending: true });

  if (error) {
    console.error('Error fetching tasks by date:', error);
    throw error;
  }

  return data || [];
}

/**
 * Update a task with specified fields
 * @param taskId ID of the task to update
 * @param updateData Object containing fields to update
 * @param userId User ID for ownership verification
 * @returns The updated task
 */
export async function updateTask(taskId: number, updateData: Record<string, any>, userId: string): Promise<Task> {
  console.log('[tasksService] Updating task:', { taskId, fields: Object.keys(updateData) });
  
  // First verify ownership
  const { data: task, error: fetchError } = await supabase
    .from('tasks')
    .select('user_id')
    .eq('id', taskId)
    .single();

  if (fetchError) {
    console.error('[tasksService] Error verifying task ownership:', fetchError);
    throw new Error(`Failed to verify task ownership: ${fetchError.message}`);
  }

  if (!task || task.user_id !== userId) {
    console.error('[tasksService] Cannot update task: User does not own this task');
    throw new Error('You do not have permission to update this task');
  }
  
  // Add updated_at timestamp if not provided
  if (!updateData.updated_at) {
    updateData.updated_at = new Date().toISOString();
  }
  
  // Perform the update
  const { data, error } = await supabase
    .from('tasks')
    .update(updateData)
    .eq('id', taskId)
    .eq('user_id', userId)
    .select()
    .single();
  
  if (error) {
    console.error('[tasksService] Error updating task:', error);
    throw new Error(`Failed to update task: ${error.message}`);
  }
  
  if (!data) {
    throw new Error('Failed to retrieve updated task data');
  }
  
  return data as Task;
}

// New function to update task status in Supabase
export async function updateTaskStatus(taskId: number, newStatus: TaskStatus, userId: string): Promise<void> {
  // First verify ownership
  const { data: task, error: fetchError } = await supabase
    .from('tasks')
    .select('user_id')
    .eq('id', taskId)
    .single();

  if (fetchError) {
    console.error('Error verifying task ownership:', fetchError);
    throw new Error(`Failed to verify task ownership: ${fetchError.message}`);
  }

  if (!task || task.user_id !== userId) {
    console.error('Cannot update task: User does not own this task');
    throw new Error('You do not have permission to update this task');
  }
  
  const { error } = await supabase
    .from('tasks')
    .update({ status: newStatus, updated_at: new Date().toISOString() })
    .eq('id', taskId)
    .eq('user_id', userId);
  
  if (error) {
    console.error('Error updating task status:', error);
    throw new Error(`Failed to update task status: ${error.message}`);
  }
  
  return Promise.resolve();
}

// New function to create a task in Supabase
export async function createTask(taskData: {
  title: string;
  description?: string;
  status: TaskStatus;
  quest_id: number;
  scheduled_for: string;
  deadline?: string;
  location?: string;
  priority: 'high' | 'medium' | 'low';
  subtasks?: string;
  tags?: string[];
  user_id: string;
}): Promise<Task> {
  console.log('Creating new task:', taskData);
  
  const newTask = {
    ...taskData,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString()
  };
  
  const { data, error } = await supabase
    .from('tasks')
    .insert(newTask)
    .select()
    .single();
  
  if (error) {
    console.error('Error creating task:', error);
    throw new Error(`Failed to create task: ${error.message}`);
  }
  
  if (!data) {
    throw new Error('Failed to retrieve created task');
  }
  
  return data as Task;
}

// Helper function to get the next status in the cycle
export function getNextStatus(currentStatus: string): TaskStatus {
  switch (currentStatus) {
    case 'ToDo':
      return 'InProgress';
    case 'InProgress':
      return 'Done';
    case 'Done':
    default:
      return 'ToDo';
  }
}

// New function to fetch quest tasks in Supabase
export async function fetchQuestTasks(questId: number, userId: string) {
  // First verify quest ownership
  const { data: quest, error: questError } = await supabase
    .from('quests')
    .select('user_id')
    .eq('id', questId)
    .single();

  if (questError) {
    console.error('Error verifying quest ownership:', questError);
    throw new Error(`Failed to verify quest ownership: ${questError.message}`);
  }

  if (!quest || quest.user_id !== userId) {
    console.error('Cannot fetch tasks: User does not own this quest');
    throw new Error('You do not have permission to view these tasks');
  }

  const { data: tasks, error } = await supabase
    .from('tasks')
    .select('*')
    .eq('quest_id', questId)
    .eq('user_id', userId)
    .order('scheduled_for', { ascending: true });

  if (error) throw error;
  return tasks || [];
}

// Delete task function
export async function deleteTask(taskId: number, userId: string): Promise<void> {
  console.log('[tasksService] Starting task deletion process', { taskId, userId });
  
  // First verify ownership
  console.log('[tasksService] Verifying task ownership');
  const { data: task, error: fetchError } = await supabase
    .from('tasks')
    .select('user_id')
    .eq('id', taskId)
    .single();

  if (fetchError) {
    console.error('[tasksService] Error verifying task ownership:', fetchError);
    throw new Error(`Failed to verify task ownership: ${fetchError.message}`);
  }

  if (!task) {
    console.error('[tasksService] No task found with ID:', taskId);
    throw new Error('Task not found');
  }

  if (task.user_id !== userId) {
    console.error('[tasksService] Task ownership verification failed', { 
      taskUserId: task.user_id, 
      requestingUserId: userId 
    });
    throw new Error('You do not have permission to delete this task');
  }

  console.log('[tasksService] Task ownership verified, proceeding with deletion');
  
  const { error } = await supabase
    .from('tasks')
    .delete()
    .eq('id', taskId)
    .eq('user_id', userId);
  
  if (error) {
    console.error('[tasksService] Error during task deletion:', error);
    throw new Error(`Failed to delete task: ${error.message}`);
  }
  
  console.log('[tasksService] Task deleted successfully');
  return Promise.resolve();
}

// React Hook
export function useTasks(providedUserId?: string) {
  const [tasks, setTasks] = useState<Task[]>([]);
  const [taskListVisible, setTaskListVisible] = useState(true);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const { session } = useSupabase();

  // Use provided userId if available, otherwise fall back to session user
  const userId = providedUserId || session?.user?.id;

  // Load tasks
  const loadTasks = async () => {
    if (!userId) {
      console.warn("useTasks: No userId provided, skipping task load");
      return;
    }
    
    try {
      setLoading(true);
      const data = await fetchTasks(userId);
      setTasks(data);
    } catch (err) {
      console.error('Error loading tasks:', err);
      setError(err instanceof Error ? err.message : 'Failed to load tasks');
    } finally {
      setLoading(false);
    }
  };

  // Initial load and subscription setup
  useEffect(() => {
    if (!userId) return;
    
    loadTasks();

    // Set up real-time subscription for this user's tasks
    const subscription = supabase
      .channel('tasks_changes')
      .on('postgres_changes', 
        { 
          event: '*', 
          schema: 'public', 
          table: 'tasks',
          filter: `user_id=eq.${userId}`
        },
        (payload) => {
          console.log('Task change received:', payload);
          loadTasks(); // Reload all tasks when any change occurs
        }
      )
      .subscribe();

    return () => {
      subscription.unsubscribe();
    };
  }, [userId]);

  return {
    tasks,
    taskListVisible,
    setTaskListVisible,
    loading,
    error,
    reload: loadTasks
  };
}

================
File: components/chat/ChatInterface.tsx
================
import React, { useState, useRef, useEffect } from 'react';
import { 
  View, 
  Text, 
  TextInput, 
  TouchableOpacity, 
  ScrollView, 
  KeyboardAvoidingView, 
  Platform,
  Animated,
  FlatList
} from 'react-native';
import { Card } from 'react-native-paper';
import { MaterialIcons } from '@expo/vector-icons';
import styles, { colors } from '@/app/styles/global';
import { ChatMessage } from '@/app/types';
import { useTheme } from '@/contexts/ThemeContext';
import { useSuggestions } from '@/contexts/SuggestionContext';
import TriangularSpinner from '../loading/TriangularSpinner';
import CompactTaskSuggestion from '../suggestions/CompactTaskSuggestion';
import { TaskSuggestion, QuestSuggestion } from '@/services/agents/SuggestionAgent';
import { CreateTaskModal } from '@/components/modals/CreateTaskModal';
import { fetchQuests } from '@/services/questsService';
import { useSupabase } from '@/contexts/SupabaseContext';
import { personalityService } from '@/services/personalityService';

interface Props {
  recentMessages: ChatMessage[];
  onSendMessage?: (message: string, userId: string) => Promise<void>;
  handleTyping?: (text: string) => void;
  isTyping?: boolean;
  sessionEnded?: boolean;
  checkupCreated?: boolean;
  onEndSession?: () => void;
  onDeleteMessages?: () => void;
  userId: string;
}

export function ChatInterface({ 
  recentMessages,
  onSendMessage, 
  handleTyping,
  isTyping, 
  sessionEnded,
  checkupCreated,
  onEndSession,
  onDeleteMessages,
  userId
}: Props) {
  const [message, setMessage] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [isProcessingSession, setIsProcessingSession] = useState(false);
  const [isEndingSession, setIsEndingSession] = useState(false);  // Add this line
  const scrollViewRef = useRef<ScrollView>(null);
  const { themeColor, secondaryColor } = useTheme();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [currentTaskModal, setCurrentTaskModal] = useState<TaskSuggestion | null>(null);
  const [showTaskModal, setShowTaskModal] = useState(false);
  const [quests, setQuests] = useState<Array<{ id: number; title: string }>>([]);
  const { session } = useSupabase();
  const [personalityName, setPersonalityName] = useState('SILVERHAND');

  // Get task and quest suggestions from context
  const { 
    taskSuggestions, 
    questSuggestions,
    acceptTaskSuggestion, 
    rejectTaskSuggestion, 
    upgradeTaskToQuest,
    rejectQuestSuggestion,
    acceptQuestSuggestion,
  } = useSuggestions();

  // Load quests for task modal
  useEffect(() => {
    const loadQuests = async () => {
      if (userId) {
        try {
          const loadedQuests = await fetchQuests(userId);
          setQuests(loadedQuests);
        } catch (err) {
          console.error('Error loading quests:', err);
        }
      }
    };
    
    loadQuests();
  }, [userId]);

  // Add logging when suggestions change
  useEffect(() => {
    console.log('üéØ [ChatInterface] Suggestion state updated:', {
      taskCount: taskSuggestions.length,
      questCount: questSuggestions.length,
    });
  }, [taskSuggestions, questSuggestions]);
  
  // Handle task suggestion actions with logging
  const handleAcceptTask = (task: TaskSuggestion) => {
    console.log('‚úÖ [ChatInterface] Accepting task:', task.title);
    if (userId) {
      setIsSubmitting(true);
      acceptTaskSuggestion(task)
        .finally(() => {
          setIsSubmitting(false);
        });
    }
  };
  
  const handleRejectTask = (taskId: string) => {
    console.log('‚ùå [ChatInterface] Rejecting task:', taskId);
    rejectTaskSuggestion(taskId);
  };
  
  const handleUpgradeTask = (task: TaskSuggestion) => {
    console.log('‚¨ÜÔ∏è [ChatInterface] Upgrading task to quest:', task.title);
    upgradeTaskToQuest(task);
  };

  // New method to handle expanding a task suggestion to show details modal
  const handleExpandTask = (task: TaskSuggestion) => {
    console.log('üîç [ChatInterface] Expanding task suggestion:', task.title);
    setCurrentTaskModal(task);
    setShowTaskModal(true);
  };

  // Handle creating a task from the suggestion in the modal
  const handleCreateTaskFromSuggestion = async (formData: any) => {
    try {
      setIsSubmitting(true);
      console.log('üìù [ChatInterface] Creating task from suggestion with form data:', formData);
      
      if (currentTaskModal) {
        // Pass the form data rather than the original suggestion
        await acceptTaskSuggestion({
          ...currentTaskModal,
          ...formData
        });
        setCurrentTaskModal(null);
        setShowTaskModal(false);
      }
    } catch (error) {
      console.error('Error creating task from suggestion:', error);
    } finally {
      setIsSubmitting(false);
    }
  };

  // Handle quest suggestion actions with logging
  const handleAcceptQuest = (quest: QuestSuggestion) => {
    console.log('‚úÖ [ChatInterface] Accepting quest:', quest.title);
    if (userId) {
      acceptQuestSuggestion(quest);
    }
  };
  
  const handleRejectQuest = (questId: string) => {
    console.log('‚ùå [ChatInterface] Rejecting quest:', questId);
    rejectQuestSuggestion(questId);
  };

  // Clear message when session ends
  useEffect(() => {
    if (sessionEnded) {
      setMessage('');
    }
  }, [sessionEnded]);
  
  // Scroll to bottom when new messages arrive
  useEffect(() => {
    if (scrollViewRef.current) {
      scrollViewRef.current.scrollToEnd({ animated: true });
    }
  }, [recentMessages]);
  
  // Get bright accent color for better visibility
  const getBrightAccent = (baseColor: string) => {
    const hex = baseColor.replace('#', '');
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    
    if (r + g + b > 500) {
      return baseColor;
    }
    
    const brightR = Math.min(255, r + 100);
    const brightG = Math.min(255, g + 100);
    const brightB = Math.min(255, b + 100);
    
    return `#${brightR.toString(16).padStart(2, '0')}${
      brightG.toString(16).padStart(2, '0')}${
      brightB.toString(16).padStart(2, '0')}`;
  };
  
  const brightAccent = getBrightAccent(themeColor);

  const handleSend = async () => {
    if (message.trim() === '') return;
    
    if (!userId) {
      console.warn("User not logged in. Cannot send message.");
      setError("You must be logged in to send messages");
      return;
    }
    
    const messageToSend = message;
    setMessage('');
    
    if (onSendMessage) {
      try {
        await onSendMessage(messageToSend, userId);
      } catch (err) {
        console.error("Error sending message:", err);
        setError("Failed to send message");
      }
    }
  };

  const handleMessageChange = (text: string) => {
    setMessage(text);
    if (handleTyping) {
      handleTyping(text);
    }
  };

  const handleKeyPress = (e: any) => {
    if (e.nativeEvent.key === 'Enter' && !e.nativeEvent.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  const formatTimestamp = (timestamp: string) => {
    try {
      const date = new Date(timestamp);
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    } catch (e) {
      return '';
    }
  };

  // Debug information for suggestions
  useEffect(() => {
    console.log("Available suggestions:", {
      taskCount: taskSuggestions.length,
      questCount: questSuggestions.length, 
    });
  }, [taskSuggestions, questSuggestions]);
  // Check if we have any suggestions to show
  const hasSuggestions = taskSuggestions.length > 0 || questSuggestions.length > 0 ;

  // Update session processing state when session ends
  useEffect(() => {
    if (sessionEnded && !checkupCreated) {
      setIsProcessingSession(true);
    } else if (checkupCreated) {
      setIsProcessingSession(false);
    }
  }, [sessionEnded, checkupCreated]);

  // Add a wrapper for the onEndSession callback
  const handleEndSession = () => {
    if (!isEndingSession && onEndSession) {
      setIsEndingSession(true);
      onEndSession();
    }
  };

  useEffect(() => {
    if (session?.user?.id) {
      personalityService.getUserPersonality(session.user.id)
        .then(personality => {
          switch(personality) {
            case 'bt7274':
              setPersonalityName('BT');
              break;
            case 'johnny':
              setPersonalityName('SILVERHAND');
              break;
            case 'batman':
              setPersonalityName('BATMAN');
              break;
            
          }
        })
        .catch(error => {
          console.error('Error getting personality:', error);
          setPersonalityName('SILVERHAND'); // Fallback to default
        });
    }
  }, [session?.user?.id]);

  return (
    <>
      <Card style={{
        flex: 1,
        backgroundColor: colors.backgroundSecondary,
        borderRadius: 8,
        borderWidth: 1, 
        borderColor: themeColor, 
        borderLeftWidth: 3,
        overflow: 'hidden',
        shadowColor: '#000',
        shadowOffset: {
          width: 0,
          height: 3,
        },
        shadowOpacity: 0.5,
        shadowRadius: 5,
        elevation: 8,
      }}>
        {/* Background with cyberpunk elements */}
        <View style={{ 
          position: 'absolute', 
          width: '100%', 
          height: '100%',
          backgroundColor: '#151515',
        }} />

        {/* Chat header */}
        <View style={{ 
          flexDirection: 'row',
          alignItems: 'center',
          justifyContent: 'space-between',
          paddingHorizontal: 15,
          paddingVertical: 15,
          borderBottomWidth: 1,
          borderBottomColor: 'rgba(255, 255, 255, 0.1)',
          backgroundColor: 'rgba(20, 20, 20, 0.7)',
        }}>
          {/* ...existing code... */}
          <View style={{ flexDirection: 'row', alignItems: 'center', flex: 1 }}>
            <Text style={{ 
              fontSize: 18,
              fontWeight: 'bold',
              color: '#FFFFFF',
              textTransform: 'uppercase',
              letterSpacing: 1,
              textShadowColor: themeColor,
              textShadowOffset: { width: 1, height: 1 },
              textShadowRadius: 4
            }}>
              Interface
            </Text>
            <View style={{
              height: 3,
              width: 20,
              backgroundColor: themeColor,
              marginLeft: 8,
              borderRadius: 2,
            }} />
            
            <TouchableOpacity 
              style={{
                marginLeft: 15,
                backgroundColor: 'rgba(30, 30, 30, 0.9)',
                borderWidth: 1,
                borderColor: secondaryColor,
                borderRadius: 4,
                paddingVertical: 4,
                paddingHorizontal: 8,
                flexDirection: 'row',
                alignItems: 'center',
                opacity: isEndingSession ? 0.5 : 1,
              }}
              onPress={handleEndSession}
              disabled={!userId || isEndingSession}
            >
              <MaterialIcons 
                name="timer-off" 
                size={16} 
                color={secondaryColor} 
                style={{ marginRight: 4 }} 
              />
              <Text style={{
                color: secondaryColor,
                fontSize: 12,
                fontWeight: 'bold',
                textTransform: 'uppercase',
              }}>
                End Session
              </Text>
            </TouchableOpacity>

            <TouchableOpacity 
              style={{
                marginLeft: 15,
                backgroundColor: 'rgba(30, 30, 30, 0.9)',
                borderWidth: 1,
                borderColor: '#ff4c4c',
                borderRadius: 4,
                paddingVertical: 4,
                paddingHorizontal: 8,
                flexDirection: 'row',
                alignItems: 'center',
              }}
              onPress={onDeleteMessages}
              disabled={!userId}
            >
              <MaterialIcons 
                name="delete" 
                size={16} 
                color="#ff4c4c"
                style={{ marginRight: 4 }} 
              />
              <Text style={{
                color: '#ff4c4c',
                fontSize: 12,
                fontWeight: 'bold',
                textTransform: 'uppercase',
              }}>
                Delete Chat
              </Text>
            </TouchableOpacity>
          </View>
        </View>

        <KeyboardAvoidingView 
          style={{ flex: 1 }}
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'} 
        >
          {/* Main content area - split into chat messages and suggestions */}
          <View style={{ flex: 1, flexDirection: 'column' }}>
            {/* Chat messages area - takes up most of the space */}
            <ScrollView 
              style={{ padding: 10, flex: 1 }} 
              contentContainerStyle={{ paddingBottom: 20 }}
              ref={scrollViewRef}
            >
              {/* Error message */}
              {error && (
                <View style={{
                  padding: 12,
                  marginVertical: 5,
                  borderRadius: 5,
                  backgroundColor: 'rgba(255, 50, 50, 0.2)',
                  borderWidth: 1,
                  borderColor: 'rgba(255, 50, 50, 0.5)',
                  marginBottom: 16,
                }}>
                  <Text style={{
                    color: '#FFA0A0',
                    fontSize: 14,
                    textAlign: 'center',
                  }}>
                    {error}
                  </Text>
                </View>
              )}

              {/* Messages */}
              {recentMessages.map((msg, index) => {
                let messageText = msg.message;
                if (!msg.is_user && messageText) {
                  messageText = messageText.replace(/^["']|["']$/g, '');
                  messageText = messageText.replace(/^Johnny Silverhand's response:\s*/i, '');
                }
                
                return (
                  <View 
                    key={`${msg.id}-${index}`}
                    style={[
                      {
                        padding: 12,
                        marginVertical: 5,
                        borderRadius: 5,
                        maxWidth: '85%',
                        backgroundColor: 'rgba(15, 15, 15, 0.8)',
                        shadowColor: '#000',
                        shadowOffset: { width: 0, height: 3 },
                        shadowOpacity: 0.2,
                        shadowRadius: 4,
                        elevation: 3,
                      },
                      !msg.is_user 
                        ? {
                            alignSelf: 'flex-start',
                            borderLeftWidth: 3,
                            borderColor: secondaryColor,
                            marginRight: '15%',
                          }
                        : {
                            alignSelf: 'flex-end',
                            borderLeftWidth: 3,
                            borderColor: themeColor,
                            marginLeft: '15%',
                          }
                    ]}
                  >
                    <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                      <Text style={{ 
                        color: !msg.is_user ? secondaryColor : themeColor,
                        fontWeight: 'bold',
                        fontSize: 12,
                        textTransform: 'uppercase',
                        letterSpacing: 0.5,
                        textShadowColor: !msg.is_user ? secondaryColor : themeColor,
                        textShadowOffset: { width: 0, height: 0 },
                        textShadowRadius: 3,
                      }}>
                        {!msg.is_user ? personalityName : 'YOU'}
                      </Text>
                      <Text style={{ color: '#777', fontSize: 10 }}>
                        {formatTimestamp(msg.updated_at)}
                      </Text>
                    </View>
                    <Text style={{ 
                      fontSize: 18,
                      color: '#BBB',
                      lineHeight: 22,
                      textShadowColor: !msg.is_user ? secondaryColor : themeColor,
                      textShadowOffset: { width: 0, height: 0 },
                      textShadowRadius: 3,
                    }}>
                      {messageText}
                    </Text>
                  </View>
                );
              })}
              
              {/* Typing indicator */}
              {isTyping && (
                <View 
                  style={[
                    {
                      padding: 12,
                      marginVertical: 5,
                      borderRadius: 5,
                      maxWidth: '85%',
                      backgroundColor: 'rgba(15, 15, 15, 0.8)',
                      shadowColor: '#000',
                      shadowOffset: { width: 0, height: 3 },
                      shadowOpacity: 0.2,
                      shadowRadius: 4,
                      elevation: 3,
                      alignSelf: 'flex-start',
                      borderLeftWidth: 3,
                      borderColor: secondaryColor,
                      marginRight: '15%',
                    },
                  ]}
                >
                  <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                    <Text style={{ 
                      color: secondaryColor,
                      fontWeight: 'bold',
                      fontSize: 12,
                      textTransform: 'uppercase',
                      letterSpacing: 0.5,
                      textShadowColor: secondaryColor,
                      textShadowOffset: { width: 0, height: 0 },
                      textShadowRadius: 3,
                    }}>
                      {personalityName}
                    </Text>
                  </View>
                  <View style={{ flexDirection: 'row', alignItems: 'center', paddingVertical: 4 }}>
                    <TriangularSpinner size={24} color={secondaryColor} />
                    <Text style={{ 
                      fontSize: 18,
                      color: '#BBB',
                      marginLeft: 8,
                      lineHeight: 22,
                      textShadowColor: secondaryColor,
                      textShadowOffset: { width: 0, height: 0 },
                      textShadowRadius: 3,
                    }}>
                      typing
                    </Text>
                  </View>
                </View>
              )}
              
              {/* Session ended notification */}
              {sessionEnded && (
                <View style={{
                  marginTop: 20,
                  padding: 12,
                  borderRadius: 5,
                  backgroundColor: 'rgba(20, 20, 20, 0.8)',
                  borderWidth: 1,
                  borderColor: secondaryColor,
                }}>
                  <Text style={{
                    color: '#BBB',
                    fontSize: 16,
                    textAlign: 'center',
                    marginBottom: 8,
                  }}>
                    Session ended
                  </Text>
                  
                  {isProcessingSession ? (
                    <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'center', marginTop: 8 }}>
                      <TriangularSpinner size={16} color={secondaryColor} />
                      <Text style={{
                        color: '#999',
                        fontSize: 14,
                        textAlign: 'center',
                        marginLeft: 8,
                      }}>
                        Processing conversation...
                      </Text>
                    </View>
                  ) : checkupCreated && (
                    <View style={{ marginTop: 8 }}>
                      <Text style={{
                        color: '#BBB',
                        fontSize: 14,
                        textAlign: 'center',
                        marginBottom: 8,
                      }}>
                        A checkup entry has been created in your journal based on this conversation.
                      </Text>
                    </View>
                  )}
                </View>
              )}
            </ScrollView>
            
            {/* Suggestions list area - displayed only when there are suggestions */}
            {hasSuggestions && (
              <View style={{
                maxHeight: 220,
                borderTopWidth: 1,
                borderTopColor: 'rgba(255, 255, 255, 0.1)',
                backgroundColor: 'rgba(15, 15, 15, 0.95)',
              }}>
                <View style={{ 
                  flexDirection: 'row',
                  justifyContent: 'space-between',
                  alignItems: 'center',
                  paddingHorizontal: 15,
                  paddingVertical: 8,
                  backgroundColor: 'rgba(20, 20, 20, 0.8)',
                }}>
                  <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                    <MaterialIcons name="lightbulb" size={16} color={secondaryColor} />
                    <Text style={{ 
                      marginLeft: 6,
                      color: secondaryColor,
                      fontWeight: 'bold',
                      fontSize: 14,
                      textTransform: 'uppercase',
                    }}>
                      Suggestions ({taskSuggestions.length + questSuggestions.length})
                    </Text>
                  </View>
                </View>
                
                <ScrollView 
                  horizontal={false}
                  style={{ 
                    maxHeight: 180,
                  }}
                  contentContainerStyle={{
                    padding: 10,
                    paddingBottom: 15,
                  }}
                >
                  {/* Task Suggestions */}
                  {taskSuggestions.length > 0 && (
                    <View style={{ marginBottom: 12 }}>
                      <Text style={{ 
                        color: '#AAA', 
                        fontSize: 12, 
                        marginBottom: 8,
                        paddingHorizontal: 4,
                      }}>
                        TASKS
                      </Text>
                      
                      {taskSuggestions.map((task) => (
                        <View key={task.id} style={{ marginBottom: 8 }}>
                          <CompactTaskSuggestion
                            suggestion={task}
                            onAccept={() => handleAcceptTask(task)}
                            onReject={() => handleRejectTask(task.id)}
                            onExpand={() => handleExpandTask(task)}
                            onUpgradeToQuest={() => handleUpgradeTask(task)}
                          />
                        </View>
                      ))}
                    </View>
                  )}
                  
                  {/* Quest Suggestions */}
                  {questSuggestions.length > 0 && (
                    <View>
                      <Text style={{ 
                        color: '#AAA', 
                        fontSize: 12, 
                        marginBottom: 8,
                        paddingHorizontal: 4,
                      }}>
                        QUESTS
                      </Text>
                      
                      {questSuggestions.map((quest) => (
                        <View key={quest.id} style={{ marginBottom: 8 }}>
                          <View style={{
                            backgroundColor: 'rgba(20, 20, 20, 0.95)',
                            borderRadius: 6,
                            borderLeftWidth: 3,
                            borderColor: secondaryColor,
                            shadowColor: '#000',
                            shadowOffset: { width: 0, height: 3 },
                            shadowOpacity: 0.3,
                            shadowRadius: 4,
                            elevation: 6,
                            overflow: 'hidden',
                          }}>
                            <View style={{
                              flexDirection: 'row',
                              alignItems: 'center',
                              padding: 10,
                              paddingHorizontal: 12,
                              borderBottomWidth: 1,
                              borderBottomColor: 'rgba(255, 255, 255, 0.1)',
                            }}>
                              <MaterialIcons name="emoji-events" size={16} color={secondaryColor} />
                              <Text style={{
                                fontSize: 12,
                                fontWeight: 'bold',
                                marginLeft: 6,
                                flex: 1,
                                color: secondaryColor,
                              }}>
                                {quest.title}
                              </Text>
                              <TouchableOpacity style={{ padding: 2 }} onPress={() => handleRejectQuest(quest.id)}>
                                <MaterialIcons name="close" size={16} color="#999" />
                              </TouchableOpacity>
                            </View>
                            
                            <View style={{ padding: 12 }}>
                              <Text style={{
                                color: '#AAA',
                                fontSize: 12,
                                marginBottom: 8
                              }}>
                                {quest.tagline}
                              </Text>
                            </View>
                            
                            <View style={{
                              flexDirection: 'row',
                              borderTopWidth: 1,
                              borderTopColor: 'rgba(255, 255, 255, 0.1)',
                            }}>
                              <TouchableOpacity
                                style={{
                                  flexDirection: 'row',
                                  alignItems: 'center',
                                  justifyContent: 'center',
                                  padding: 8,
                                  backgroundColor: secondaryColor,
                                  flex: 1
                                }}
                                onPress={() => handleAcceptQuest(quest)}
                              >
                                <MaterialIcons name="check" size={14} color="#fff" />
                                <Text style={{
                                  color: '#FFF',
                                  fontSize: 12,
                                  marginLeft: 4
                                }}>
                                  Accept
                                </Text>
                              </TouchableOpacity>
                            </View>
                          </View>
                        </View>
                      ))}
                    </View>
                  )}
                </ScrollView>
              </View>
            )}
            {/* Chat input */}
            <View style={{
              flexDirection: 'row',
              padding: 10,
              borderTopWidth: 1,
              borderTopColor: 'rgba(255, 255, 255, 0.1)',
              backgroundColor: 'rgba(20, 20, 20, 0.9)'
            }}>
                            <TextInput
                style={{
                  flex: 1,
                  padding: 12,
                  backgroundColor: 'rgba(25, 25, 25, 0.7)',
                  color: colors.text,
                  borderRadius: 4,
                  fontSize: 15,
                  marginRight: 10,
                  borderLeftWidth: 2, 
                  borderLeftColor: themeColor,
                  textAlignVertical: 'center',
                  maxHeight: 100,
                }}
                value={message}
                onChangeText={handleMessageChange}
                onKeyPress={handleKeyPress}
                placeholder={!userId ? "Please log in to chat" : "Type your message..."}
                placeholderTextColor="#666"
                blurOnSubmit={false}
                multiline={false}
                editable={!sessionEnded && !!userId}
              />
              <TouchableOpacity 
                style={{
                  justifyContent: 'center',
                  alignItems: 'center',
                  backgroundColor: themeColor,
                  borderRadius: 4,
                  paddingHorizontal: 15,
                  borderWidth: 1,
                  borderColor: brightAccent,
                  shadowColor: themeColor,
                  shadowOffset: { width: 0, height: 0 },
                  shadowOpacity: 0.5,
                  shadowRadius: 5,
                  elevation: 5,
                  opacity: sessionEnded || !userId ? 0.5 : 1,
                }} 
                onPress={handleSend}
                disabled={sessionEnded || !userId}
              >
                <MaterialIcons name="send" size={24} color="#FFF" />
              </TouchableOpacity>
            </View>
          </View>
        </KeyboardAvoidingView>
      </Card>

      {/* Task Suggestion Modal */}
      <CreateTaskModal
        visible={showTaskModal}
        onClose={() => {
          setShowTaskModal(false);
          setCurrentTaskModal(null);
        }}
        onSubmit={handleCreateTaskFromSuggestion}
        isSubmitting={isSubmitting}
        quests={quests}
        userId={userId}
        initialData={currentTaskModal ? {
          title: currentTaskModal.title,
          description: currentTaskModal.description,
          scheduled_for: currentTaskModal.scheduled_for,
          deadline: currentTaskModal.deadline,
          location: currentTaskModal.location,
          status: 'ToDo',
          priority: currentTaskModal.priority || 'medium',
          subtasks: currentTaskModal.subtasks,
          user_id: userId
        } : undefined}
      />
    </>
  );
}

================
File: services/questsService.ts
================
import { useState, useEffect } from 'react';
import { supabase } from '@/lib/supabase';
import type { Quest } from '@/app/types';
import { RealtimePostgresChangesPayload } from '@supabase/supabase-js';
import { useSupabase } from '@/contexts/SupabaseContext';

interface QuestUpdate {
  id: number;
  title: string;
  tagline: string;
  description?: string;
  description_sugg?: string;
  is_main: boolean;
  status: 'Active' | 'On-Hold' | 'Completed';
  analysis?: string;
  analysis_sugg?: string;
  parent_quest_id?: number;
  start_date?: string;
  end_date?: string;
  tags?: string[];
  user_id: string;
}

interface QuestInput extends Omit<Quest, 'id' | 'created_at' | 'updated_at' | 'tasks'> {
  description?: string;
  user_id: string;
}

// Update type definition for update operations to allow partial data
type QuestUpdateInput = Partial<Omit<QuestInput, 'user_id'>> & {
  description_sugg?: string;
  analysis_sugg?: string;
};

type QuestRealtimePayload = RealtimePostgresChangesPayload<QuestUpdate>;


// Database operations
export async function fetchQuests(userId: string): Promise<Quest[]> {
  if (!userId) {
    console.error('fetchQuests called without userId');
    return [];
  }

  console.log(`[questsService] Fetching quests for user: ${userId}`);
  
  try {
    // Verify supabase client is initialized
    if (!supabase) {
      console.error('[questsService] Supabase client not initialized');
      return [];
    }

    const { data, error } = await supabase
      .from('quests')
      .select(`
        id,
        created_at,
        updated_at,
        tags,
        title,
        tagline,
        description,
        description_sugg,
        is_main,
        status,
        start_date,
        end_date,
        analysis,
        analysis_sugg,
        parent_quest_id,
        user_id,
        tasks (*)
      `)
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    if (error) {
      console.error('[questsService] Error fetching quests:', error);
      throw error;
    }

    console.log(`[questsService] Successfully fetched ${data?.length || 0} quests`);
    return data || [];
  } catch (error) {
    console.error('[questsService] Unexpected error in fetchQuests:', error);
    
    // In production, return empty array instead of throwing to prevent UI crashes
    if (process.env.NODE_ENV === 'production') {
      return [];
    }
    throw error;
  }
}

// Renamed function to be more descriptive of what it returns
async function getQuestsWithTasks(userId: string): Promise<Quest[]> {
  return fetchQuests(userId);
}

// Remove the export keyword here since we'll export at the bottom
async function createQuest(userId: string, questData: Omit<QuestInput, 'user_id'>): Promise<Quest> {
  const fullQuestData: QuestInput = {
    ...questData,
    user_id: userId
  };

  const cleanedFields = Object.fromEntries(
    Object.entries(fullQuestData).map(([key, value]) => {
      if ((key === 'start_date' || key === 'end_date') && value === '') {
        return [key, null];
      }
      return [key, value];
    })
  );

  const { data: quest, error: questError } = await supabase
    .from('quests')
    .insert({
      ...cleanedFields,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    })
    .select()
    .single();

  if (questError) throw questError;
  return quest;
}

// Remove the export keyword here since we'll export at the bottom
// Update to accept partial data for updates
async function updateQuest(questId: number, userId: string, questData: QuestUpdateInput): Promise<Quest> {
  // First verify ownership
  const { data: quest, error: fetchError } = await supabase
    .from('quests')
    .select('user_id')
    .eq('id', questId)
    .single();

  if (fetchError) {
    console.error('Error verifying quest ownership:', fetchError);
    throw new Error(`Failed to verify quest ownership: ${fetchError.message}`);
  }

  if (!quest || quest.user_id !== userId) {
    console.error('Cannot update quest: User does not own this quest');
    throw new Error('You do not have permission to update this quest');
  }

  const fullQuestData = {
    ...questData,
    user_id: userId
  };

  const cleanedFields = Object.fromEntries(
    Object.entries(fullQuestData).map(([key, value]) => {
      if ((key === 'start_date' || key === 'end_date') && value === '') {
        return [key, null];
      }
      return [key, value];
    })
  );

  const { data, error: updateError } = await supabase
    .from('quests')
    .update({
      ...cleanedFields,
      updated_at: new Date().toISOString()
    })
    .eq('id', questId)
    .eq('user_id', userId)
    .select('*')
    .single();

  if (updateError) throw updateError;
  return data;
}

// New function to delete a quest
async function deleteQuest(questId: number, userId: string): Promise<void> {
  // First verify ownership
  const { data: quest, error: fetchError } = await supabase
    .from('quests')
    .select('user_id')
    .eq('id', questId)
    .single();

  if (fetchError) {
    console.error('Error verifying quest ownership:', fetchError);
    throw new Error(`Failed to verify quest ownership: ${fetchError.message}`);
  }

  if (!quest || quest.user_id !== userId) {
    console.error('Cannot delete quest: User does not own this quest');
    throw new Error('You do not have permission to delete this quest');
  }

  // Delete the quest
  const { error } = await supabase
    .from('quests')
    .delete()
    .eq('id', questId)
    .eq('user_id', userId);

  if (error) throw error;
}

// Add functions to handle misc quests
async function getMiscQuest(userId: string): Promise<Quest | null> {
  const { data, error } = await supabase
    .from('quests')
    .select(`
      id,
      created_at,
      updated_at,
      tags,
      title,
      tagline,
      description,
      description_sugg,
      is_main,
      status,
      start_date,
      end_date,
      analysis,
      analysis_sugg,
      parent_quest_id,
      user_id,
      tasks (*)
    `)
    .eq('user_id', userId)
    .eq('title', 'Misc')
    .single();

  if (error) {
    if (error.code === 'PGSQL_ERROR_NO_DATA_FOUND') {
      return null;
    }
    throw error;
  }

  return data;
}

async function createMiscQuest(userId: string): Promise<Quest> {
  const miscQuest = await createQuest(userId, {
    title: 'Misc',
    tagline: 'Miscellaneous tasks',
    description: 'A collection of tasks that don\'t belong to any specific quest',
    status: 'Active',
    is_main: false
  });

  return miscQuest;
}

async function getOrCreateMiscQuest(userId: string): Promise<Quest> {
  let miscQuest = await getMiscQuest(userId);
  
  if (!miscQuest) {
    miscQuest = await createMiscQuest(userId);
  }

  return miscQuest;
}

// Update the moveTasksToQuest function to handle moving to misc quest
async function moveTasksToQuest(fromQuestId: number, toQuestId: number | null, userId: string, taskIds?: number[]): Promise<void> {
  // If toQuestId is null, we need to move to the misc quest
  const actualToQuestId = toQuestId ?? (await getOrCreateMiscQuest(userId)).id;

  let query = supabase
    .from('tasks')
    .update({ quest_id: actualToQuestId })
    .eq('quest_id', fromQuestId)
    .eq('user_id', userId);

  // If specific taskIds are provided, only move those tasks
  if (taskIds && taskIds.length > 0) {
    query = query.in('id', taskIds);
  }

  const { error } = await query;
  if (error) throw error;
}

async function updateMainQuest(questId: number, userId: string): Promise<void> {
  // First verify ownership
  const { data: quest, error: fetchError } = await supabase
    .from('quests')
    .select('user_id')
    .eq('id', questId)
    .single();

  if (fetchError) {
    console.error('Error verifying quest ownership:', fetchError);
    throw new Error(`Failed to verify quest ownership: ${fetchError.message}`);
  }

  if (!quest || quest.user_id !== userId) {
    console.error('Cannot update main quest: User does not own this quest');
    throw new Error('You do not have permission to update this quest');
  }

  const { error } = await supabase.rpc('update_main_quest', { 
    p_quest_id: questId,
    p_user_id: userId
  });
  
  if (error) {
    console.error('Error updating main quest via RPC:', error);
    throw error;
  }
}


// Export all database operation functions together
export { 
  createQuest, 
  updateQuest, 
  deleteQuest, 
  moveTasksToQuest, 
  updateMainQuest, 
  getQuestsWithTasks,
  getOrCreateMiscQuest,
};

// React Hook
export function useQuests() {
  const [quests, setQuests] = useState<Quest[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const { session } = useSupabase();

  const loadQuests = async () => {
    if (!session?.user?.id) return;
    try {
      setLoading(true);
      const allQuests = await fetchQuests(session.user.id);
      setQuests(allQuests);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load quests');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (!session?.user?.id) return;
    
    loadQuests();

    const subscription = supabase
      .channel('quests_changes')
      .on('postgres_changes', 
        { 
          event: '*', 
          schema: 'public', 
          table: 'quests',
          filter: `user_id=eq.${session.user.id}`
        },
        (payload: QuestRealtimePayload) => {
          console.log('Quest change received:', payload);
          loadQuests();
        }
      )
      .subscribe();

    return () => {
      subscription.unsubscribe();
    };
  }, [session?.user?.id]);

  return {
    mainQuest: quests.find(q => q.is_main) || null,
    quests,
    setQuestAsMain: async (questId: number) => {
      if (!session?.user?.id) return;
      try {
        setQuests(currentQuests => 
          currentQuests.map(quest => ({
            ...quest,
            is_main: quest.id === questId
          }))
        );
        
        await updateMainQuest(questId, session.user.id);
      } catch (err) {
        console.error('Failed to set main quest:', err);
        setError(err instanceof Error ? err.message : 'Failed to update main quest');
        await loadQuests();
      }
    },
    loading,
    error,
    reload: loadQuests
  };
}

================
File: services/agents/SuggestionAgent.ts
================
// filepath: c:\Users\ThinkPad\Code\QuestLogMockupsWL\QuestLog\services\agents\SuggestionAgent.ts
import OpenAI from 'openai';
import { GoogleGenerativeAI, type GenerativeModel, SchemaType } from "@google/generative-ai";
import { performanceLogger } from '@/utils/performanceLogger';
import { Quest, Task } from '@/app/types';
import { createTask, fetchTasks, updateTask, fetchTasksByQuest } from '@/services/tasksService'; // Import fetchTasksByQuest
import { createQuest, fetchQuests, getOrCreateMiscQuest } from '@/services/questsService';
import { personalityService } from '@/services/personalityService';
import { getPersonality } from '@/services/agents/PersonalityPrompts';

/**
 * Represents a task suggestion generated from user content
 */
export interface TaskSuggestion {
  id: string;
  sourceContent: string;
  sourceType: 'chat' | 'journal';
  timestamp: string;
  type: 'task';
  title: string;
  description: string;
  scheduled_for: string;
  deadline?: string;
  location?: string;
  status: 'ToDo';
  tags?: string[];
  quest_id?: number;
  priority: 'high' | 'medium' | 'low';
  subtasks?: string;
  // Add a flag to indicate if this is an edit suggestion for an existing task
  isEditSuggestion?: boolean;
  existingTaskId?: number;
  // Remove editFields property and rely solely on updateValues
  updateValues?: {
    title?: string;
    status?: 'ToDo' | 'InProgress' | 'Done';
    description?: string;
    deadline?: string;
    scheduled_for?: string;
    location?: string;
    priority?: 'high' | 'medium' | 'low';
  };
  previousTaskId?: number; // Reference to the previous task for continuation
  continuesFromTask?: Task; // Reference to the task this suggestion continues from
}

/**
 * Represents a quest suggestion generated from user content
 */
export interface QuestSuggestion {
  id: string;
  sourceContent: string;
  sourceType: 'chat' | 'journal';
  timestamp: string;
  type: 'quest';
  title: string;
  quest_id?: number;
  tagline: string;
  description: string;
  status: 'Active';
  start_date?: string;
  end_date?: string;
  is_main: boolean;
  relatedTasks?: TaskSuggestion[];
}


export interface ConversationMessage {
  role: "user" | "assistant";
  content: string;
  timestamp: string;
}

export interface ConversationData {
  messages: ConversationMessage[];
  metadata: {
    startTime: string;
    endTime: string;
    totalMessages: number;
  };
}


interface TaskContext {
  sourceMessage: string;
  relatedMessages: string[];
  confidence: number;
  dependencies?: string[];
  timing?: string;
}

// Interface to represent task similarity comparison results
interface TaskSimilarityResult {
  isMatch: boolean;
  existingTask: Task | null;
  matchConfidence: number; // 0 to 1
  isContinuation?: boolean; // New field to indicate if this is a continuation
  continuationReason?: string; // Explanation of why this is considered a continuation
}

// Interface for task update field generation
interface TaskUpdateFields {
  shouldUpdate: boolean;
  updateFields: string[];
  updateValues: {
    title?: string;
    status?: 'ToDo' | 'InProgress' | 'Done';
    description?: string;
    deadline?: string;
    scheduled_for?: string;
    location?: string;
    priority?: 'high' | 'medium' | 'low';
  };
}

type Suggestion = TaskSuggestion | QuestSuggestion;

/**
 * SuggestionAgent handles AI/LLM operations for generating task and quest suggestions.
 * State management is handled by SuggestionContext.
 */
export class SuggestionAgent {
  private genAI: GoogleGenerativeAI;
  private model: GenerativeModel;
  private openai: OpenAI;
  // Add a static instance to implement proper singleton pattern
  private static instance: SuggestionAgent;

  constructor() {
    // Initialize both APIs
    this.genAI = new GoogleGenerativeAI(process.env.EXPO_PUBLIC_GEMINI_API_KEY || '');
    this.model = this.genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
    
    this.openai = new OpenAI({
      apiKey: process.env.EXPO_PUBLIC_DEEPSEEK_API_KEY,
      baseURL: 'https://api.deepseek.com',
      dangerouslyAllowBrowser: true
    });

    console.log("üîß [SuggestionAgent] Created new agent instance");
  }

  // Static method to get the singleton instance
  public static getInstance(): SuggestionAgent {
    if (!SuggestionAgent.instance) {
      SuggestionAgent.instance = new SuggestionAgent();
      console.log("üîß Created new SuggestionAgent singleton instance");
    }
    return SuggestionAgent.instance;
  }


  /**
   * Generates a task suggestion from content
   * @param content The source content
   * @param userId The user's ID
   * @returns A task suggestion or null
   */
  public async generateTaskSuggestion(
    content: string,
    userId: string,
    context?: TaskContext
  ): Promise<TaskSuggestion[]> {
    performanceLogger.startOperation('generateTaskSuggestion');
    try {
      const currentDate = new Date().toISOString().split('T')[0];
      
      // Get current personality for task generation
      const personalityType = await personalityService.getUserPersonality(userId);
      const personality = getPersonality(personalityType);

      const prompt = `You are ${personality.name}. ${personality.description}
Current date is: ${currentDate}

Analyze this content and generate ONE OR MORE separate tasks. If multiple distinct tasks are mentioned, create a separate task for each one.

Content: "${content}"

${context ? `Context:
- Source Message: ${context.sourceMessage}
- Related Messages: ${context.relatedMessages.join('\n')}
- Confidence: ${context.confidence}` : ''}

Generate a JSON object with this EXACT format:
{
  "tasks": [
    {
      "title": "Brief task title for first task",
      "description": "Detailed description incorporating context",
      "scheduled_for": "YYYY-MM-DD format date when task should start (must be ${currentDate} or later)",
      "deadline": "YYYY-MM-DD format deadline if mentioned (must be ${currentDate} or later), otherwise null",
      "location": "Location if mentioned, otherwise null",
      "priority": "high, medium, or low based on urgency/importance",
      "tags": ["relevant", "keyword", "tags"],
      "subtasks": "Comma-separated list of subtasks if appropriate, otherwise empty string"
    }
  ]
}

IMPORTANT:
- Write descriptions in your characteristic voice and style
- Create SEPARATE tasks for distinct activities
- Each task should be focused and specific
- Do not combine unrelated tasks into one
- All dates must be ${currentDate} or later
- Never use dates from the past`;

      console.log(`üöÄ Generating task suggestion(s). Content: ${JSON.stringify(content)} Context: ${JSON.stringify(context)}\n Prompt: ${prompt}`);

      const response = await this.openai.chat.completions.create({
        model: "deepseek-chat",
        messages: [
          { role: "system", content: prompt },
          { role: "user", content: content }
        ],
        temperature: 0.4,
        max_tokens: 3000,
        response_format: { type: "json_object" }
      });

      const responseText = response.choices[0].message?.content;
      if (!responseText) {
        throw new Error('Empty response from AI');
      }

      try {
        const parsed = JSON.parse(responseText);
        const timestamp = new Date().toISOString();
        const sourceType = content.length > 200 ? 'journal' : 'chat';

        // Return empty array if no tasks
        if (!parsed.tasks || parsed.tasks.length === 0) {
          console.log('No tasks generated from content');
          return [];
        }

        // Process all tasks
        const suggestions = parsed.tasks.map((taskData: {
          title: string;
          description: string;
          scheduled_for: string;
          deadline: string | null;
          location: string | null;
          priority: 'high' | 'medium' | 'low';
          tags: string[];
          subtasks: string;
        }) => ({
          id: `task-${timestamp}-${Math.random().toString(36).substring(2, 10)}`,
          sourceContent: content,
          sourceType,
          timestamp,
          type: 'task',
          title: taskData.title,
          description: taskData.description,
          scheduled_for: taskData.scheduled_for,
          deadline: taskData.deadline === 'null' ? undefined : taskData.deadline,
          location: taskData.location === 'null' ? undefined : taskData.location,
          status: 'ToDo',
          tags: taskData.tags || [],
          priority: taskData.priority || 'medium',
          subtasks: taskData.subtasks || undefined
        } as TaskSuggestion));

        console.log('‚úÖ Generated task suggestions:', suggestions.map((s: TaskSuggestion) => s.title));
        return suggestions;

      } catch (parseError) {
        console.error('Error parsing task suggestion:', parseError);
        return [];
      }
    } catch (error) {
      console.error('Error generating task suggestion:', error);
      return [];
    } finally {
      performanceLogger.endOperation('generateTaskSuggestion');
    }
  }

  /**
   * Upgrades a task suggestion to a quest suggestion using LLM analysis
   * @param task The task suggestion to upgrade
   * @returns A quest suggestion if successful, null otherwise
   */
  async upgradeTaskToQuest(task: TaskSuggestion, userId: string): Promise<QuestSuggestion | null> {
    performanceLogger.startOperation('upgradeTaskToQuest');
    try {
      const currentDate = new Date().toISOString().split('T')[0];
      
      // Get current personality for quest generation
      const personalityType = await personalityService.getUserPersonality(userId);
      const personality = getPersonality(personalityType);
      
      console.log('‚¨ÜÔ∏è Upgrading task to quest:', task.title);
      
      const prompt = `You are ${personality.name}. ${personality.description}
Current date is: ${currentDate}

Upgrade this task to a quest (a larger goal that might require multiple tasks). Use your unique personality to frame these objectives.

Task Title: ${task.title}
Task Description: ${task.description}
Scheduled For: ${task.scheduled_for}
${task.deadline ? `Deadline: ${task.deadline}` : ''}
${task.location ? `Location: ${task.location}` : ''}
Priority: ${task.priority}
${task.tags && task.tags.length > 0 ? `Tags: ${task.tags.join(', ')}` : ''}
${task.subtasks ? `Subtasks: ${task.subtasks}` : ''}

Generate a JSON object with these EXACT fields, using your characteristic voice and perspective:
{
  "title": "Quest title - can be based on the original task or expanded",
  "tagline": "Short, one-line description of the quest",
  "description": "Detailed description of the overall goal/objective",
  "start_date": "YYYY-MM-DD - must be ${currentDate} or later",
  "end_date": "YYYY-MM-DD - must be after start_date",
  "relatedTasks": [
    {
      "title": "First related task - include the original task here",
      "description": "Description of first task",
      "scheduled_for": "YYYY-MM-DD"
    }
  ]
}

IMPORTANT:
- Write in your unique voice and perspective
- Make the original task the first related task
- Add 2-3 more related tasks that would help achieve this quest
- Make the quest a meaningful expansion of the original task
- All dates must be ${currentDate} or later
- Never use dates from the past`;

      const response = await this.openai.chat.completions.create({
        model: "deepseek-chat",
        messages: [
          { role: "system", content: prompt }
        ],
        temperature: 0.3,
        max_tokens: 1500,
        response_format: { type: "json_object" }
      });

      const responseText = response.choices[0].message?.content;
      if (!responseText) {
        throw new Error('Empty response from AI');
      }

      try {
        const parsed = JSON.parse(responseText);
        const timestamp = new Date().toISOString();
        
        // Convert related tasks to TaskSuggestions
        const relatedTasks: TaskSuggestion[] = parsed.relatedTasks.map((taskData: any) => ({
          id: `task-${timestamp}-${Math.random().toString(36).substring(2, 10)}`,
          sourceContent: task.sourceContent,
          sourceType: task.sourceType,
          timestamp,
          type: 'task',
          title: taskData.title,
          description: taskData.description,
          scheduled_for: taskData.scheduled_for,
          status: 'ToDo',
          priority: task.priority,
          tags: task.tags
        }));

        const suggestion: QuestSuggestion = {
          id: `quest-${timestamp}-${Math.random().toString(36).substring(2, 10)}`,
          sourceContent: task.sourceContent,
          sourceType: task.sourceType,
          timestamp,
          type: 'quest',
          title: parsed.title,
          tagline: parsed.tagline,
          description: parsed.description,
          status: 'Active',
          start_date: parsed.start_date,
          end_date: parsed.end_date,
          is_main: false,
          relatedTasks
        };

        console.log('‚úÖ Successfully upgraded task to quest:', suggestion.title);
        return suggestion;
      } catch (parseError) {
        console.error('Error parsing upgraded quest:', parseError);
        return null;
      }
    } catch (error) {
      console.error('Error upgrading task to quest:', error);
      return null;
    } finally {
      performanceLogger.endOperation('upgradeTaskToQuest');
    }
  }

  /**
   * Creates a task in the database from a task suggestion
   * @param suggestion The task suggestion to create
   * @param userId The user's ID
   */
  async acceptTaskSuggestion(suggestion: TaskSuggestion, userId: string): Promise<Task | null> {
    try {
      // Check if this is an edit suggestion
      if (suggestion.isEditSuggestion && suggestion.existingTaskId) {
        console.log('üìù Updating existing task from edit suggestion:', suggestion.existingTaskId);
        
        // Get the original task to ensure we have the latest data
        const questId = suggestion.quest_id || (await getOrCreateMiscQuest(userId)).id;
        const questTasks = await fetchTasksByQuest(questId, userId);
        const existingTask = questTasks.find(t => t.id === suggestion.existingTaskId);
        
        if (!existingTask) {
          console.error('Could not find existing task to update');
          return null;
        }
        
        // If updateValues is missing, generate them now
        let updateData: Record<string, any> = {};
        
        if (!suggestion.updateValues) {
          const updateFields = await this.generateTaskUpdateFields(suggestion, existingTask, suggestion.sourceContent, userId);
          if (updateFields.updateValues) {
            updateData = { ...updateFields.updateValues };
          }
        } else {
          updateData = { ...suggestion.updateValues };
        }
        
        // Only perform the update if there are changes to make
        if (Object.keys(updateData).length > 0) {
          updateData.updated_at = new Date().toISOString();
          console.log('Updating task with values:', updateData);
          const updatedTask = await updateTask(suggestion.existingTaskId, updateData, userId);
          return updatedTask;
        } else {
          console.log('No changes needed for the existing task');
          return null;
        }
      }
      
      // If it's not an edit suggestion, proceed with regular task creation
      console.log('üìù Creating task from suggestion:', suggestion.title);
      
      // Get the quest ID, should be determined already during duplicate check
      const finalQuestId = suggestion.quest_id || 
        (await getOrCreateMiscQuest(userId)).id;
      
      const taskData = {
        title: suggestion.title,
        description: suggestion.description,
        scheduled_for: suggestion.scheduled_for,
        deadline: suggestion.deadline,
        location: suggestion.location,
        status: suggestion.status,
        tags: suggestion.tags,
        priority: suggestion.priority,
        subtasks: suggestion.subtasks,
        quest_id: finalQuestId,
        user_id: userId
      };
      
      return await createTask(taskData);
    } catch (error) {
      console.error('Error creating task from suggestion:', error);
      return null;
    }
  }

  /**
   * Find the best quest for a task using LLM analysis
   * @param suggestion The task suggestion
   * @param userId The user's ID
   * @returns Quest ID of the best matching quest, or misc quest if no good match
   */
  public async findBestQuestForTask(suggestion: TaskSuggestion, userId: string): Promise<number> {
    try {
      console.log('üîç Finding best quest for task:', suggestion.title);
      
      // Get all user quests for analysis
      const quests = await fetchQuests(userId);
      if (!quests || quests.length === 0) {
        console.log('No quests found, using misc quest');
        const miscQuest = await getOrCreateMiscQuest(userId);
        return miscQuest.id;
      }
      
      // Create a task and quest information for the model
      const taskInfo = `Title: ${suggestion.title}
Description: ${suggestion.description || 'No description'}
${suggestion.scheduled_for ? `Scheduled for: ${suggestion.scheduled_for}` : ''}
${suggestion.deadline ? `Deadline: ${suggestion.deadline}` : ''}
${suggestion.location ? `Location: ${suggestion.location}` : ''}`;

      const questsInfo = quests.map(quest => `
ID: ${quest.id}
Title: ${quest.title}
Tagline: ${quest.tagline || 'No tagline'}
Description: ${quest.description || 'No description'}
Status: ${quest.status}
Is Main: ${quest.is_main ? 'Yes' : 'No'}
`).join('\n---\n');

      // Define the schema for structured output
      const questMatcherSchema = {
        type: SchemaType.OBJECT as const,
        description: "Quest matching analysis result",
        properties: {
          questId: {
            type: SchemaType.INTEGER as const,
            description: "The ID of the best matching quest, or null if no good match",
            nullable: true
          },
          confidence: {
            type: SchemaType.NUMBER as const,
            description: "How confident the model is in this match (0-1)",
          },
          reason: {
            type: SchemaType.STRING as const,
            description: "Brief explanation of why this quest is the best fit"
          }
        },
        required: ["questId", "confidence", "reason"]
      };

      // Create a model with the schema for structured output
      const structuredModel = this.genAI.getGenerativeModel({
        model: "gemini-2.0-flash",
        generationConfig: {
          temperature: 0.4,
          responseMimeType: "application/json",
          responseSchema: questMatcherSchema
        }
      });

      // Prepare the prompt text
      const promptText = `You are analyzing a new task to determine which existing quest it belongs to.
Consider these criteria:
1. Theme alignment - does the task directly relate to the quest's purpose?
2. Scope fit - is the task at the right level of detail for the quest?
3. Timeline alignment - does the task fit within the quest's timeframe?

Find the best quest for this task:

New Task:
${taskInfo}

Available Quests:
${questsInfo}`;

      // Generate content with structured output
      const result = await structuredModel.generateContent(promptText);
      const responseText = result.response.text();
      
      if (!responseText) {
        console.log('‚ö†Ô∏è Empty response from Gemini for quest matching');
        const miscQuest = await getOrCreateMiscQuest(userId);
        return miscQuest.id;
      }
      
      // Parse the JSON response - should already be well-structured
      try {
        const parsed = JSON.parse(responseText);
        console.log(`‚úÖ Gemini returned quest match analysis with confidence: ${parsed.confidence}`);
        
        // If a quest was identified with good confidence, use it
        if (parsed.questId && parsed.confidence > 0.7) {
          console.log(`Found matching quest ID ${parsed.questId} with confidence ${parsed.confidence}`);
          console.log(`Reason: ${parsed.reason}`);
          return parsed.questId;
        } else {
          console.log('No confident quest match found. Using misc quest.');
          console.log(`Reason: ${parsed.reason}`);
          const miscQuest = await getOrCreateMiscQuest(userId);
          return miscQuest.id;
        }
      } catch (parseError) {
        console.error('‚ùå Error parsing Gemini response:', parseError);
        console.error('Raw response:', responseText);
        const miscQuest = await getOrCreateMiscQuest(userId);
        return miscQuest.id;
      }
    } catch (error) {
      console.error('‚ùå Error finding best quest for task:', error);
      const miscQuest = await getOrCreateMiscQuest(userId);
      return miscQuest.id;
    }
  }

  /**
   * Generates update fields for an existing task based on new source content
   * @param suggestion The new task suggestion
   * @param existingTask The existing task that was found to be a match
   * @param sourceContent The original source content that generated this suggestion
   * @returns Task update field recommendations
   */
  public async generateTaskUpdateFields(
    suggestion: TaskSuggestion, 
    existingTask: Task, 
    sourceContent: string,
    userId: string
  ): Promise<TaskUpdateFields> {
    performanceLogger.startOperation('generateTaskUpdateFields');
    try {
      // Get current personality for update analysis
      const personalityType = await personalityService.getUserPersonality(userId);
      const personality = getPersonality(personalityType);

      // Default result
      const defaultResult: TaskUpdateFields = {
        shouldUpdate: false,
        updateFields: [],
        updateValues: {}
      };
      
      // Check if there's source content to analyze
      if (!sourceContent || !existingTask) {
        console.log('Missing source content or existing task, cannot generate update fields');
        return defaultResult;
      }
      
      console.log(`Analyzing source content to generate updates for task: "${existingTask.title}"`);
      
      // Use Gemini 2.0 Flash to analyze the source content and suggest updates
      const prompt = `You are ${personality.name}. ${personality.description}

Analyze user message to determine how to update an existing task. Use your unique perspective to evaluate these changes.

Existing Task:
Title: ${existingTask.title}
Description: ${existingTask.description || 'None'}
Status: ${existingTask.status}
Scheduled for: ${existingTask.scheduled_for || 'None'}
Deadline: ${existingTask.deadline || 'None'}
Priority: ${existingTask.priority || 'None'}
Location: ${existingTask.location || 'None'}

User Message (that references this task):
"${sourceContent}"

New Task Suggestion Generated:
Title: ${suggestion.title}
Description: ${suggestion.description || 'None'}
Scheduled for: ${suggestion.scheduled_for}
Deadline: ${suggestion.deadline || 'None'}
Priority: ${suggestion.priority}
${suggestion.location ? `Location: ${suggestion.location}` : ''}

Based on the user message and the new suggestion, determine which fields should be updated in the existing task.

IMPORTANT GUIDELINES:
1. Use your characteristic perspective to evaluate changes
2. Only suggest updates for fields that have meaningful new information
3. Use the user message and context to determine what should be updated
4. Only include fields in updateValues that should actually change
5. For status, only use one of these exact values: "ToDo", "InProgress", or "Done"

Reply ONLY with a JSON object in this format:
{
  "shouldUpdate": true/false,
  "updateFields": ["title", "status", "description", "deadline", "scheduled_for", "location"],
  "updateValues": {
    "title": "The new title to use",
    "status": "ToDo/InProgress/Done",
    "description": "The new description to use",
    "deadline": "YYYY-MM-DD",
    "scheduled_for": "YYYY-MM-DD",
    "location": "The new location"
  }
}`;

      try {
        // Use Gemini model for analysis
        const result = await this.model.generateContent(prompt);
        const responseText = this.cleanResponseText(result.response.text().trim());
        
        if (!responseText) {
          console.log('Empty response from AI for update field generation');
          return defaultResult;
        }

        const parsed = JSON.parse(responseText);
        
        if (parsed.shouldUpdate) {
          console.log(`Suggested updates for task "${existingTask.title}":`, parsed.updateValues);
        }
        
        return {
          shouldUpdate: parsed.shouldUpdate || false,
          updateFields: parsed.updateFields || [],
          updateValues: parsed.updateValues || {}
        };
      } catch (parseError) {
        console.error('Error parsing update fields generation result:', parseError);
        return defaultResult;
      }
    } catch (error) {
      console.error('Error generating update fields:', error);
      return {
        shouldUpdate: false,
        updateFields: [],
        updateValues: {}
      };
    } finally {
      performanceLogger.endOperation('generateTaskUpdateFields');
    }
  }

  /**
   * Checks if a newly generated task suggestion is similar to existing tasks
   * @param suggestion The newly generated task suggestion
   * @param userId The user's ID
   * @returns TaskSimilarityResult with match information
   */
  public async checkForDuplicatesBeforeShowing(suggestion: TaskSuggestion, userId: string): Promise<TaskSimilarityResult> {
    try {
      console.log('üîç Checking if task suggestion is similar to existing active tasks:', suggestion.title);
      
      const allUserTasks = await fetchTasks(userId);
      const activeTasks = allUserTasks.filter(task => 
        task.status === 'ToDo' || task.status === 'InProgress'
      );
      
      if (activeTasks.length === 0) {
        console.log('No active tasks found for comparison');
        return {
          isMatch: false,
          existingTask: null,
          matchConfidence: 0
        };
      }
      
      console.log(`Comparing new task suggestion against ${activeTasks.length} active tasks`);
      
      const prompt = `You are analyzing if a new task suggestion is semantically equivalent to or a continuation of any existing tasks.

New Task Suggestion:
Title: ${suggestion.title}
Description: ${suggestion.description || 'None'}
Scheduled for: ${suggestion.scheduled_for}
Deadline: ${suggestion.deadline || 'None'}
Priority: ${suggestion.priority}
${suggestion.location ? `Location: ${suggestion.location}` : ''}

Existing active tasks:
${activeTasks.map(task => `
Task ID: ${task.id}
Title: ${task.title}
Description: ${task.description || 'None'}
Status: ${task.status}
Scheduled for: ${task.scheduled_for}
Deadline: ${task.deadline || 'None'}
Priority: ${task.priority || 'None'}
${task.location ? `Location: ${task.location}` : ''}
`).join('\n---\n')}

CRITICAL EVALUATION GUIDELINES:
1. Look for SEMANTIC EQUIVALENCE (same task):
   - "Make dinner" and "Cook pasta for dinner" refer to the same task
   - "Bake a cake" and "Bake chocolate cake for tomorrow" refer to the same task

2. Look for TASK CONTINUATIONS (logical next step):
   - "Schedule doctor appointment" -> "Go to doctor appointment"
   - "Buy ingredients for cake" -> "Bake the cake"
   - "Draft email to client" -> "Send client email"

Determine:
1. Is the new task SEMANTICALLY THE SAME as any existing task?
2. If not, is it a LOGICAL CONTINUATION of any existing task?
3. If yes to either, which existing task is it related to?

Reply ONLY with a JSON object in this format:
{
  "isMatch": true/false,
  "matchingTaskId": task id of matching task or null if no match,
  "matchConfidence": 0.0 to 1.0,
  "isContinuation": true/false,
  "continuationReason": "Brief explanation of why this is a continuation, or null if not"
}`;

      try {
        const result = await this.model.generateContent(prompt);
        const responseText = this.cleanResponseText(result.response.text().trim());
        
        if (!responseText) {
          console.log('Empty response from AI for task comparison');
          return {
            isMatch: false,
            existingTask: null,
            matchConfidence: 0
          };
        }

        const parsed = JSON.parse(responseText);
        
        const matchingTask = parsed.isMatch && parsed.matchingTaskId ? 
          activeTasks.find(t => t.id === parsed.matchingTaskId) || 
          activeTasks.find(t => t.id === Number(parsed.matchingTaskId)) :
          null;
        
        return {
          isMatch: !!parsed.isMatch,
          existingTask: matchingTask || null,
          matchConfidence: parsed.matchConfidence || 0,
          isContinuation: !!parsed.isContinuation,
          continuationReason: parsed.continuationReason || null
        };
        
      } catch (parseError) {
        console.error('Error parsing task comparison result:', parseError);
        return {
          isMatch: false,
          existingTask: null,
          matchConfidence: 0
        };
      }
    } catch (error) {
      console.error('Error checking for duplicate tasks:', error);
      return {
        isMatch: false,
        existingTask: null,
        matchConfidence: 0
      };
    }
  }

  /**
   * Regenerates a task suggestion with context from its predecessor
   * @param suggestion Current task suggestion
   * @param previousTask The task this one continues from
   * @param questContext Optional quest context if the task belongs to a quest
   */
  public async regenerateTaskWithContinuationContext(
    suggestion: TaskSuggestion,
    previousTask: Task,
    questContext?: Quest
  ): Promise<TaskSuggestion | null> {
    try {
      const currentDate = new Date().toISOString().split('T')[0];
      console.log('‚ôªÔ∏è Regenerating task suggestion with continuation context');
      
      const prompt = `Current date is: ${currentDate}

Generate an improved task description using the context of its predecessor task and quest.

Previous Task:
Title: ${previousTask.title}
Description: ${previousTask.description || 'None'}
Status: ${previousTask.status}
Priority: ${previousTask.priority || 'None'}

${questContext ? `Related Quest:
Title: ${questContext.title}
Description: ${questContext.description || 'None'}
Status: ${questContext.status}` : ''}

Current Task Suggestion:
Title: ${suggestion.title}
Description: ${suggestion.description || 'None'}

This task is a continuation or next step after the previous task.
Generate a JSON object with these EXACT fields that incorporates this context:
{
  "title": "Improved task title that shows continuity",
  "description": "Enhanced description that references the previous task",
  "priority": "high/medium/low (based on previous task)",
  "scheduled_for": "YYYY-MM-DD (must be ${currentDate} or later)",
  "tags": ["relevant", "tags", "including", "continuation"]
}

IMPORTANT:
- All dates must be ${currentDate} or later
- Never use dates from the past`;

      const response = await this.openai.chat.completions.create({
        model: "deepseek-chat",
        messages: [
          { role: "system", content: prompt }
        ],
        temperature: 0.4,
        response_format: { type: "json_object" }
      });

      const responseText = response.choices[0].message?.content;
      if (!responseText) {
        throw new Error('Empty response from AI');
      }

      const parsed = JSON.parse(responseText);
      const timestamp = new Date().toISOString();

      // Create new suggestion with improved context
      const enhancedSuggestion: TaskSuggestion = {
        ...suggestion,
        id: `task-${timestamp}-${Math.random().toString(36).substring(2, 10)}`,
        title: parsed.title,
        description: parsed.description,
        scheduled_for: parsed.scheduled_for,
        priority: parsed.priority,
        tags: parsed.tags,
        timestamp,
        previousTaskId: previousTask.id, // Add reference to previous task
        quest_id: previousTask.quest_id // Carry over the quest ID from the previous task
      };

      console.log('‚ú® Generated enhanced continuation task:', enhancedSuggestion.title);
      return enhancedSuggestion;

    } catch (error) {
      console.error('Error regenerating task with continuation context:', error);
      return null;
    }
  }

  /**
   * Converts a task suggestion into an edit suggestion for an existing task
   * @param suggestion The original task suggestion
   * @param existingTask The existing task that was found to be similar
   * @returns The modified task suggestion as an edit suggestion
   */
  public async convertToEditSuggestion(suggestion: TaskSuggestion, existingTask: Task): Promise<TaskSuggestion> {
    try {
      // Generate update fields based on the source content
      const updateFields = await this.generateTaskUpdateFields(suggestion, existingTask, suggestion.sourceContent, existingTask.user_id);
      
      // Modify the suggestion to indicate it's an edit suggestion and preserve quest context
      suggestion.isEditSuggestion = true;
      suggestion.existingTaskId = existingTask.id;
      suggestion.quest_id = existingTask.quest_id; // Ensure quest_id is carried over
      suggestion.updateValues = updateFields.updateValues;
      
      // Update the title to indicate it's an edit
      suggestion.title = `Update: ${suggestion.title}`;
      
      if (existingTask.title) {
        // Create a more useful description that shows what's being updated
        const updateFieldsList = updateFields.updateValues ? 
          Object.keys(updateFields.updateValues).join(', ') : 
          'No specific fields';
          
        suggestion.description = `Edit to existing task "${existingTask.title}":\n\n${suggestion.description}\n\nFields to update: ${updateFieldsList}`;
      }
      
      // Log for tracking quest context
      console.log('Created edit suggestion with quest context:', {
        taskId: suggestion.id,
        questId: suggestion.quest_id,
        title: suggestion.title
      });
      

      return suggestion;
    } catch (error) {
      console.error('Error converting to edit suggestion:', error);
      // If there's an error, just return the original suggestion
      return suggestion;
    }
  }

  /**
   * Clean response text from model output
   * Handles JSON formatting issues from different model outputs
   */
  private cleanResponseText(text: string): string {
    // Extract JSON content if wrapped in markdown code blocks
    const jsonRegex = /```(?:json)?\s*([\s\S]*?)\s*```/;
    const match = text.match(jsonRegex);
    if (match && match[1]) {
      return match[1].trim();
    }
    
    // If no code block, return the original text
    return text;
  }

  /**
   * Creates a quest in the database from a quest suggestion
   * @param suggestion The quest suggestion to create
   * @param userId The user's ID
   */
  async acceptQuestSuggestion(suggestion: QuestSuggestion, userId: string): Promise<Quest | null> {
    try {
      console.log('üìù Creating quest from suggestion:', suggestion.title);
      
      const questData = {
        title: suggestion.title,
        tagline: suggestion.tagline,
        description: suggestion.description,
        status: suggestion.status,
        start_date: suggestion.start_date,
        end_date: suggestion.end_date,
        is_main: false,
        user_id: userId
      };
      
      const quest = await createQuest(userId, questData);
      
      // Create related tasks if they exist
      if (suggestion.relatedTasks && suggestion.relatedTasks.length > 0) {
        for (const taskSuggestion of suggestion.relatedTasks) {
          await createTask({
            title: taskSuggestion.title,
            description: taskSuggestion.description,
            scheduled_for: taskSuggestion.scheduled_for,
            status: 'ToDo',
            priority: taskSuggestion.priority,
            quest_id: quest.id,
            user_id: userId
          });
        }
      }
      
      return quest;
    } catch (error) {
      console.error('Error creating quest from suggestion:', error);
      return null;
    }
  }
}

================
File: services/agents/ChatAgent.ts
================
import OpenAI from 'openai';
import { ChatMessage, JournalEntry, ChatSession } from '@/app/types';
import { ChatCompletionMessageParam } from 'openai/resources/chat';
import { journalService } from '../journalService';
import { QuestAgent } from './QuestAgent';
import { SuggestionAgent } from './SuggestionAgent';
import { performanceLogger } from '@/utils/performanceLogger';
import { 
  getCurrentMessagesFromDB, 
  getRecentJournalEntries, 
  createChatSession,
  updateMessagesWithSessionId
} from '@/hooks/useChatData';
import { PersonalityType, getPersonality } from './PersonalityPrompts';
import { personalityService } from '../personalityService';
import { eventsService, EVENT_NAMES } from '../eventsService';

export class ChatAgent {
  private openai: OpenAI;
  private questAgent: QuestAgent;
  
  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.EXPO_PUBLIC_DEEPSEEK_API_KEY,
      baseURL: 'https://api.deepseek.com', // updated per docs
      dangerouslyAllowBrowser: true
    });
    this.questAgent = new QuestAgent();
  }
  


  // Add this method to generate responses using the JournalAgent's method
  async generateResponse(content: string, previousCheckupsContext?: string, userId?: string): Promise<string> {
    performanceLogger.startOperation('generateResponse');
    console.log('üöÄ ChatAgent.generateResponse called for checkup content');
    
    try {
      // Replace validateUserId with direct check and guard clause
      if (!userId) {
        console.error('User ID is required for generateResponse');
        return "I need to know who you are to respond properly. Authentication issue.";
      }
      
      // Use journalService to generate a response, which will in turn use JournalAgent
      const response = await journalService.generateResponse(content, userId);
      console.log('üì• Generated response for checkup content:', response.substring(0, 100) + '...');
      return response;
    } catch (error) {
      console.error('‚ùå Error in ChatAgent.generateResponse:', error);
      return "Seems like my neural circuits are fried. Can't come up with anything clever right now.";
    } finally {
      performanceLogger.endOperation('generateResponse');
    }
  }

  async generateChatResponse(message: string, userId: string): Promise<string[]> { // Changed return type to string[]
    performanceLogger.startOperation('generateChatResponse');
    try {
      if (!userId) {
        console.error('User ID is required for generateChatResponse');
        return ["Authentication required. Please log in."];
      }

      // Get current personality for this call
      const personalityType = await personalityService.getUserPersonality(userId);
      const personality = getPersonality(personalityType);

      console.log('\n=== ChatAgent.generateChatResponse ===');
      console.log('Current message:', message);
      console.log ('Current Personality:', personality.name);
      // Get messages from localStorage instead of DB
      performanceLogger.startOperation('fetchCurrentMessages');
      let currentMessages: ChatMessage[] = [];
      try {
        const storedMessages = localStorage.getItem(`chat_messages_local_${userId}`);
        if (storedMessages) {
          currentMessages = JSON.parse(storedMessages);
        }
      } catch (currentError) {
        console.error('Error fetching chat messages from localStorage:', currentError);
        throw currentError;
      }
      performanceLogger.endOperation('fetchCurrentMessages');
        
      // First check for relevant quests based on the message
      console.log('Checking for relevant quests');
      performanceLogger.startOperation('findRelevantQuests');
      const relevantQuests = await this.questAgent.findRelevantQuests(message, userId);
      performanceLogger.endOperation('findRelevantQuests');
      console.log('Found relevant quests:', relevantQuests.map(q => q.title));

      // Get today's checkups first
      const today = new Date().toISOString().split('T')[0];
      console.log('Fetching today\'s checkups');
      performanceLogger.startOperation('fetchCheckups');
      const todaysCheckups = await journalService.getCheckupEntries(today, userId);
      performanceLogger.endOperation('fetchCheckups');
      console.log('Found', todaysCheckups.length, 'checkups from today');
      
      // Format quest context 
      performanceLogger.startOperation('buildContext');
      let questContext = '';
      if (relevantQuests.length > 0) {
        questContext = '\nRELEVANT QUEST AND TASK DETAILS:\n' + relevantQuests.map(quest => {
          let questInfo = `\nQuest: ${quest.title}\n`;
          questInfo += `Description: ${quest.description || 'No description available'}\n`;
          questInfo += `Current Status: ${quest.status || 'Unknown'}\n`;
          
          if (quest.relevantTasks && quest.relevantTasks.length > 0) {
            questInfo += '\nRelevant Tasks:\n';
            quest.relevantTasks.forEach(task => {
              questInfo += `- ${task.name}\n`;
              questInfo += `  Description: ${task.description}\n`;
              questInfo += `  Why Relevant: ${task.relevance}\n`;
            });
          }
          
          if (quest.relevance) {
            questInfo += `\nRelevance: ${quest.relevance}\n`;
          }
          return questInfo;
        }).join('\n---\n');
      }

      // Format today's checkups with responses as additional context
      let checkupContext = '';
      if (todaysCheckups && todaysCheckups.length > 0) {
        checkupContext = todaysCheckups.map(checkup => {
          const time = new Date(checkup.created_at).toLocaleTimeString([], { 
            hour: '2-digit', 
            minute: '2-digit',
            hour12: false
          });
          return `[${time}] Checkup: "${checkup.content}"\n[${time}] My Response: "${checkup.ai_checkup_response || 'No response recorded'}"`;
        }).join('\n\n');
      }

      // Replace direct SQL call with function from useChatData
      let recentEntries;
      try {
        recentEntries = await getRecentJournalEntries(userId, 2);
      } catch (journalError) {
        console.error('Error fetching journal entries:', journalError);
        throw journalError;
      }
      
      // Format journal context
      let journalContext = '';
      if (recentEntries && recentEntries.length > 0) {
        journalContext = recentEntries
          .filter(entry => entry.user_id === userId)
          .map(entry => 
          `Journal Entry: "${entry.user_entry}"\nMy Response: "${entry.ai_response}"`
        ).join('\n\n');
      }

      // Format messages for chat history
      const chatMessages = currentMessages?.map(msg => ({
        role: msg.is_user ? ("user" as const) : ("assistant" as const),
        content: msg.message
      })) || [];
      performanceLogger.endOperation('buildContext');

      // Build the final messages array with personality-based system prompt
      const messages: ChatCompletionMessageParam[] = [
        {
          role: "system",
          content: personality.prompts.chat.system + `

Background context from possibly relevant quests and tasks(only if relevant to current conversation):
${questContext ? '\n' + questContext + '\n' : ''}
Background context from recent journal entries (use this sparingly, only when relevant to current conversation):
${journalContext}
Additional background context from today's checkups (use this sparingly, only if relevant):
${checkupContext}`
        }
      ];
      
      // Add all previous messages from this chat session
      if (chatMessages.length > 0) {
        console.log('Adding previous messages to context:', chatMessages.length);
        messages.push(...chatMessages.map(msg => ({
          role: msg.role,
          content: msg.content
        })));
      }
      
      console.log('\n=== SENDING TO LLM ===');
      console.log('Full prompt data:', messages);
      
      // Get response from OpenAI with enhanced context
      performanceLogger.startOperation('aiResponse');
      const response = await this.openai.chat.completions.create({
        model: "deepseek-chat",
        messages: messages,
        temperature: 0.7,
        max_tokens: 400
      });
      performanceLogger.endOperation('aiResponse');

      // Get the response content and remove surrounding quotes if they exist
      performanceLogger.startOperation('processResponse');
      const responseText = response.choices[0].message?.content || "Listen up, got nothing to say right now. Come back when you've got something interesting.";
      console.log('Received AI response:', responseText);
      
      // Split response into separate messages by line breaks
      const cleanedResponse = responseText.replace(/^["'](.*)["']$/, '$1');
      const splitMessages = cleanedResponse
        .split(/\n+/) // Split on one or more newlines
        .map(msg => msg.trim())
        .filter(msg => msg.length > 0);
      performanceLogger.endOperation('processResponse');

      console.log('Split into messages:', splitMessages);
      
      return splitMessages;
    } catch (error) {
      console.error('Error in generateChatResponse:', error);
      return ["Damn netrunners must be messing with our connection. Try again in a bit."];
    } finally {
      performanceLogger.endOperation('generateChatResponse');
    }
  }

  async summarizeAndStoreSession(messages: ChatMessage[]): Promise<string> {
    performanceLogger.startOperation('storeSession');

    // Get the user_id right away for the event
    const userId = messages[0]?.user_id;
    if (!userId) {
      throw new Error('No user_id found in messages');
    }

    try {
      if (!messages || messages.length === 0) {
        throw new Error('No messages to store');
      }

      // Verify all messages belong to the same user
      const invalidMessages = messages.filter(msg => msg.user_id !== userId);
      if (invalidMessages.length > 0) {
        throw new Error('Session contains messages from multiple users');
      }

      console.log('\n=== ChatAgent.storeSession ===');
      
      // Generate simple timestamp-based summary instead of using LLM
      const messageCount = messages.length;
      const timestamp = new Date().toLocaleString();
      const summary = `Chat session with ${messageCount} messages on ${timestamp}`;
      
      // Use basic message content keywords as tags instead of LLM-generated ones
      const userMessages = messages.filter(m => m.is_user).map(m => m.message).join(' ');
      const commonWords = ['the', 'and', 'to', 'a', 'of', 'I', 'you', 'is', 'in', 'it', 'that', 'for', 'was'];
      const potentialTags = userMessages
        .toLowerCase()
        .replace(/[^\w\s]/g, '')
        .split(/\s+/)
        .filter(word => word.length > 3 && !commonWords.includes(word))
        .filter((word, i, arr) => arr.indexOf(word) === i) // Unique only
        .slice(0, 5); // Limit to 5 tags

      performanceLogger.startOperation('dbOperations');
      // Create session in database
      let sessionData;
      try {
        sessionData = await createChatSession(summary, potentialTags, userId);
      } catch (sessionError) {
        throw sessionError;
      }

      // Update all messages with the session ID
      try {
        await updateMessagesWithSessionId(messages.map(m => m.id), sessionData.id, userId);
      } catch (updateError) {
        throw updateError;
      }
      performanceLogger.endOperation('dbOperations');

      // Generate checkup entry from the session
      await this.createCheckupEntryFromSession(
        messages.filter(m => m.user_id === userId),
        summary,
        potentialTags
      );

      return sessionData.id;
    } catch (error) {
      console.error('Error in storeSession:', error);
      throw error;
    } finally {
      performanceLogger.endOperation('storeSession');
    }
  }

  // Updated method to create a checkup entry from a completed chat session
  async createCheckupEntryFromSession(messages: ChatMessage[], summary: string, tags: string[]): Promise<void> {
    performanceLogger.startOperation('createCheckupEntryFromSession');
    try {
      console.log('üîÑ Creating checkup entry from chat session');
      
      // Get the user_id from the first message
      const userId = messages[0]?.user_id;
      if (!userId) {
        throw new Error('No user_id found in messages');
      }
      
      // Step 1: Generate content for the checkup entry (user's perspective)
      performanceLogger.startOperation('generateCheckupContent');
      const checkupContent = await this.generateCheckupContent(messages, summary);
      performanceLogger.endOperation('generateCheckupContent');
      
      // Get today's date in YYYY-MM-DD format for the entry
      const today = new Date().toISOString().split('T')[0];
      
      // Step 2: Get today's previous checkups for context when generating the response
      performanceLogger.startOperation('fetchCheckupContext');
      console.log('üîÑ Fetching today\'s checkups for context');
      const todaysCheckups = await journalService.getCheckupEntries(today, userId);
      
      // Format previous checkups as context with paired responses
      let previousCheckupsContext = "";
      if (todaysCheckups && todaysCheckups.length > 0) {
        previousCheckupsContext = todaysCheckups
          .map(entry => {
            const time = new Date(entry.created_at).toLocaleTimeString([], { 
              hour: '2-digit', 
              minute: '2-digit',
              hour12: false
            });
            return `[${time}] USER: ${entry.content}\n[${time}] ASSISTANT: ${entry.ai_checkup_response || 'No response recorded'}`;
          })
          .join('\n\n');
      }
      performanceLogger.endOperation('fetchCheckupContext');
      
      // Step 3: Generate Johnny's response to this new checkup content
      performanceLogger.startOperation('generateAIResponse');
      console.log('ü§ñ Generating AI response for the checkup with context');
      const aiResponse = await this.generateResponse(checkupContent, previousCheckupsContext, userId);
      performanceLogger.endOperation('generateAIResponse');
      
      // Step 4: Save the complete checkup entry with both content and AI response
      performanceLogger.startOperation('saveCheckup');
      console.log('üíæ Saving complete checkup entry to database');
      await journalService.saveCheckupEntry(today, checkupContent, userId, tags, aiResponse);
      performanceLogger.endOperation('saveCheckup');
      
      console.log('‚úÖ Successfully created complete checkup entry from chat session');
    } catch (error) {
      console.error('‚ùå Error creating checkup entry from chat session:', error);
      // Fail gracefully - don't throw, as this is an enhancement, not core functionality
    } finally {
      performanceLogger.endOperation('createCheckupEntryFromSession');
    }
  }

  // Updated method to generate content for the checkup entry with more accurate user voice
  private async generateCheckupContent(messages: ChatMessage[], summary: string): Promise<string> {
    performanceLogger.startOperation('generateCheckupContent');
    try {
      console.log('\n=== ChatAgent.generateCheckupContent ===');
      
      const userMessages = messages.filter(msg => msg.is_user);
      const johnnyMessages = messages.filter(msg => !msg.is_user);
      const userId = messages[0]?.user_id;
      
      if (!userId) {
        throw new Error('No user_id found in messages');
      }

      // Verify all messages are from the same user
      if (messages.some(m => m.user_id !== userId)) {
        throw new Error('Cannot generate checkup content: Messages from multiple users');
      }
      
      const today = new Date().toISOString().split('T')[0];
      performanceLogger.startOperation('fetchTodayCheckups');
      const todaysCheckups = await journalService.getCheckupEntries(today, userId);
      performanceLogger.endOperation('fetchTodayCheckups');
      console.log('Today\'s checkups for style analysis:', todaysCheckups?.map(c => c.content));
      
      // Format previous user entries to help model understand user's style
      performanceLogger.startOperation('prepareContent');
      let userStyleSamplesContent = '';
      if (todaysCheckups && todaysCheckups.length > 0) {
        // Extract only user entries for style analysis
        userStyleSamplesContent = todaysCheckups
          .map(checkup => {
            const entryTime = new Date(checkup.created_at).toLocaleTimeString('en-US', { 
              hour: '2-digit', 
              minute: '2-digit',
              hour12: false 
            });
            return `[${entryTime}] "${checkup.content}"`;
          })
          .join('\n\n');
      }

      const now = new Date();
      const currentTime = now.toLocaleTimeString('en-US', { 
        hour: '2-digit', 
        minute: '2-digit',
        hour12: false
      });

      // Extract only the user's messages and Johnny's responses
      const userMessagesContent = userMessages
        .map(msg => msg.message)
        .join('\n');
      
      const johnnyMessagesContent = johnnyMessages
        .map(msg => msg.message)
        .join('\n');
      performanceLogger.endOperation('prepareContent');
      
      console.log('\n=== SENDING TO LLM ===');
      console.log('System prompt: Creating journal entry from chat');
      
      // Get the appropriate personality prompts
      const personalityType = await personalityService.getUserPersonality(userId);
      const personality = getPersonality(personalityType);
      
      // Replace {time} placeholder with the current time
      const checkupEntrySystem = `You are helping to create a journal entry based on the user's chat with ${personality.name}.

INSTRUCTIONS:
1. Current time is {time}
2. Write from the user's perspective
3. Focus only on what the user said/discussed
4. Match the user's writing style from previous entries
5. Start with [{time}] timestamp
6. Be concise but capture key thoughts/feelings
7. Do not mention this being an AI-generated entry
8. Only reference the user's messages, not ${personality.name}'s responses`.replace(/{time}/g, currentTime);
      
      performanceLogger.startOperation('aiGeneration');
      const response = await this.openai.chat.completions.create({
        model: "deepseek-chat",
        messages: [
          {
            role: "system",
            content: checkupEntrySystem
          },
          {
            role: "user",
            content: `Here are examples of my previous journal entries today (study these to understand my writing style):
${userStyleSamplesContent}

Here's our chat conversation:
${messages}

Remember to use ONLY my messages to create a summary of what *I*, the user, talked about. Avoid writing down that I said something when it was actually johnny. Here are MY MESSAGES: ${userMessagesContent}

Write a reflective journal entry from my perspective about what I discussed in my messages, matching my writing style from the previous entries.`
          }
        ],
        temperature: 0.7,
        max_tokens: 3000
      });
      performanceLogger.endOperation('aiGeneration');

      performanceLogger.startOperation('processContent');
      const aiContent = response.choices[0].message?.content || 
             `[${currentTime}] Just had a chat with Johnny where I brought up the things that have been on my mind.`;
      
      // Ensure the content starts with the timestamp
      if (!aiContent.startsWith(`[${currentTime}]`)) {
        return `[${currentTime}] ${aiContent}`;
      }
      
      console.log('Received AI-generated journal entry:', aiContent);
      return aiContent;
    } catch (error) {
      console.error('Error generating checkup content:', error);
      const currentTime = new Date().toLocaleTimeString('en-US', { 
        hour: '2-digit', 
        minute: '2-digit',
        hour12: false
      });
      return `[${currentTime}] Had a conversation with Johnny about some things on my mind.`;
    } finally {
      performanceLogger.endOperation('generateCheckupContent');
    }
  }
}



================================================================
End of Codebase
================================================================
