This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: components/journal/CheckupItem.tsx, components/journal/JournalPanel.tsx, hooks/useChatData.ts, hooks/useJournal.ts, services/agents/ChatAgent.ts, services/agents/JournalAgent.ts, services/journalService.ts
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
components/journal/CheckupItem.tsx
components/journal/JournalPanel.tsx
hooks/useChatData.ts
hooks/useJournal.ts
services/agents/ChatAgent.ts
services/agents/JournalAgent.ts
services/journalService.ts

================================================================
Files
================================================================

================
File: components/journal/CheckupItem.tsx
================
import React from 'react';
import { View, Text, TouchableOpacity, ScrollView } from 'react-native';
import { MaterialIcons } from '@expo/vector-icons';
import { ThemedText } from '@/components/ui/ThemedText';
import { CheckupEntry } from '@/services/journalService';

interface CheckupItemProps {
  checkup: CheckupEntry;
  themeColor: string;
  onPress: () => void;
  isExpanded: boolean;
  secondaryColor: string; // Add secondaryColor prop
}

export const CheckupItem: React.FC<CheckupItemProps> = ({
  checkup,
  themeColor,
  onPress,
  isExpanded,
  secondaryColor
}) => {
  const checkupTime = new Date(checkup.created_at).toLocaleTimeString('en-US', { 
    hour: '2-digit', 
    minute: '2-digit',
    hour12: false
  });
  
  // Get a summary of the entry (first sentence or first 60 chars)
  const summary = checkup.content.split('.')[0] + (checkup.content.length > 60 ? '...' : '');
  
  return (
    <TouchableOpacity
      onPress={onPress}
      style={{
        padding: 12,
        backgroundColor: 'rgba(20, 20, 20, 0.7)',
        borderRadius: 4,
        marginBottom: 8,
        borderLeftWidth: 2,
        borderLeftColor: themeColor,
      }}
    >
      <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}>
        <Text style={{ color: '#AAA', fontSize: 12, fontWeight: 'bold' }}>
          {checkupTime}
        </Text>
        <MaterialIcons
          name={isExpanded ? "expand-less" : "expand-more"}
          size={18}
          color="#AAA"
        />
      </View>
      
      {isExpanded ? (
        <View style={{ marginTop: 8 }}>
          <Text style={{ 
            color: '#FFB74D', // Changed from red to warm amber
            fontSize: 15,
            textShadowColor: '#FFB74D',
            textShadowOffset: { width: 0, height: 0 },
            textShadowRadius: 3
          }}>
            {checkup.content}
          </Text>
          
          {/* Update AI response styling to match AIResponse component */}
          {checkup.ai_checkup_response && (
            <View style={{
              marginTop: 10,
              backgroundColor: 'rgba(15, 15, 15, 0.8)',
              borderRadius: 5,
              borderLeftWidth: 3,
              borderColor: secondaryColor,
            }}>
              {/* Match the header styling from AIResponse */}
              <View style={{ 
                flexDirection: 'row', 
                alignItems: 'center', 
                padding: 10,
                borderBottomWidth: 1,
                borderBottomColor: 'rgba(255, 255, 255, 0.1)',
              }}>
                <MaterialIcons 
                  name="psychology" 
                  size={16} 
                  color={secondaryColor}
                  style={{ marginRight: 8 }} 
                />
                <ThemedText style={{
                  fontSize: 14,
                  fontWeight: 'bold',
                  color: secondaryColor,
                }}>
                  SILVERHAND
                </ThemedText>
              </View>
              
              {/* Match the content styling from AIResponse */}
              <ScrollView style={{ padding: 10, maxHeight: 150 }}>
                <ThemedText style={{
                  fontSize: 15,
                  color: secondaryColor,
                  fontStyle: 'italic',
                  textShadowColor: secondaryColor,
                  textShadowOffset: { width: 0, height: 0 },
                  textShadowRadius: 3
                }}>
                  {checkup.ai_checkup_response}
                </ThemedText>
              </ScrollView>
            </View>
          )}
        </View>
      ) : (
        <Text style={{ 
          color: '#FFB74D', // Changed from red to warm amber
          marginTop: 4, 
          fontSize: 15,
          textShadowColor: '#FFB74D',
          textShadowOffset: { width: 0, height: 0 },
          textShadowRadius: 3
        }} numberOfLines={1}>
          {summary}
        </Text>
      )}
    </TouchableOpacity>
  );
};

================
File: hooks/useJournal.ts
================
// File: hooks/useJournal.ts
import { useState, useEffect, useCallback } from 'react';
// <<< Correct: Import CheckupEntry and JournalEntry if needed elsewhere
import { journalService, CheckupEntry, JournalEntry } from '@/services/journalService';
import { useQuestUpdate } from '@/contexts/QuestUpdateContext';
import { useSupabase } from '@/contexts/SupabaseContext';
import { useRouter } from 'expo-router';

export function useJournal() {
    const router = useRouter();
    const { session } = useSupabase();
    const [currentDate, setCurrentDate] = useState(new Date());
    // <<< FIX: State should hold CheckupEntry arrays as getEntries returns CheckupEntry[]
    const [entries, setEntries] = useState<Record<string, CheckupEntry[]>>({});
    const [localEntries, setLocalEntries] = useState<Record<string, string>>({});
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const { triggerUpdate } = useQuestUpdate();
    // These might be less relevant if daily analysis isn't stored/fetched here
    const [aiResponse, setAiResponse] = useState<string | null>(null);
    const [aiAnalysis, setAiAnalysis] = useState<string | null>(null);

    const formatDate = (date: Date): string => {
        return date.toISOString().split('T')[0];
    };

    // Fetch entries for the last 7 days
    const fetchRecentEntries = useCallback(async () => {
        if (!session?.user?.id) {
            setError("User not authenticated");
            return;
        }

        setLoading(true);
        setError(null);

        try {
            const today = new Date();
            const sevenDaysAgo = new Date();
            sevenDaysAgo.setDate(today.getDate() - 6); // Fetch last 7 days

            const startDate = formatDate(sevenDaysAgo);
            const endDate = formatDate(today);

            console.log('Fetching checkup entries for user', session.user.id, 'from', startDate, 'to', endDate);
            // <<< Correct: getEntries returns CheckupEntry[]
            const checkupEntries: CheckupEntry[] = await journalService.getEntries(startDate, endDate, session.user.id);
            console.log('Fetched checkup entries:', checkupEntries.length);

            // Convert to our local format, organized by date
            const entriesRecord: Record<string, CheckupEntry[]> = {};
            // <<< FIX: Loop variable must be CheckupEntry
            checkupEntries.forEach((entry: CheckupEntry) => {
                const entryDateStr = entry.created_at ? formatDate(new Date(entry.created_at)) : null;
                if (entryDateStr) {
                    if (!entriesRecord[entryDateStr]) {
                        entriesRecord[entryDateStr] = [];
                    }
                    // <<< FIX: Add 'date' property, consistent with getEntries mapping in journalService
                    // Note: journalService.getEntries already adds this 'date' property,
                    // so we might not strictly need to add it again here, but being explicit is safe.
                    // Ensure the 'date' property is defined on the CheckupEntry interface if needed downstream.
                    // Let's assume CheckupEntry might not have 'date' initially.
                    const entryWithDate = { ...entry, date: entryDateStr };
                    entriesRecord[entryDateStr].push(entryWithDate);
                 } else {
                    console.warn("Checkup entry missing created_at:", entry.id);
                 }
            });

            setEntries(entriesRecord);
            console.log('Updated entries state (as checkups by date):', Object.keys(entriesRecord).length, 'dates');

        } catch (err: any) {
            const errorMessage = err?.message || "Failed to load journal entries";
            setError(errorMessage);
            console.error("Error in fetchRecentEntries:", { error: err, userId: session.user.id });
        } finally {
            setLoading(false);
        }
    }, [session?.user?.id]);

    // Load entries initially and when session changes
    useEffect(() => {
      if (session?.user?.id) {
         console.log('User session available, fetching recent entries...');
         fetchRecentEntries();
      } else {
         console.log('No user session, clearing entries.');
         setEntries({}); // Clear entries if logged out
      }
   }, [session?.user?.id, fetchRecentEntries]); // Depend on fetchRecentEntries

    // Load entries whenever currentDate changes (optional, depends on UI needs)
    // Consider if fetching only the specific day is more efficient if needed.
    // For now, refetching recent range keeps consistency.
    useEffect(() => {
      console.log('Current date changed to', formatDate(currentDate), '- refreshing entries');
      if (session?.user?.id) { // Only fetch if logged in
        fetchRecentEntries();
      }
    }, [currentDate, session?.user?.id, fetchRecentEntries]); // Added dependencies

    // <<< FIX: getEntry returns CheckupEntry | null based on state
    const getEntry = useCallback((date: Date): CheckupEntry | null => {
        const dateStr = formatDate(date);
        const dateEntries = entries[dateStr] || [];
        // Return the latest checkup entry for the date
        return dateEntries.length > 0 ? dateEntries[dateEntries.length - 1] : null;
    }, [entries]);

    // <<< FIX: getAiResponses based on CheckupEntry
    const getAiResponses = useCallback((date: Date): { response: string | null; analysis: string | null } => {
        const entry = getEntry(date); // Gets the latest CheckupEntry for the date
        return {
            response: entry?.ai_checkup_response || null,
            analysis: null // CheckupEntry does not have ai_analysis
        };
    }, [getEntry]);

    // Update local entry text without saving to database
    const updateLocalEntry = useCallback((date: Date, content: string) => {
        const dateStr = formatDate(date);
        setLocalEntries(prev => ({
            ...prev,
            [dateStr]: content
        }));
    }, []);

    // Save entry (which is a Checkup) to the database
    const saveEntry = useCallback(async (date: Date, content: string, tags: string[] = []) => {
        if (!session?.user?.id) {
            console.warn("Cannot save entry: User not logged in");
            throw new Error("Please log in to save journal entries");
        }

        const dateStr = formatDate(date);
        setLoading(true);
        try {
            // <<< Correct: saveCheckupEntry is the right function here
            const savedEntry = await journalService.saveCheckupEntry(
                dateStr,
                content,
                session.user.id,
                tags
            );

            await fetchRecentEntries(); // Refresh entries (checkups)

            setLocalEntries(prev => ({ // Clear local text for this date after saving
                ...prev,
                [dateStr]: ''
            }));

            triggerUpdate();
            return savedEntry; // Returns the saved CheckupEntry
        } catch (err: any) {
            const errorMessage = err?.message || "Failed to update journal entry";
            setError(errorMessage);
            console.error("Error in saveEntry:", { error: err, userId: session.user.id });
            throw err;
        } finally {
            setLoading(false);
        }
    }, [fetchRecentEntries, triggerUpdate, session?.user?.id]);


    const goToPreviousDay = () => {
        const prevDay = new Date(currentDate);
        prevDay.setDate(prevDay.getDate() - 1);
        setCurrentDate(prevDay);
    };

    const goToNextDay = () => {
        const nextDay = new Date(currentDate);
        nextDay.setDate(nextDay.getDate() + 1);
        const today = new Date();
        if (nextDay <= today) {
            setCurrentDate(nextDay);
        }
    };

    return {
        currentDate,
        // entries, // Expose entries map directly if needed by UI
        localEntries, // Expose local unsaved text
        getEntry, // Gets latest CheckupEntry for a date
        getAiResponses, // Gets AI response for latest CheckupEntry
        updateLocalEntry, // Updates local unsaved text
        saveEntry, // Saves current local text as a new CheckupEntry
        goToPreviousDay,
        goToNextDay,
        loading,
        error,
        refreshEntries: fetchRecentEntries,
        // aiResponse/aiAnalysis state might be less useful now
    };
}

================
File: services/agents/JournalAgent.ts
================
// ================================================================
// File: services/agents/JournalAgent.ts
// Goal: Ensure correct event emission for suggestion context, remove performanceLogger.
// ================================================================
import OpenAI from 'openai';
import { QuestAgent } from './QuestAgent';
import { journalService } from '../journalService';
import { eventsService, EVENT_NAMES } from '../eventsService'; // Correct path if needed
import { getPersonality } from './PersonalityPrompts';
import { personalityService } from '../personalityService';

export class JournalAgent {
    private openai: OpenAI;
    private questAgent: QuestAgent;

    constructor() {
      this.openai = new OpenAI({
        apiKey: process.env.EXPO_PUBLIC_DEEPSEEK_API_KEY,
        baseURL: 'https://api.deepseek.com',
        dangerouslyAllowBrowser: true
      });
      this.questAgent = new QuestAgent();
    }

    // Helper method to trigger suggestion analysis via SuggestionContext
    private emitJournalAnalysisEvent(entry: string, userId: string): void {
      try {
        console.log('üì£ Emitting analyzeJournalEntry event for SuggestionContext');
        // Include sourceType in the payload
        eventsService.emit(EVENT_NAMES.ANALYZE_JOURNAL_ENTRY, {
            entry,
            userId,
            sourceType: 'journal' // Added sourceType
        });
      } catch (error) {
        console.error('‚ùå Error emitting journal analysis event:', error);
      }
    }

    async generateResponse(currentEntry: string, userId: string, previousCheckupsContext?: string): Promise<string> {
      console.log('üöÄ JournalAgent.generateResponse called with entry:', currentEntry.substring(0, 50) + '...'); // Log snippet

      try {
        // --- Start suggestion analysis in parallel ---
        console.log('üîç Triggering suggestion analysis for journal entry...');
        // This correctly triggers the SuggestionContext via the event service
        this.emitJournalAnalysisEvent(currentEntry, userId);
        // --- End suggestion analysis trigger ---

        // Continue with response generation immediately
        console.log('üîÑ Proceeding with response generation');
        const recentEntries = await journalService.getRecentEntries(3, userId);

        // Format context for OpenAI, now including timestamp information
        const context = recentEntries?.map(entry => ({
          entry: entry.user_entry || '', // Provide default empty string
          response: entry.ai_response || '', // Provide default empty string
          updated_at: entry.updated_at
        })) || [];
        
        // Create the prompt with consistent paired format
        // The error occurs when passing `context` here:
        const prompt = await this.createResponsePrompt(currentEntry, context, userId, previousCheckupsContext);
        
        console.log('üì§ Sending prompt to AI for response...'); // Removed detailed prompt logging

        // Get current personality for this call
        const personalityType = await personalityService.getUserPersonality(userId);
        const personality = getPersonality(personalityType);

        // Get OpenAI response
        const response = await this.openai.chat.completions.create({
          model: "deepseek-chat",
          messages: [
            {
              role: "system",
              content: personality.prompts.journal.system // Use 'journal' prompt context
            },
            {
              role: "user",
              content: prompt
            }
          ],
          temperature: 0.7,
          max_tokens: 8000 // Consider adjusting if responses are cut off
        });

        const aiResponse = response.choices[0].message?.content || `Hey choom, looks like my neural circuits are fried. Try again in a bit.`;
        console.log('üì• Received AI response (length):', aiResponse.length);

        // After generating response, check for quest updates
        const relevantQuests = await this.questAgent.findRelevantQuests(currentEntry, userId);

        // For each relevant quest, analyze the entry for potential updates
        for (const quest of relevantQuests) {
          await this.questAgent.analyzeContentForQuest(
            currentEntry,
            quest.id,
            userId,
            'journal' // Indicate source is journal
          );
        }

        return aiResponse;
      } catch (error) {
        console.error('‚ùå Error in generateResponse:', error);
        // Consider returning a more user-friendly error message
        return "Sorry, I encountered an error trying to generate a response.";
      }
    }

    async generateAnalysis(currentEntry: string, userId: string, previousCheckupsContext?: string): Promise<string> {
      console.log('üöÄ JournalAgent.generateAnalysis called with entry:', currentEntry.substring(0, 50) + '...');
      console.log('üîÑ Previous checkup context available:', !!previousCheckupsContext);

      try {
        // Fetch recent journal entries using the service
        const recentEntries = await journalService.getRecentEntries(3, userId);

        // Format context for OpenAI with timestamp info
        const context = recentEntries?.map(entry => ({
          entry: entry.user_entry || '', // Provide default empty string
          response: entry.ai_response || '', // Provide default empty string
          updated_at: entry.updated_at
        })) || [];
        
        // Create the prompt with consistent paired format
        // The error occurs when passing `context` here:
        const prompt = await this.createResponsePrompt(currentEntry, context, userId, previousCheckupsContext);
        
        console.log('üì§ Sending analysis prompt to AI...'); // Removed detailed prompt logging

        // Get current personality for this call
        const personalityType = await personalityService.getUserPersonality(userId);
        const personality = getPersonality(personalityType);

        // Get OpenAI response with analysis prompt
        const response = await this.openai.chat.completions.create({
          model: "deepseek-chat",
          messages: [
            {
              role: "system",
              content: personality.prompts.analysis.system // Use 'analysis' prompt context
            },
            {
              role: "user",
              content: prompt
            }
          ],
          temperature: 0.7, // Temp might be lower for analysis? Test needed.
          max_tokens: 8000
        });

        const aiAnalysis = response.choices[0].message?.content || 'Not seeing any patterns worth mentioning yet. Keep writing and I might find something.';
        console.log('üì• Received AI analysis (length):', aiAnalysis.length);

        return aiAnalysis;
      } catch (error) {
        console.error('‚ùå Error in generateAnalysis:', error);
        return "Sorry, I encountered an error during analysis.";
      }
    }

    // Updated prompt creation to better utilize task relevance information
    private async createResponsePrompt(currentEntry: string, context: Array<{ entry: string; response: string; updated_at: string }>, userId: string, previousCheckupsContext?: string): Promise<string> {
      console.log('üîß Creating response prompt with context entries:', context.length);

      // Fetch relevant quests - RLS handles clerk_id filtering
      const relevantQuests = await this.questAgent.findRelevantQuests(currentEntry, userId);
      console.log('‚ú® Found relevant quests for prompt:', relevantQuests.map(q => q.title));

      const currentTime = new Date().toLocaleTimeString([], {
        hour: '2-digit',
        minute: '2-digit',
        hour12: false
      });
      const currentDate = new Date().toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric'
      });

      let prompt = '';

      // --- Historical Daily Entries Context ---
      if (context.length > 0) {
        prompt += "HISTORICAL CONTEXT (Recent Daily Summaries):\n";
        context.forEach((entry, index) => {
          const entryDate = new Date(entry.updated_at);
          const formattedDate = entryDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
          const formattedTime = entryDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
          prompt += `Previous Daily Entry ${index + 1} [${formattedDate}, ${formattedTime}]: "${entry.entry}"\n`;
          prompt += `Your Response: "${entry.response}"\n\n`;
        });
      }

      // --- Relevant Quest & Task Context ---
      if (relevantQuests.length > 0) {
        prompt += `\nRELEVANT QUEST AND TASK DETAILS:\n`;
        relevantQuests.forEach(quest => {
          prompt += `\nQuest: ${quest.title} (Status: ${quest.status || 'Unknown'})\n`;
          prompt += `Description: ${quest.description || 'No description available'}\n`;

          // Add specifically relevant tasks section with explanations
          if (quest.relevantTasks && quest.relevantTasks.length > 0) {
            prompt += 'Relevant Tasks Mentioned:\n';
            quest.relevantTasks.forEach(task => {
              prompt += `- ${task.name} (Desc: ${task.description || 'N/A'}, Why Relevant: ${task.relevance})\n`;
            });
          }

          // Add other tasks for context
          const otherTasks = quest.tasks?.filter(task =>
            !quest.relevantTasks?.some(rt => rt.taskId === task.id)
          );
          if (otherTasks && otherTasks.length > 0) {
            prompt += 'Other Related Tasks:\n';
            otherTasks.forEach(task => {
              prompt += `- ${task.title} (${task.status})\n`;
            });
          }
          if (quest.relevance) {
            prompt += `\nRelevance to Current Entry: ${quest.relevance}\n`;
          }
          prompt += '---\n';
        });
        prompt += '\nFocus on addressing the specifically relevant tasks in your response, keeping the broader quest context in mind.\n\n';
      }

      // --- Today's Previous Checkups Context ---
      if (previousCheckupsContext && previousCheckupsContext.trim()) {
        prompt += `IMPORTANT: EARLIER TODAY'S CONVERSATION (Timestamped):\n${previousCheckupsContext}\n\n`;
        prompt += `REMINDER: You've already responded to the above. Address ONLY what's new in the entry below. Acknowledge continuity if present, but avoid repeating yourself.\n\n`;
      }

      // --- Instructions ---
      prompt += `INSTRUCTIONS FOR YOUR RESPONSE:
1. Respond ONLY to the user's LATEST checkup entry (provided below).
2. Focus on what's NEW or DIFFERENT compared to earlier checkups today.
3. DO NOT repeat advice/commentary already given in your previous responses today.
4. Maintain your characteristic personality style (sarcastic but supportive if Johnny, etc.).
5. Keep responses concise and impactful.
6. No emojis unless extremely fitting for the personality. Avoid overusing emotes (*action*).\n\n`;

      // --- Current Entry ---
      prompt += `USER'S LATEST CHECKUP ENTRY ([${currentDate}, ${currentTime}]):\n${currentEntry}\n`;
      prompt += `\nYOUR RESPONSE:`; // Added explicit marker for the AI

      return prompt;
    }

    private async createAnalysisPrompt(currentEntry: string, context: Array<{ entry: string; analysis: string; updated_at: string }>, userId: string, previousCheckupsContext?: string): Promise<string> {
      console.log('üîß Creating analysis prompt...');
      const relevantQuests = await this.questAgent.findRelevantQuests(currentEntry, userId);
      console.log('‚ú® Found relevant quests for analysis prompt:', relevantQuests.map(q => q.title));

      let prompt = `ANALYZE THE FOLLOWING LATEST JOURNAL ENTRY:\n"${currentEntry}"\n\n`;

       // --- Relevant Quest & Task Context ---
       if (relevantQuests.length > 0) {
        prompt += `RELEVANT QUEST AND TASK CONTEXT:\n`;
        relevantQuests.forEach(quest => {
          prompt += `\nQuest: ${quest.title}\n`;
          if (quest.relevance) prompt += `Why Relevant: ${quest.relevance}\n`;
          if (quest.relevantTasks && quest.relevantTasks.length > 0) {
            prompt += 'Directly Relevant Tasks:\n';
            quest.relevantTasks.forEach(task => prompt += `- ${task.name} (Relevance: ${task.relevance})\n`);
          }
        });
        prompt += 'Consider these relationships in your analysis.\n\n';
      }

      // --- Today's Previous Checkups Context ---
      if (previousCheckupsContext && previousCheckupsContext.trim()) {
        prompt += `CONTEXT FROM EARLIER TODAY (User Entries & Your Responses):\n${previousCheckupsContext}\n\n`;
      }

      // --- Historical Daily Entries Context ---
      if (context.length > 0) {
        prompt += "HISTORICAL CONTEXT (Recent Daily Summaries):\n";
        context.forEach((entry, index) => {
          const entryDate = new Date(entry.updated_at);
          const formattedDate = entryDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
          const formattedTime = entryDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
          prompt += `Previous Daily Entry ${index + 1} [${formattedDate}, ${formattedTime}]: "${entry.entry}"\n`;
          prompt += `Your previous analysis: "${entry.analysis}"\n\n`;
        });
      }

      // --- Analysis Instructions ---
      prompt += `YOUR ANALYSIS TASK:
1. Analyze the LATEST entry considering today's earlier entries and historical context to identify patterns, shifts, or insights.
2. Connect the entry to the relevant quests and tasks mentioned above. Analyze progress, blockers, or changes in focus.
3. Identify potential underlying themes or connections.
4. Maintain your characteristic personality style in the analysis.\n\n`;

      prompt += `LATEST JOURNAL ENTRY FOR FINAL ANALYSIS:\n"${currentEntry}"\n\n`;
      prompt += `YOUR ANALYSIS:`; // Added explicit marker

      console.log('‚úÖ Analysis prompt created.');
      return prompt;
    }

    // Process journal entry with mandatory userId
    async processJournalEntry(currentEntry: string, userId: string, previousCheckupsContext?: string): Promise<{ response: string; analysis: string }> {
      console.log('üöÄ JournalAgent.processJournalEntry called...');

      try {
        console.log('üîÑ Processing journal entry with Promise.all for response and analysis');
        // Run response and analysis generation concurrently
        const [response, analysis] = await Promise.all([
          this.generateResponse(currentEntry, userId, previousCheckupsContext),
          this.generateAnalysis(currentEntry, userId, previousCheckupsContext)
        ]);

        console.log('‚úÖ processJournalEntry complete.');
        return { response, analysis };
      } catch (error) {
        console.error('‚ùå Error in processJournalEntry:', error);
        // Provide fallback results on error
        return {
            response: "Error generating response.",
            analysis: "Error generating analysis."
        };
      }
    }

    // Updated to recognize paired checkup/response format
    async processEndOfDay(allCheckupEntriesWithResponses: string, userId: string): Promise<{ response: string; analysis: string }> {
      console.log('üöÄ JournalAgent.processEndOfDay called...');

      try {
        const prompt = await this.createEndOfDayPrompt(allCheckupEntriesWithResponses, userId);
        console.log('üì§ Sending end-of-day prompt to AI...');

        // Get current personality for this call
        const personalityType = await personalityService.getUserPersonality(userId);
        const personality = getPersonality(personalityType);

        // Generate response and analysis concurrently
        console.log('üîÑ Generating end-of-day response and analysis concurrently...');
        const [responseResult, analysisResult] = await Promise.all([
            this.openai.chat.completions.create({
                model: "deepseek-chat",
                messages: [
                    { role: "system", content: personality.prompts.endOfDay.system },
                    { role: "user", content: prompt }
                ],
                temperature: 0.7,
                max_tokens: 8000 // Adjust as needed
            }),
            this.openai.chat.completions.create({
                model: "deepseek-chat", // Use same or different model for analysis
                messages: [
                    { role: "system", content: personality.prompts.analysis.system }, // Use analysis system prompt
                    { role: "user", content: prompt } // Same user prompt can work for analysis too
                ],
                temperature: 0.5, // Potentially lower temp for analysis
                max_tokens: 8000
            })
        ]);

        const responseText = responseResult.choices[0]?.message?.content || "Error generating end-of-day response";
        const analysisText = analysisResult.choices[0]?.message?.content || "Error generating end-of-day analysis";

        console.log('üì• Received end-of-day response (length):', responseText.length);
        console.log('üì• Received end-of-day analysis (length):', analysisText.length);

        return { response: responseText, analysis: analysisText };
      } catch (error) {
        console.error('‚ùå Error in processEndOfDay:', error);
        return {
            response: "Error generating end-of-day response.",
            analysis: "Error generating end-of-day analysis."
        };
      }
    }

    private async createEndOfDayPrompt(allCheckupEntriesWithResponses: string, userId: string): Promise<string> {
      console.log('üîß Creating end-of-day prompt...');

      // Fetch context concurrently
      const [relevantQuests, recentEntries] = await Promise.all([
        this.questAgent.findRelevantQuests(allCheckupEntriesWithResponses, userId),
        journalService.getRecentEntries(3, userId)
      ]);

      console.log('‚ú® Found relevant quests for EOD prompt:', relevantQuests.map(q => q.title));
      console.log('‚ú® Found recent daily entries for EOD prompt:', recentEntries.length);

      let prompt = '';

      // --- Historical Daily Entries Context ---
      if (recentEntries && recentEntries.length > 0) {
        prompt += "HISTORICAL CONTEXT (Recent Daily Summaries):\n";
        recentEntries.forEach(entry => {
          const date = new Date(entry.updated_at).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
          prompt += `[${date}]\nEntry: ${entry.user_entry}\nYour Response: ${entry.ai_response}\nYour Analysis: ${entry.ai_analysis || 'N/A'}\n\n`;
        });
      }

      // --- Relevant Quest & Task Context ---
      if (relevantQuests.length > 0) {
        prompt += `\nRELEVANT QUEST AND TASK PROGRESS TODAY:\n`;
        relevantQuests.forEach(quest => {
          prompt += `\nQuest: ${quest.title} (Status: ${quest.status})\n`;
          if (quest.relevance) prompt += `Overall Relevance Today: ${quest.relevance}\n`;
          if (quest.relevantTasks && quest.relevantTasks.length > 0) {
            prompt += 'Key Tasks Discussed Today:\n';
            quest.relevantTasks.forEach(task => prompt += `- ${task.name} (Context: ${task.description}, Relevance: ${task.relevance})\n`);
          }
          const otherTasks = quest.tasks?.filter(task => !quest.relevantTasks?.some(rt => rt.taskId === task.id));
          if (otherTasks && otherTasks.length > 0) {
            prompt += 'Other Tasks to Consider:\n';
            otherTasks.forEach(task => prompt += `- ${task.title} (${task.status})\n`);
          }
          prompt += '\n';
        });
        prompt += 'Consider how today\'s discussions impacted these quests and tasks.\n\n';
      }

      // --- Today's Checkups and Responses ---
      prompt += `TODAY'S FULL CONVERSATION LOG (User Checkups & Your Responses):\n${allCheckupEntriesWithResponses}\n\n`;

      // --- Analysis/Response Instructions ---
      prompt += `YOUR TASK (End of Day Summary & Analysis):
Based on ALL the context (historical, quests, today's full conversation), provide a thoughtful end-of-day summary and analysis. Address the user directly. Consider:
1. Key themes or progress throughout the day.
2. Connections between today's checkups and ongoing quests/tasks.
3. Patterns compared to historical entries.
4. Notable shifts in focus, mood, or goals.
5. Actionable insights or recommendations for tomorrow.
Maintain your characteristic personality.`;

      console.log('‚úÖ End-of-day prompt created (length):', prompt.length);
      return prompt;
    }
  };

================
File: services/journalService.ts
================
import { supabase } from '../lib/supabase';
import { JournalAgent } from './agents/JournalAgent'; // Ensure this imports the updated JournalAgent

// Interface for daily entries from journal_entries table
export interface JournalEntry {
  id: string; // Supabase uses string UUIDs by default
  created_at: string;
  updated_at: string;
  tags: string[] | null; // Allow null from DB
  title: string | null; // Allow null from DB
  user_entry: string | null; // Allow null from DB
  ai_analysis: string | null; // Allow null from DB
  ai_response: string | null; // Allow null from DB
  date?: string; // Client-side convenience property
  clerk_id: string;
}

// Interface for Checkup entries from checkup_entries table
export interface CheckupEntry {
  id: string; // Supabase uses string UUIDs by default
  created_at: string;
  content: string;
  tags: string[] | null; // Allow null from DB
  // Foreign key to journal_entries.id (linking each checkup to its associated daily entry)
  daily_entry_id: string | null; // Should be string if referencing UUID
  ai_checkup_response: string | null; // AI response for individual checkups
  clerk_id: string;
}

// Instantiate the JournalAgent (ensure this uses the updated version)
const journalAgent = new JournalAgent();

export const journalService = {
  /**
   * Gets the latest daily journal entry for a specific date and user.
   * @param date - The date in 'YYYY-MM-DD' format.
   * @param userId - The ID of the user.
   * @returns The journal entry or null if not found.
   */
  async getEntry(date: string, userId: string): Promise<JournalEntry | null> {
    if (!userId) {
      console.error('[journalService] User ID is missing for getEntry.');
      return null;
    }
    console.log('[journalService] getEntry called for date:', date, 'userId:', userId);
    const startOfDay = `${date}T00:00:00Z`; // Use ISO format with Z for UTC
    const endOfDay = `${date}T23:59:59Z`;

    const { data, error } = await supabase
      .from('journal_entries')
      .select('*')
      .eq('clerk_id', userId)
      .gte('created_at', startOfDay)
      .lte('created_at', endOfDay)
      .order('created_at', { ascending: false })
      .limit(1)
      .maybeSingle(); // Use maybeSingle to handle null without error code PGRST116

    if (error) {
      console.error('[journalService] Error fetching journal entry:', error);
      throw new Error('Failed to fetch journal entry');
    }

    if (data) {
      console.log('[journalService] ‚úÖ Found journal entry for date:', date);
      // Add client-side date property
      return { ...data, date };
    } else {
      console.log('[journalService] ‚ÑπÔ∏è No journal entry found for date:', date);
      return null;
    }
  },

  /**
   * Gets all daily journal entries within a date range for a user.
   * @param startDate - The start date in 'YYYY-MM-DD' format.
   * @param endDate - The end date in 'YYYY-MM-DD' format.
   * @param userId - The ID of the user.
   * @returns An array of journal entries.
   */
  async getEntries(startDate: string, endDate: string, userId: string): Promise<CheckupEntry[]> {
    if (!userId) {
      console.error('[journalService] User ID is missing for getEntries.');
      return [];
    }
    console.log('[journalService] getEntries called for range:', startDate, 'to', endDate, 'userId:', userId);
    const startDateTime = `${startDate}T00:00:00Z`; // Use ISO format with Z for UTC
    const endDateTime = `${endDate}T23:59:59Z`;

    const { data, error } = await supabase
      .from('checkup_entries')
      .select('*')
      .eq('clerk_id', userId)
      .gte('created_at', startDateTime)
      .lte('created_at', endDateTime)
      .order('created_at', { ascending: true });

    if (error) {
      console.error('[journalService] Error fetching journal entries:', error);
      throw new Error('Failed to fetch journal entries');
    }

    console.log('[journalService] ‚úÖ Retrieved', data?.length || 0, 'journal entries');
    // Add client-side date property
    return (data || []).map(entry => ({
      ...entry,
      date: new Date(entry.created_at).toISOString().split('T')[0]
    }));
  },

  /**
   * Generates both AI response and analysis for a daily entry content using JournalAgent.
   * @param entryId - The ID of the journal entry (currently unused by agent but kept for potential future use).
   * @param content - The content of the daily entry.
   * @param userId - The ID of the user.
   * @returns An object containing the AI response and analysis.
   */
  async generateAIResponses(entryId: string, content: string, userId: string): Promise<{ response: string; analysis: string }> {
    if (!userId) {
      console.error('[journalService] User ID is missing for generateAIResponses.');
      throw new Error('User ID is required');
    }
    console.log('[journalService] ü§ñ generateAIResponses called for entry ID:', entryId, 'userId:', userId);
    console.log('[journalService] üìù Content length:', content.length);
    try {
      // Calls the updated JournalAgent method
      const result = await journalAgent.processJournalEntry(content, userId);
      console.log('[journalService] ‚úÖ AI responses generated, response length:', result.response.length, 'analysis length:', result.analysis.length);
      return result;
    } catch (err) {
      console.error('[journalService] Error generating AI responses:', err);
      throw new Error('Failed to generate AI responses');
    }
  },

  /**
   * Generates only the AI response for given content using JournalAgent.
   * This also triggers the suggestion analysis event within JournalAgent.
   * @param content - The content (e.g., a checkup entry).
   * @param userId - The ID of the user.
   * @param previousCheckupsContext - Optional context from previous checkups today.
   * @returns The generated AI response string.
   */
  async generateResponse(content: string, userId: string, previousCheckupsContext?: string): Promise<string> {
     if (!userId) {
      console.error('[journalService] User ID is missing for generateResponse.');
      throw new Error('User ID is required');
    }
    console.log('[journalService] ü§ñ generateResponse called, userId:', userId, 'context provided:', !!previousCheckupsContext);
    console.log('[journalService] üìù Content length:', content.length);
    try {
      // Calls the updated JournalAgent method, which emits the suggestion event
      const response = await journalAgent.generateResponse(content, userId, previousCheckupsContext);
      console.log('[journalService] ‚úÖ AI response generated, length:', response.length);
      return response;
    } catch (err) {
      console.error('[journalService] Error generating AI response:', err);
      throw new Error('Failed to generate AI response');
    }
  },

  /**
   * Generates only the AI analysis for given content using JournalAgent.
   * @param content - The content (e.g., a checkup entry or daily summary).
   * @param userId - The ID of the user.
   * @param previousCheckupsContext - Optional context from previous checkups today.
   * @returns The generated AI analysis string.
   */
  async generateAnalysis(content: string, userId: string, previousCheckupsContext?: string): Promise<string> {
    if (!userId) {
      console.error('[journalService] User ID is missing for generateAnalysis.');
      throw new Error('User ID is required');
    }
    console.log('[journalService] ü§ñ generateAnalysis called, userId:', userId, 'context provided:', !!previousCheckupsContext);
    console.log('[journalService] üìù Content length:', content.length);
    try {
      // Calls the updated JournalAgent method
      const analysis = await journalAgent.generateAnalysis(content, userId, previousCheckupsContext);
      console.log('[journalService] ‚úÖ AI analysis generated, length:', analysis.length);
      return analysis;
    } catch (err) {
      console.error('[journalService] Error generating AI analysis:', err);
      throw new Error('Failed to generate AI analysis');
    }
  },

  /**
   * Gets all checkup entries for a specific date and user.
   * @param date - The date in 'YYYY-MM-DD' format.
   * @param userId - The ID of the user.
   * @returns An array of checkup entries.
   */
  async getCheckupEntries(date: string, userId: string): Promise<CheckupEntry[]> {
    if (!userId) {
      console.error('[journalService] User ID is missing for getCheckupEntries.');
      return [];
    }
    console.log('[journalService] getCheckupEntries called for date:', date, 'userId:', userId);
    const startOfDay = `${date}T00:00:00Z`; // Use ISO format with Z for UTC
    const endOfDay = `${date}T23:59:59Z`;

    const { data, error } = await supabase
      .from('checkup_entries')
      .select('*')
      .eq('clerk_id', userId)
      .gte('created_at', startOfDay)
      .lte('created_at', endOfDay)
      .order('created_at', { ascending: true });

    if (error) {
      console.error('[journalService] Error fetching checkup entries:', error);
      throw new Error('Failed to fetch checkup entries');
    }

    console.log('[journalService] ‚úÖ Retrieved', data?.length || 0, 'checkup entries for', date);
    return data || [];
  },

  /**
   * Saves a checkup entry, generates its AI response (triggering suggestion analysis),
   * and stores both in the database.
   * @param date - The date of the checkup in 'YYYY-MM-DD' format.
   * @param content - The user's content for the checkup.
   * @param userId - The ID of the user.
   * @param tags - Optional array of tags.
   * @param aiResponse - Optional pre-generated AI response (e.g., from ChatAgent).
   * @returns The saved checkup entry.
   */
  async saveCheckupEntry(date: string, content: string, userId: string, tags: string[] = [], aiResponse?: string): Promise<CheckupEntry> {
    if (!userId) {
      console.error('[journalService] User ID is required for saveCheckupEntry.');
      throw new Error('User ID is required');
    }
    if (!content || content.trim() === '') {
       console.warn('[journalService] Attempted to save empty checkup entry.');
       throw new Error('Checkup content cannot be empty');
    }
    console.log('[journalService] üíæ saveCheckupEntry called for date:', date, 'userId:', userId);
    console.log('[journalService] üìù Content length:', content.length, 'Tags:', tags, 'AI resp provided:', !!aiResponse);
    try {
      // Fetch today's checkups for context
      console.log('[journalService] üîÑ Fetching existing checkups for context');
      const todaysCheckups = await this.getCheckupEntries(date, userId);

      // Format context
      console.log('[journalService] üîÑ Formatting', todaysCheckups.length, 'checkups as context');
      let previousCheckupsContext = "";
      if (todaysCheckups && todaysCheckups.length > 0) {
        previousCheckupsContext = todaysCheckups
          .map(entry => {
            const entryTime = new Date(entry.created_at).toLocaleTimeString('en-US', {
              hour: '2-digit', minute: '2-digit', hour12: false
            });
            return `[${entryTime}] USER: ${entry.content}\n[${entryTime}] ASSISTANT: ${entry.ai_checkup_response || 'No response recorded'}`;
          })
          .join('\n\n');
      }

      // Generate AI response via JournalAgent IF NOT provided
      // This call to generateResponse will trigger the suggestion analysis event
      let checkupResponse = aiResponse;
      if (!checkupResponse) {
        console.log('[journalService] ü§ñ Generating AI response via JournalAgent (will trigger suggestions)');
        checkupResponse = await this.generateResponse(content, userId, previousCheckupsContext);
      } else {
        console.log('[journalService] ‚ÑπÔ∏è Using provided AI response. Suggestion trigger relies on caller.');
        // IMPORTANT: If aiResponse is provided (e.g., from ChatAgent), the suggestion trigger must happen elsewhere (e.g., ChatAgent calling SuggestionAgent post-session).
      }

      // Prepare data for insertion
      const now = new Date();
      const entryData = {
          created_at: now.toISOString(),
          content: content, // Store raw content, timestamping can be handled by UI or retrieved from created_at
          tags: tags.length > 0 ? tags : null,
          daily_entry_id: null, // Initially unlinked
          ai_checkup_response: checkupResponse,
          clerk_id: userId
      };

      // Insert the checkup
      console.log('[journalService] üíæ Saving checkup entry to database');
      const { data, error } = await supabase
        .from('checkup_entries')
        .insert([entryData])
        .select()
        .single();

      if (error) {
        console.error('[journalService] ‚ùå Database error when saving checkup:', error);
        throw error;
      }

      console.log('[journalService] ‚úÖ Checkup entry saved with ID:', data.id);
      return data;
    } catch (err) {
      console.error('[journalService] Error saving checkup entry:', err);
      // Re-throw the error so the calling function (e.g., in useJournal) can handle it
      throw err;
    }
  },

  /**
   * Gets checkup entries for a date that are not yet linked to a daily entry.
   * @param date - The date in 'YYYY-MM-DD' format.
   * @param userId - The ID of the user.
   * @returns An array of unlinked checkup entries.
   */
  async getUnsavedCheckupEntries(date: string, userId: string): Promise<CheckupEntry[]> {
    if (!userId) {
      console.error('[journalService] User ID is missing for getUnsavedCheckupEntries.');
      return [];
    }
    console.log('[journalService] getUnsavedCheckupEntries called for date:', date, 'userId:', userId);
    const startOfDay = `${date}T00:00:00Z`;
    const endOfDay = `${date}T23:59:59Z`;

    const { data, error } = await supabase
      .from('checkup_entries')
      .select('*')
      .eq('clerk_id', userId)
      .gte('created_at', startOfDay)
      .lte('created_at', endOfDay)
      .is('daily_entry_id', null) // Filter for unlinked entries
      .order('created_at', { ascending: true });

    if (error) {
      console.error('[journalService] Error fetching unsaved checkup entries:', error);
      throw new Error('Failed to fetch unsaved checkup entries');
    }

    console.log('[journalService] ‚úÖ Found', data?.length || 0, 'unsaved checkup entries');
    return data || [];
  },

  /**
   * Creates a daily journal summary entry, potentially saving current text as a final checkup,
   * generates end-of-day AI response/analysis, saves the daily entry, and links checkups.
   * @param date - The date for the daily entry in 'YYYY-MM-DD' format.
   * @param userId - The ID of the user.
   * @param currentText - Optional current text in the editor to be saved as a final checkup.
   * @returns The saved daily journal entry.
   */
  async saveDailyEntry(date: string, userId: string, currentText?: string): Promise<JournalEntry> {
    if (!userId) {
      console.error('[journalService] User ID is required for saveDailyEntry.');
      throw new Error('User ID is required');
    }
    console.log('[journalService] üíæ saveDailyEntry called for date:', date, 'userId:', userId);
    try {
      // Save current text as final checkup if provided
      if (currentText?.trim()) {
        console.log('[journalService] üìù Saving current text as final checkup');
        // This call will also generate a response and trigger suggestion analysis for this final checkup
        await this.saveCheckupEntry(date, currentText.trim(), userId, []);
      }

      // Fetch ALL checkups for the day (now including the potentially just-saved one)
      console.log('[journalService] üîÑ Fetching ALL checkups for the day');
      const allTodaysCheckups = await this.getCheckupEntries(date, userId);

      if (allTodaysCheckups.length === 0) {
         console.warn('[journalService] No checkup entries found for the day. Cannot create daily summary.');
         // Return a placeholder or throw an error depending on desired behavior
         throw new Error('No checkup entries available to create a daily summary.');
      }

      // Format checkups + responses for end-of-day processing
      console.log('[journalService] üîÑ Formatting checkups with responses for daily entry content');
      const formattedContent = allTodaysCheckups
        .map(entry => {
          const entryTime = new Date(entry.created_at).toLocaleTimeString('en-US', {
            hour: '2-digit', minute: '2-digit', hour12: false
          });
          // Ensure content and response are not null before using them
          const userContent = entry.content || '';
          const aiResp = entry.ai_checkup_response || 'No response recorded';
          return `[${entryTime}] USER:\n${userContent}\nASSISTANT:\n${aiResp}`;
        })
        .join('\n\n');

      // Generate end-of-day AI response and analysis via JournalAgent
      console.log('[journalService] ü§ñ Generating end-of-day response & analysis via JournalAgent');
      const { response: dailyResponse, analysis: dailyAnalysis } = await journalAgent.processEndOfDay(formattedContent, userId);

      // Create the daily entry
      const entryTimestamp = new Date().toISOString(); // Use current time for the summary entry
      const dailyEntryData = {
          created_at: entryTimestamp,
          updated_at: entryTimestamp,
          user_entry: formattedContent, // Store the combined checkups+responses
          title: `Daily Summary - ${date}`,
          tags: null, // Or derive tags if needed
          ai_response: dailyResponse,
          ai_analysis: dailyAnalysis,
          clerk_id: userId
      };

      console.log('[journalService] üíæ Creating daily entry in database');
      const { data: savedDailyEntry, error: insertError } = await supabase
        .from('journal_entries')
        .insert([dailyEntryData])
        .select()
        .single();

      if (insertError) {
        console.error('[journalService] ‚ùå Database error creating daily entry:', insertError);
        throw insertError;
      }
      if (!savedDailyEntry) {
          throw new Error('Failed to retrieve saved daily entry data.');
      }

      const dailyEntryId = savedDailyEntry.id; // Get the ID of the newly created daily entry

      // Link all of today's checkups to this new daily entry
      console.log('[journalService] üîÑ Linking', allTodaysCheckups.length, 'checkups to daily entry ID:', dailyEntryId);
      const checkupIdsToLink = allTodaysCheckups.map(c => c.id);

      if (checkupIdsToLink.length > 0) {
        const { error: updateError } = await supabase
          .from('checkup_entries')
          .update({ daily_entry_id: dailyEntryId })
          .eq('clerk_id', userId)
          .in('id', checkupIdsToLink); // Link specifically the checkups we processed

        if (updateError) {
          // Log error but don't necessarily fail the whole operation, maybe retry later?
          console.error('[journalService] Error updating checkup entries with daily entry id:', updateError);
          // Consider adding retry logic or background job for linking failures
        }
      }

      console.log('[journalService] ‚úÖ Daily entry saved (ID:', dailyEntryId, ') and checkups linked');
      return { ...savedDailyEntry, date }; // Return the saved entry with the client-side date

    } catch (err) {
      console.error('[journalService] Error saving daily entry:', err);
      throw err; // Re-throw error
    }
  },

  /**
   * Gets checkup entries associated with a specific daily entry ID.
   * @param dailyEntryId - The ID of the daily journal entry.
   * @param userId - The ID of the user.
   * @returns An array of associated checkup entries.
   */
  async getCheckupsForDailyEntry(dailyEntryId: string, userId: string): Promise<CheckupEntry[]> {
    if (!userId) {
      console.error('[journalService] User ID is missing for getCheckupsForDailyEntry.');
      return [];
    }
    if (!dailyEntryId) {
        console.error('[journalService] Daily Entry ID is missing for getCheckupsForDailyEntry.');
        return [];
    }
    console.log('[journalService] getCheckupsForDailyEntry called for entry ID:', dailyEntryId, 'userId:', userId);
    try {
      const { data, error } = await supabase
        .from('checkup_entries')
        .select('*')
        .eq('clerk_id', userId)
        .eq('daily_entry_id', dailyEntryId) // Match the foreign key
        .order('created_at', { ascending: true });

      if (error) {
        console.error('[journalService] ‚ùå Database error fetching checkups:', error);
        throw error;
      }

      console.log('[journalService] ‚úÖ Retrieved', data?.length || 0, 'checkups for daily entry ID:', dailyEntryId);
      return data || [];
    } catch (err) {
      console.error('[journalService] Error fetching checkups for daily entry:', err);
      throw new Error('Failed to fetch checkups for daily entry');
    }
  },

  /**
   * Gets the most recent daily journal entries for a user.
   * @param limit - The maximum number of entries to retrieve.
   * @param userId - The ID of the user.
   * @returns An array of recent journal entries.
   */
  async getRecentEntries(limit: number, userId: string): Promise<JournalEntry[]> {
    if (!userId) {
      console.error('[journalService] User ID is missing for getRecentEntries.');
      return [];
    }
    console.log('[journalService] getRecentEntries called with limit:', limit, 'userId:', userId);

    try {
      const { data, error } = await supabase
        .from('journal_entries')
        .select('*') // Select all fields
        .eq('clerk_id', userId)
        .order('created_at', { ascending: false })
        .limit(limit);

      if (error) {
        console.error('[journalService] Error fetching recent journal entries:', error);
        throw new Error('Failed to fetch recent journal entries');
      }

      console.log('[journalService] ‚úÖ Retrieved', data?.length || 0, 'recent journal entries');
      // Add client-side date property
      return (data || []).map(entry => ({
          ...entry,
          date: new Date(entry.created_at).toISOString().split('T')[0]
      }));
    } catch (err) {
      console.error('[journalService] Error in getRecentEntries:', err);
      return []; // Return empty array on error
    }
  },
};

================
File: components/journal/JournalPanel.tsx
================
import React, { useCallback, useState, useEffect } from 'react';
import { View, TextInput, TouchableOpacity, Text, ActivityIndicator, ScrollView, Image } from 'react-native';
import { Card } from 'react-native-paper';
import { useRouter } from 'expo-router';
import { ThemedText } from '@/components/ui/ThemedText';
import { MaterialIcons } from '@expo/vector-icons';
import styles from '@/app/styles/global';
import { useJournal } from '@/hooks/useJournal';
import { journalStyles } from '@/app/styles/journalStyles';
import { questStyles } from '@/app/styles/questStyles';
import { journalService, JournalEntry, CheckupEntry } from '@/services/journalService';
import { useTheme } from '@/contexts/ThemeContext';
import { useSupabase } from '@/contexts/SupabaseContext';
import { assertSession } from '@/utils/authGuards';
import { useSuggestions } from '@/contexts/SuggestionContext';

import { JournalEntryInput } from './JournalEntryInput';
import { CheckupItem } from './CheckupItem';
import { AIResponse } from './AIResponse';

export function JournalPanel({ 
  themeColor, 
  textColor, 
  fullColumnMode = false,
  showAnalysis = false,
  userId 
}: { 
  themeColor: string; 
  textColor: string; 
  fullColumnMode?: boolean;
  showAnalysis?: boolean;
  userId: string;
}) {
  const { secondaryColor } = useTheme();
  const router = useRouter();
  const { session } = useSupabase();
  const { 
    currentDate, 
    getEntry, 
    getAiResponses,
    updateLocalEntry,
    refreshEntries,
    goToPreviousDay, 
    goToNextDay
  } = useJournal();
  const { analyzeJournalEntry } = useSuggestions();
  
  const [localLoading, setLocalLoading] = useState(false);
  const [aiGenerating, setAiGenerating] = useState(false);
  const [localError, setLocalError] = useState<string | null>(null);
  const [localEntry, setLocalEntry] = useState<string>('');
  const [originalEntry, setOriginalEntry] = useState<string>('');
  const [localTags, setLocalTags] = useState<string>('');
  const [aiResponse, setAiResponse] = useState<string | null>(null);
  const [aiAnalysis, setAiAnalysis] = useState<string | null>(null);
  const [dailyEntry, setDailyEntry] = useState<JournalEntry | null>(null);
  const [checkups, setCheckups] = useState<CheckupEntry[]>([]);
  const [hasDailyEntry, setHasDailyEntry] = useState(false);
  const [expandedCheckupId, setExpandedCheckupId] = useState<string | null>(null);

  {/* Add ownership verification */}
  const verifyCurrentUser = React.useMemo(() => {
    if (!session?.user?.id || !userId) return false;
    return session.user.id === userId;
  }, [session?.user?.id, userId]);

  {/* Add guard for unauthorized access */}
  if (!verifyCurrentUser) {
    return (
      <Card style={[styles.taskCard, { padding: 15 }]}>
        <ThemedText style={{ color: '#666', textAlign: 'center' }}>
          Unauthorized access
        </ThemedText>
      </Card>
    );
  }

  {/* Format date display */}
  const formattedDate = currentDate.toLocaleDateString('en-US', { 
    weekday: 'long', 
    month: 'long', 
    day: 'numeric' 
  });

  // Load current entries whenever date changes or after refresh
  useEffect(() => {
    const loadEntries = async () => {
      if (!verifyCurrentUser) return;
      assertSession(session); // This will throw if session is null
      
      const dateStr = currentDate.toISOString().split('T')[0];
      
      // Get daily entry first with clerk_id
      const dailyEntryForDate = await journalService.getEntry(dateStr, session.user.id);
      setDailyEntry(dailyEntryForDate);
      setHasDailyEntry(!!dailyEntryForDate);

      // Get today's checkups with clerk_id
      const todaysCheckups = await journalService.getCheckupEntries(dateStr, session.user.id);
      setCheckups(todaysCheckups);

      // Set current entry and responses
      setLocalEntry(''); // Start with empty entry for new checkup
      setOriginalEntry('');
      setLocalTags('');
      
      // If there's a daily entry response, use that
      if (dailyEntryForDate?.ai_response) {
        setAiResponse(dailyEntryForDate.ai_response);
      } else if (todaysCheckups.length > 0) {
        // Otherwise, if there are checkups today, use the AI response from the latest one
        const latestCheckup = todaysCheckups[todaysCheckups.length - 1];
        setAiResponse(latestCheckup.ai_checkup_response || null);
      } else {
        // Fallback to the response from useJournal if no checkups or daily entry
        const aiResponses = getAiResponses(currentDate);
        setAiResponse(aiResponses.response);
      }
      
      // Analysis should always come from daily entries
      if (dailyEntryForDate?.ai_analysis) {
        setAiAnalysis(dailyEntryForDate.ai_analysis);
      } else {
        const aiResponses = getAiResponses(currentDate);
        setAiAnalysis(aiResponses.analysis);
      }
    };

    loadEntries();
  }, [currentDate, getAiResponses, session?.user?.id, verifyCurrentUser]);

  {/* Refresh entries initially to make sure we have the latest data */}
  useEffect(() => {
    if (!session?.user?.id) return;
    
    console.log('JournalPanel: Initial load, fetching entries...');
    refreshEntries().then(() => {
      {/* After refreshing, get the entry again to ensure we have the latest data */}
      const entry = getEntry(currentDate);
      console.log('JournalPanel: After refresh, entry length:', entry?.content?.length || 0);
      setLocalEntry(entry?.content || '');
      setOriginalEntry(entry?.content || '');
    });
  }, [session?.user?.id]); // Add session.user.id as dependency
  
  useEffect(() => {
    {/* Check if getAiAnalysis is a function */}
    if (typeof getAiResponses !== 'function') {
      console.error('JournalPanel: getAiResponses is not a function');
    }
  }, [getAiResponses]);

  {/* Generate a bright accent color for cyberpunk text effect */}
  const getBrightAccent = (baseColor: string) => {
    // For dark colors, create a bright neon variant
    const hex = baseColor.replace('#', '');
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    
    // If already bright, make it even brighter
    if (r + g + b > 500) {
      return '#FFFFFF';
    }
    
    // Otherwise create a bright neon version
    const brightR = Math.min(255, r + 100);
    const brightG = Math.min(255, g + 100);
    const brightB = Math.min(255, b + 100);
    
    return `#${brightR.toString(16).padStart(2, '0')}${
      brightG.toString(16).padStart(2, '0')}${
      brightB.toString(16).padStart(2, '0')}`;
  };
  
  const brightAccent = getBrightAccent(themeColor);
  const amberColor = '#FFB74D'; {/* Define amber color for the Save Checkup button */}

  {/* Handle entry text changes - remove immediate update */}
  const handleEntryChange = useCallback((text: string) => {
    setLocalEntry(text);
    {/* Removed the immediate updateLocalEntry call */}
  }, []);

  {/* Handle tags changes */}
  const handleTagsChange = useCallback((text: string) => {
    setLocalTags(text);
  }, []);

  {/* Toggle checkup expansion */}
  const toggleCheckupExpansion = useCallback((id: string) => {
    setExpandedCheckupId(prevId => prevId === id ? null : id);
  }, []);

  {/* Modified save handler to update local entries before saving and generate AI response */}
  const handleSaveEntry = useCallback(async () => {
    if (!localEntry) return;
    assertSession(session); // This will throw if session is null
    
    try {
      setLocalLoading(true);
      setAiGenerating(true);
      setLocalError(null);
      
      const processedTags = localTags
        .split(',')
        .map(tag => tag.trim())
        .filter(tag => tag.length > 0);
      
      updateLocalEntry(currentDate, localEntry);
      
      // Use saveCheckupEntry with clerk_id
      const dateStr = currentDate.toISOString().split('T')[0];
      await journalService.saveCheckupEntry(dateStr, localEntry, session.user.id, processedTags);
      
      await refreshEntries();
      
      // Get updated entries after saving
      const todaysCheckups = await journalService.getCheckupEntries(dateStr, session.user.id);
      setCheckups(todaysCheckups);

      const aiResponses = getAiResponses(currentDate);
      setAiResponse(aiResponses.response);
      setAiAnalysis(aiResponses.analysis);
      
      // Update the original entry to the new version
      setOriginalEntry(localEntry);
      
    } catch (err: any) {
      console.error('JournalPanel: Error in handleSaveEntry:', err);
      setLocalError(err?.message || 'Failed to update journal entry');
    } finally {
      setLocalLoading(false);
      setAiGenerating(false);
    }
  }, [currentDate, localEntry, localTags, updateLocalEntry, refreshEntries, getAiResponses, session]);

  {/* Save a checkup entry and analyze for suggestions */}
  const handleSaveCheckup = useCallback(async () => {
    if (!localEntry) return;
    assertSession(session); // This will throw if session is null
    
    try {
      setLocalLoading(true);
      setAiGenerating(true);
      setLocalError(null);
      
      const processedTags = localTags
        .split(',')
        .map(tag => tag.trim())
        .filter(tag => tag.length > 0);
      
      // Save to checkup_entries table with null daily_entry_id
      const dateStr = currentDate.toISOString().split('T')[0];
      const newCheckup = await journalService.saveCheckupEntry(
        dateStr, 
        localEntry, 
        session.user.id,
        processedTags
      );
      
      // After successful save, analyze the checkup content for suggestions
      await analyzeJournalEntry(localEntry, session.user.id);
      
      // Refresh entries
      await refreshEntries();

      // Get updated entries and set them
      const todaysCheckups = await journalService.getCheckupEntries(dateStr, session.user.id);
      setCheckups(todaysCheckups);

      // ONLY set the AI response from the newly created checkup, clean it first
      let cleanResponse = newCheckup.ai_checkup_response || null;
      if (cleanResponse) {
        cleanResponse = cleanResponse.replace(/^["']|["']$/g, ''); // Remove surrounding quotes
        cleanResponse = cleanResponse.replace(/^Johnny Silverhand's response:\s*/i, ''); // Remove prefix
      }
      setAiResponse(cleanResponse);
      
      // Analysis should stay as it was or null
      setAiAnalysis(aiAnalysis);

      // Clear the form for the next checkup
      setLocalEntry('');
      setLocalTags('');
      
    } catch (err: any) {
      console.error('JournalPanel: Error in handleSaveCheckup:', err);
      setLocalError(err?.message || 'Failed to save checkup entry');
    } finally {
      setLocalLoading(false);
      setAiGenerating(false);
    }
  }, [currentDate, localEntry, localTags, refreshEntries, getAiResponses, aiAnalysis, session, analyzeJournalEntry]);

  {/* Create a daily entry and link all unlinked checkups via foreign key */}
  const handleDailyEntry = useCallback(async () => {
    assertSession(session); // This will throw if session is null
    
    try {
      setLocalLoading(true);
      setAiGenerating(true);
      setLocalError(null);
      
      const dateStr = currentDate.toISOString().split('T')[0];
      // Create daily entry before navigation to ensure it exists
      const newDailyEntry = await journalService.saveDailyEntry(dateStr, session.user.id);
      
      // Only navigate after successful creation
      router.push('/daily-review');
      
      // Refresh entries
      await refreshEntries();
      
      // Update daily entry status
      setHasDailyEntry(true);
      
      const aiResponses = getAiResponses(currentDate);
      let cleanResponse = aiResponses.response;
      let cleanAnalysis = aiResponses.analysis;

      // Clean response and analysis
      if (cleanResponse) {
        cleanResponse = cleanResponse.replace(/^["']|["']$/g, ''); // Remove surrounding quotes
        cleanResponse = cleanResponse.replace(/^Johnny Silverhands response:\s*/i, ''); // Remove prefix
      }
      if (cleanAnalysis) {
        cleanAnalysis = cleanAnalysis.replace(/^["']|["']$/g, ''); // Remove surrounding quotes
        cleanAnalysis = cleanAnalysis.replace(/^Johnny Silverhand's response:\s*/i, ''); // Remove prefix
      }
      
      setAiResponse(cleanResponse);
      setAiAnalysis(cleanAnalysis);
      
    } catch (err: any) {
      console.error('JournalPanel: Error in handleDailyEntry:', err);
      setLocalError(err?.message || 'Failed to generate daily entry');
    } finally {
      setLocalLoading(false);
      setAiGenerating(false);
    }
  }, [currentDate, refreshEntries, router, getAiResponses, session]);

  const loading = localLoading;
  const error = localError;

  return (
    <Card style={[styles.taskCard, { 
      overflow: 'hidden', 
      borderColor: themeColor, 
      borderWidth: 1, 
      borderLeftWidth: 3, 
      height: fullColumnMode ? 'auto' : 'auto',
      flex: fullColumnMode ? 1 : undefined, // Changed 'auto' to undefined
      marginTop: fullColumnMode ? 0 : 20,
      marginBottom: fullColumnMode ? -5 : 20,
    }]}>
      {/* Background with subtle gradient effect */}
      <View style={{ 
        position: 'absolute', 
        width: '100%', 
        height: '100%',
        backgroundColor: '#151515',
        borderLeftColor: themeColor,
        borderLeftWidth: 3,
      }} />
    
      <View style={[journalStyles.journalHeader, { 
        padding: 15, 
        borderBottomWidth: 1, 
        borderBottomColor: 'rgba(255, 255, 255, 0.1)', 
        alignItems: 'center', // Center items vertically
        justifyContent: 'space-between', // Align items to the right
        flexDirection: 'row', // Ensure row direction for header, starting from the right
        width: '100%', // Ensure full width
        gap: 10 // Add consistent space between items
      }]}>
        
        <TouchableOpacity 
            style={[journalStyles.updateButton, { 
              backgroundColor: 'rgba(30, 30, 30, 0.9)',
              borderWidth: 1,
              borderColor: themeColor,
              padding: 10,
              shadowColor: themeColor,
              shadowOffset: { width: 0, height: 0 },
              shadowOpacity: 0.5,
              shadowRadius: 5,
              elevation: 5,
              alignItems: 'center',
              justifyContent: 'center',
              marginHorizontal: 10 // Add margin for consistent spacing
            }]}
            onPress={() => router.push('/journal')}
          >
            <Text style={{ 
              color: brightAccent, 
              fontSize: 22,
              textShadowColor: themeColor,
              textShadowOffset: { width: 0, height: 0 },
              textShadowRadius: 4
            }}>
              üìì
            </Text>
          </TouchableOpacity>
        <View style={{ flexDirection: 'row', alignItems: 'center', flex: 1 }}>
        <TouchableOpacity 
          style={{ 
            padding: 8, 
            borderRadius: 4, 
            backgroundColor: 'rgba(20, 20, 20, 0.7)',
            marginHorizontal: 10 // Add margin for consistent spacing
          }}
          onPress={goToPreviousDay}
        >
          <MaterialIcons name="chevron-left" size={24} color={brightAccent} />
        </TouchableOpacity>
        <View style={{ flexDirection: 'column', alignItems: 'center', flex: 1 }}>
          <ThemedText style={[questStyles.mainQuestTitle, { 
            fontSize: 20,
            color: '#FFFFFF',
            textShadowColor: themeColor,
            textShadowOffset: { width: 1, height: 1 },
            textShadowRadius: 5,
            textAlign: 'center',
          }]}>
            {showAnalysis ? 'ANALYSIS' : "TODAY'S JOURNAL"}
          </ThemedText>
          <ThemedText style={{ 
            fontSize: 12,
            color: '#AAA',
            marginTop: 0
          }}>
            {currentDate.toLocaleDateString('pt-pt', { 
              day: '2-digit',
              month: '2-digit'
            })}
          </ThemedText>
          
        </View>
        
        <TouchableOpacity 
          onPress={goToNextDay}
          style={{ 
            padding: 8, 
            borderRadius: 4, 
            backgroundColor: 'rgba(20, 20, 20, 0.7)',
            marginHorizontal: 10 // Add margin for consistent spacing
          }}
        >
          <MaterialIcons name="chevron-right" size={24} color={brightAccent} />
        </TouchableOpacity>
        </View>
        <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', flex: 1 }}>
          
          <View style={{ flexDirection: 'row', alignItems: 'center', gap: 10 }}>
            <TouchableOpacity 
              style={[journalStyles.updateButton, { 
                backgroundColor: 'rgba(30, 30, 30, 0.9)',
                borderWidth: 1,
                borderColor: amberColor,
                padding: 10,
                shadowColor: amberColor,
                shadowOffset: { width: 0, height: 0 },
                shadowOpacity: 0.5,
                shadowRadius: 5,
                elevation: 5,
                alignItems: 'center',
                justifyContent: 'center',
                opacity: !localEntry.trim() || loading ? 0.5 : 1,
                marginHorizontal: 10 // Add margin for consistent spacing
              }]}
              onPress={handleSaveCheckup}
              disabled={loading || !localEntry.trim()}
            >
              {loading ? (
                <ActivityIndicator size="small" color={amberColor} />
              ) : (
                <Text style={{ 
                  color: brightAccent, 
                  fontSize: 22,
                  textShadowColor: amberColor,
                  textShadowOffset: { width: 0, height: 0 },
                  textShadowRadius: 4
                }}>
                  üíæ
                </Text>
              )}
            </TouchableOpacity>
            <TouchableOpacity 
              style={[journalStyles.updateButton, { 
                backgroundColor: 'rgba(30, 30, 30, 0.9)',
                borderWidth: 1,
                borderColor: secondaryColor,
                padding: 10,
                shadowColor: secondaryColor,
                shadowOffset: { width: 0, height: 0 },
                shadowOpacity: 0.5,
                shadowRadius: 5,
                elevation: 5,
                alignItems: 'center',
                justifyContent: 'center',
                opacity: hasDailyEntry || checkups.length === 0 || loading ? 0.5 : 1,
                marginHorizontal: 10 // Add margin for consistent spacing
              }]}
              onPress={handleDailyEntry}
              disabled={loading || hasDailyEntry || checkups.length === 0}
            >
              <Text style={{ 
                color: brightAccent, 
                fontSize: 22,
                textShadowColor: secondaryColor,
                textShadowOffset: { width: 0, height: 0 },
                textShadowRadius: 4
              }}>
                üõå
              </Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
      
      <View style={{ 
        flex: 1, 
        padding: 15, 
        flexDirection: 'column' 
      }}>
       
        
        {error ? (
          <View style={{ 
            margin: 15,
            padding: 10, 
            backgroundColor: 'rgba(200, 0, 0, 0.1)', 
            borderRadius: 5,
            borderLeftWidth: 2,
            borderLeftColor: '#D81159',
          }}>
            <ThemedText style={[styles.errorText, { color: '#FF6B6B' }]}>
              {error}. <Text style={{textDecorationLine: 'underline', color: '#FF6B6B'}} onPress={() => { setLocalError(null); refreshEntries(); }}>Try again</Text>
            </ThemedText>
          </View>
        ) : (
          <View style={{ 
            flex: 1, 
            flexDirection: 'column', 
            gap: 10,
            height: '100%',
          }}>
            {/* Today's checkups list */}
            {!showAnalysis && checkups.length > 0 && (
              <View style={{ maxHeight: 250 }}>
                <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 8 }}>
                  <MaterialIcons name="history" size={16} color={themeColor} style={{ marginRight: 6 }} />
                  <Text style={{ color: themeColor, fontWeight: 'bold', fontSize: 14 }}>
                    TODAY'S <Text style=
                            {{ color: brightAccent, fontWeight: 'bold', fontSize: 14
                               }}>
              {checkups.length}</Text> CHECKUP{checkups.length !== 1 ? 'S' : ''}
                  </Text>
                </View>
                <ScrollView style={{ maxHeight: 210 }}>
                  {checkups.map((checkup) => (
                    <CheckupItem 
                      key={checkup.id}
                      checkup={checkup}
                      themeColor={themeColor}
                      onPress={() => toggleCheckupExpansion(checkup.id)}
                      isExpanded={expandedCheckupId === checkup.id}
                      secondaryColor={secondaryColor}
                    />
                  ))}
                </ScrollView>
              </View>
            )}

            {/* Each section gets appropriate vertical space */}
            {!showAnalysis && (
              <View style={{ flex: 1 }}>
                <JournalEntryInput
                  value={localEntry}
                  tagsValue={localTags}
                  onChangeText={handleEntryChange}
                  onChangeTags={handleTagsChange}
                  loading={loading}
                  fullColumnMode={fullColumnMode}
                  themeColor={themeColor}
                />
              </View>
            )}
            
            <View style={{ flex: 1 }}>
              <AIResponse
                response={aiResponse}
                loading={loading}
                aiGenerating={aiGenerating} // Pass the new AI generation state
                fullColumnMode={fullColumnMode}
                secondaryColor={secondaryColor}
                entryUserId={session?.user?.id}
              />
            </View>
          </View>
        )}
      </View>
    </Card>
  );
}

================
File: hooks/useChatData.ts
================
import { useState, useCallback, useEffect, useRef } from 'react';
import { ChatMessage } from '@/app/types';
import { useTheme } from '@/contexts/ThemeContext';
import { ChatAgent } from '@/services/agents/ChatAgent';
import { supabase } from '@/lib/supabase';
import { useSupabase } from '@/contexts/SupabaseContext';
import { updateTask } from '@/services/tasksService'; // Import updateTask


import AsyncStorage from '@react-native-async-storage/async-storage';

const INACTIVITY_TIMEOUT = 5 * 60 * 1000;
const JOHNNY_RESPONSE_DELAY = 2000;
const MESSAGE_STAGGER_DELAY = 1000;
const LOCAL_STORAGE_KEY = 'chat_messages_local'; // key for local storage

// New database access functions for ChatAgent
export async function getCurrentMessagesFromDB(userId: string) {
  if (!userId) {
    throw new Error('User ID is required to fetch current messages');
  }
  
  const { data, error } = await supabase
    .from('chat_messages')
    .select('*')
    .is('chat_session_id', null)
    .eq('clerk_id', userId)
    .order('created_at', { ascending: true });
  
  if (error) {
    throw error;
  }
  
  return data || [];
}


export async function createChatSession(summary: string, tags: string[], userId: string) {
  if (!userId) {
    throw new Error('User ID is required to create a chat session');
  }
  
  const { data, error } = await supabase
    .from('chat_sessions')
    .insert([{ 
      summary,
      tags,
      clerk_id: userId
    }])
    .select('id')
    .single();
  
  if (error) {
    throw error;
  }
  
  return data;
}

export async function updateMessagesWithSessionId(messageIds: any[], sessionId: string, userId: string) {
  if (!userId || !sessionId || !messageIds || messageIds.length === 0) {
    throw new Error('User ID, session ID, and message IDs are required to update messages');
  }
  
  const { error } = await supabase
    .from('chat_messages')
    .update({ chat_session_id: sessionId })
    .in('id', messageIds)
    .eq('clerk_id', userId);
  
  if (error) {
    throw error;
  }
  
  return true;
}

export function useChatData() {
  const { themeColor } = useTheme();
  const { session } = useSupabase();
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isTyping, setIsTyping] = useState(false);
  const [currentSessionId, setCurrentSessionId] = useState<string | null>(null);
  const [sessionEnded, setSessionEnded] = useState(false);
  const [checkupCreated, setCheckupCreated] = useState(false);
  const [error, setError] = useState<string | null>(null); // Add error state for auth issues
  const chatAgent = new ChatAgent();
  const inactivityTimerRef = useRef<NodeJS.Timeout | null>(null);
  const currentSessionMessagesRef = useRef<ChatMessage[]>([]);
  const pendingMessagesRef = useRef<ChatMessage[]>([]);
  const johnnyResponseTimerRef = useRef<NodeJS.Timeout | null>(null);
  const lastMessageRef = useRef<string>('');

  // Keep track of current session messages
  const getCurrentSessionMessages = useCallback(() => {
    return messages.filter(msg => !msg.chat_session_id);
  }, [messages]);

  // Keep track of session messages
  useEffect(() => {
    currentSessionMessagesRef.current = getCurrentSessionMessages();
  }, [messages, getCurrentSessionMessages]);

  // Reset inactivity timer with stronger auth check
  const resetInactivityTimer = useCallback(() => {
    // Clear any existing error
    setError(null);
    
    // Strong guard clause for authentication
    if (!session?.user?.id) {
      console.error('Cannot reset inactivity timer: No user ID');
      setError('Authentication required');
      return;
    }

    if (inactivityTimerRef.current) {
      clearTimeout(inactivityTimerRef.current);
    }
    setSessionEnded(false);
    setCheckupCreated(false);

    inactivityTimerRef.current = setTimeout(async () => {
      const userId = session.user.id; // Cache userId for use in closure
      if (!userId) {
        console.error('User ID missing in timer execution');
        return;
      }
      
      const sessionMessages = currentSessionMessagesRef.current;
      if (sessionMessages.length > 0) {
        try {
          // Verify all messages belong to current user before proceeding
          const allMessagesOwnedByUser = sessionMessages.every(msg => 
            !msg.clerk_id || msg.clerk_id === userId);
            
          if (!allMessagesOwnedByUser) {
            console.error('Security issue: Found messages not owned by current user');
            return;
          }
          
          // All messages should have the same clerk_id
          const sessionMessagesWithUserId = sessionMessages.map(msg => ({
            ...msg,
            clerk_id: userId
          }));
          
          const sessionId = await chatAgent.summarizeAndStoreSession(sessionMessagesWithUserId);
          
          // Update local messages with new session ID
          setMessages(prev => prev.map(msg => 
            sessionMessages.some(sMsg => sMsg.id === msg.id) 
              ? { ...msg, chat_session_id: sessionId }
              : msg
          ));
          setCurrentSessionId(null);
          setSessionEnded(true);
          setCheckupCreated(true); // Mark that we've created a checkup
        } catch (error) {
          console.error('Error summarizing session:', error);
        }
      }
    }, INACTIVITY_TIMEOUT);
  }, [session?.user?.id]);

  // End session with stronger auth check
  const endSession = useCallback(async () => {
    // Strong guard clause for authentication
    if (!session?.user?.id) {
      console.error('Cannot end session: No user ID');
      setError('Authentication required to end session');
      return;
    }

    const userId = session.user.id;
    const sessionMessages = currentSessionMessagesRef.current;
    
    // Set session ended state immediately
    setSessionEnded(true);
    
    // If no messages, just end without creating a record
    if (sessionMessages.length === 0) {
      return;
    }
    
    try {
      // Verify all messages belong to current user
      const allMessagesOwnedByUser = sessionMessages.every(msg => 
        !msg.clerk_id || msg.clerk_id === userId);
        
      if (!allMessagesOwnedByUser) {
        console.error('Security issue: Found messages not owned by current user');
        setError('Cannot end session: Message ownership verification failed');
        return;
      }
      
      // Ensure all messages have clerk_id
      const sessionMessagesWithUserId = sessionMessages.map(msg => ({
        ...msg,
        clerk_id: userId
      }));
      
      const sessionId = await chatAgent.summarizeAndStoreSession(sessionMessagesWithUserId);
      
      // Update local messages with new session ID
      setMessages(prev => prev.map(msg => 
        sessionMessages.some(sMsg => sMsg.id === msg.id) 
          ? { ...msg, chat_session_id: sessionId }
          : msg
      ));
      setCurrentSessionId(null);
      setCheckupCreated(true); // Mark that we've created a checkup
    } catch (error) {
      console.error('Error summarizing session:', error);
      setError('Failed to end session: ' + (error instanceof Error ? error.message : 'Unknown error'));
    }
  }, [session?.user?.id]);

  // Remove real-time subscription useEffect block completely
  useEffect(() => {
    // Instead load messages from DB and local storage once
    setMessages([]);
    if (!session?.user?.id) {
      console.log('No active user session, skipping message loading');
      return;
    }
    const userId = session.user.id;
    
    const loadLocalMessages = async () => {
      try {
        const key = `${LOCAL_STORAGE_KEY}_${userId}`;
        const stored = await AsyncStorage.getItem(key);
        if (stored) {
          const parsed: ChatMessage[] = JSON.parse(stored);
          const valid = parsed.filter(msg => !msg.chat_session_id && msg.clerk_id === userId);
          setMessages(valid);
        }
      } catch (err) {
        console.error('Error loading messages from local storage:', err);
      }
    };
    
    const loadDatabaseMessages = async () => {
      try {
        const { data, error } = await supabase
          .from('chat_messages')
          .select('*')
          .eq('clerk_id', userId)
          .is('chat_session_id', null)
          .order('created_at', { ascending: true });
        if (error) {
          console.error('Error loading messages from database:', error);
          return;
        }
        const valid = data?.filter(msg => msg.clerk_id === userId) || [];
        setMessages(prev => {
          const map = new Map(prev.map(msg => [String(msg.id), msg]));
          valid.forEach(msg => map.set(String(msg.id), msg));
          return Array.from(map.values()).sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());
        });
      } catch (err) {
        console.error('Exception loading messages from DB:', err);
      }
    };
    
    loadLocalMessages().then(loadDatabaseMessages);
  }, [resetInactivityTimer, session?.user?.id]);

  // Save local messages whenever they change
  useEffect(() => {
    const saveLocal = async () => {
      if (!session?.user?.id) return;
      try {
        const key = `${LOCAL_STORAGE_KEY}_${session.user.id}`;
        await AsyncStorage.setItem(key, JSON.stringify(getCurrentSessionMessages()));
      } catch (err) {
        console.error('Error saving messages to local storage:', err);
      }
    };
    saveLocal();
  }, [messages, getCurrentSessionMessages, session?.user?.id]);

  // Add helper: sync unsynced messages to DB
  const syncMessages = useCallback(async () => {
    if (!session?.user?.id) return;
    const userId = session.user.id;
    try {
      // Read from local storage
      const key = `${LOCAL_STORAGE_KEY}_${userId}`;
      const stored = await AsyncStorage.getItem(key);
      if (!stored) return;
      const localMessages: ChatMessage[] = JSON.parse(stored);
      // For example, assume messages with string id starting with "client" are unsynced
      const unsynced = localMessages.filter(msg => String(msg.id).startsWith('client'));
      for (const msg of unsynced) {
        try {
          const { data, error } = await supabase
            .from('chat_messages')
            .insert([msg])
            .select()
            .single();
          if (error) throw error;
          // Update local state: replace client id with server id
          setMessages(prev => prev.map(m => (m.id === msg.id ? { ...data, id: data.id } : m)));
        } catch (syncError) {
          console.error('Error syncing message:', syncError);
        }
      }
    } catch (err) {
      console.error('Error in syncMessages:', err);
    }
  }, [session?.user?.id]);

  // Handle user typing
  const handleTyping = useCallback((text: string) => {
    // Clear Johnny's response timer if user is typing
    if (johnnyResponseTimerRef.current) {
      clearTimeout(johnnyResponseTimerRef.current);
    }
    // Update the last message reference
    lastMessageRef.current = text;
  }, []);

  // Modify sendMessage to only update local storage & state immediately for AI responses
  const sendMessage = useCallback(async (messageText: string, userId?: string) => {
    // Clear any existing errors first
    setError(null);
    
    // Strong auth check - prefer explicit userId parameter, fallback to session
    const authenticatedUserId = userId || session?.user?.id;
    
    if (!messageText.trim() || !authenticatedUserId) {
      const errorMsg = !authenticatedUserId 
        ? 'Authentication required to send messages'
        : 'Message cannot be empty';
        
      console.error(`Cannot send message: ${errorMsg}`);
      setError(errorMsg);
      return;
    }
    
    // Use a client-generated numeric id (negative) for optimistic update
    const clientUserId = -Date.now();
    const userMessage: ChatMessage = {
      id: clientUserId,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      is_user: true,
      message: messageText.trim(),
      chat_session_id: currentSessionId || undefined,
      clerk_id: authenticatedUserId
    };

    // OPTIMISTIC UPDATE: Add message to local state first for immediate UI update
    setMessages(prev => [...prev, userMessage]);
    
    // Add to pending messages for AI response
    pendingMessagesRef.current.push(userMessage);
    
  
    // Instead of awaiting DB insert immediately, let the sync function handle it later
    // (Optional: you can trigger syncMessages() after a delay if desired.)

    // Clear any existing timer
    if (johnnyResponseTimerRef.current) {
      clearTimeout(johnnyResponseTimerRef.current);
    }

    // Set new timer for Johnny's response
    johnnyResponseTimerRef.current = setTimeout(async () => {
      setIsTyping(true);
      try {
        // Get all pending messages and ensure they have clerk_id
        const pendingMessages = [...pendingMessagesRef.current].map(msg => ({
          ...msg,
          clerk_id: authenticatedUserId
        }));
        
        const combinedMessage = pendingMessages
          .map(msg => msg.message)
          .join('\n');

        // Clear pending messages
        pendingMessagesRef.current = [];

        // Pass userId explicitly to generateChatResponse
        const responseMessages = await chatAgent.generateChatResponse(combinedMessage, authenticatedUserId);
        
        // Process each message with a delay between them
        for (let i = 0; i < responseMessages.length; i++) {
          const sendAIMessage = async () => {
            const message = responseMessages[i];
            
            // Use a client-generated numeric id (negative) for AI message
            const clientAiId = -(Date.now() + i);
            const aiMessage: ChatMessage = {
              id: clientAiId,
              created_at: new Date().toISOString(),
              updated_at: new Date().toISOString(),
              is_user: false,
              message: message,
              chat_session_id: currentSessionId || undefined,
              clerk_id: authenticatedUserId // Explicit user ID assignment
            };
            
            // OPTIMISTIC UPDATE: Add AI message to local state immediately
            setMessages(prev => [...prev, aiMessage]);
            
            // Also let syncMessages() handle sending to DB later.
            if (i === responseMessages.length - 1) {
              setIsTyping(false);
            }
          };
          
          setTimeout(sendAIMessage, i * MESSAGE_STAGGER_DELAY);
        }

        resetInactivityTimer();
      } catch (error) {
        console.error('Error in Johnny\'s response:', error);
        
        // Handle error with proper clerk_id
        const clientErrorId = -Date.now();
        const errorMessage: ChatMessage = {
          id: clientErrorId,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
          is_user: false,
          message: "Damn netrunners must be messing with our connection. Try again in a bit.",
          chat_session_id: currentSessionId || undefined,
          clerk_id: authenticatedUserId // Explicit user ID assignment
        };

        // OPTIMISTIC UPDATE: Add error message to local state
        setMessages(prev => [...prev, errorMessage]);

        setIsTyping(false);
      }
    }, JOHNNY_RESPONSE_DELAY);

  }, [currentSessionId, resetInactivityTimer, session?.user?.id, getCurrentSessionMessages]);

  // Add a new function to delete current session messages
  const deleteCurrentMessages = useCallback(async () => {
    // Strong guard clause for authentication
    if (!session?.user?.id) {
      console.error('Cannot delete messages: No user ID');
      setError('Authentication required to delete messages');
      return;
    }

    const userId = session.user.id;
    
    try {
      // Clear local storage for current session
      const key = `${LOCAL_STORAGE_KEY}_${userId}`;
      await AsyncStorage.removeItem(key); // Use removeItem to clear the local storage
      await AsyncStorage.setItem(key, ''); // Use setItem to reset the local storage
      // Update state to remove current session messages
      setMessages(prev => prev.filter(msg => msg.chat_session_id !== null));
      
      console.log('Successfully deleted current chat messages');
      
      // End the session without creating a record
      setSessionEnded(true);
    } catch (error) {
      console.error('Error deleting current messages:', error);
      setError('Failed to delete messages: ' + (error instanceof Error ? error.message : 'Unknown error'));
    }
  }, [session?.user?.id]);

  // Cleanup timers on unmount
  useEffect(() => {
    return () => {
      if (johnnyResponseTimerRef.current) {
        clearTimeout(johnnyResponseTimerRef.current);
      }
      if (inactivityTimerRef.current) {
        clearTimeout(inactivityTimerRef.current);
      }
    };
  }, []);

  return {
    messages: getCurrentSessionMessages(), // Only return current session messages
    sendMessage,
    handleTyping,
    endSession,
    isTyping,
    sessionEnded,
    checkupCreated,
    error, // Expose error state for UI feedback
    authenticated: !!session?.user?.id, // Add authentication status
    syncMessages, // Expose sync function so you can trigger it externally if needed
    deleteCurrentMessages // Expose the new function
  };
}

================
File: services/agents/ChatAgent.ts
================
// File: services/agents/ChatAgent.ts
import OpenAI from 'openai';
import { ChatCompletionMessageParam, ChatCompletion } from 'openai/resources/chat/completions';
import { QuestAgent } from './QuestAgent';
import { SuggestionAgent, ConversationData, TaskStatusChangeResult } from './SuggestionAgent';
import * as chatDataUtils from '@/hooks/useChatData';
import { PersonalityType, getPersonality } from './PersonalityPrompts';
import { personalityService } from '../personalityService';
import { updateTask, fetchActiveTasks } from '../tasksService';
// <<< FIX: Use named import for the journalService object
import { journalService } from '../journalService';
// <<< FIX: Also import interfaces needed
import { JournalEntry, CheckupEntry } from '../journalService';
import { ChatMessage, Quest, Task } from '@/app/types';

// Helper function to format date
const formatDate = (date: Date): string => {
    return date.toISOString().split('T')[0];
};


export class ChatAgent {
  // --------- Properties ---------
  private openai: OpenAI;
  private questAgent: QuestAgent;
  private suggestionAgent: SuggestionAgent;

  // --------- Constructor ---------
  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.EXPO_PUBLIC_DEEPSEEK_API_KEY,
      baseURL: "https://api.deepseek.com/v1",
      dangerouslyAllowBrowser: true
    });
    this.questAgent = new QuestAgent();
    this.suggestionAgent = SuggestionAgent.getInstance();

    console.log("ü§ñ [ChatAgent] Initialized with DeepSeek for main responses.");
    console.log("ü§ñ [ChatAgent] SuggestionAgent configured (assumed Gemini for status checks/suggestions).");
  }

  // --------- generateChatResponse ---------
  async generateChatResponse(message: string, userId: string): Promise<string[]> {
    let statusChangeResult: TaskStatusChangeResult | null = null;
    let deepseekResponse: ChatCompletion | null = null;

    try {
        if (!userId) { throw new Error('User ID required'); }
        console.log('\n=== ChatAgent.generateChatResponse ===');

        // --- 1. Fetch Initial Context (Concurrent) ---
        const today = new Date();
        const todayStr = formatDate(today); // Helper function assumed to return 'YYYY-MM-DD'

        // Define promises for fetching data concurrently
        const activeTasksPromise = fetchActiveTasks(userId);
        const personalityTypePromise = personalityService.getUserPersonality(userId);
        const relevantQuestsPromise = this.questAgent.findRelevantQuests(message, userId);
        const historyPromise = (async (): Promise<ChatMessage[]> => {
            // Fetch chat history (e.g., from local storage)
            try {
                const storedMessages = localStorage.getItem(`chat_messages_local_${userId}`);
                if (storedMessages) {
                    // Basic validation could be added here if needed
                    return JSON.parse(storedMessages) as ChatMessage[];
                }
            } catch (e) {
                console.error("[ChatAgent] Error reading chat history from localStorage:", e);
            }
            return []; // Return empty array if fetch fails or no history
        })();

        // Fetch today's checkups using journalService
        const checkupsPromise = journalService.getCheckupEntries(todayStr, userId)
           .catch((err: any) => {
              console.error("[ChatAgent] Error fetching today's checkups:", err);
              return [] as CheckupEntry[]; // Return typed empty array on error
           });

        // Fetch recent daily journal summaries using journalService
        const recentEntriesPromise = journalService.getRecentEntries(2, userId) // Limit to 2 entries
           .catch((err: any) => {
              console.error("[ChatAgent] Error fetching recent journal entries:", err);
              return [] as JournalEntry[]; // Return typed empty array on error
           });

        // Await all concurrent fetches
        const [
            activeTasks,
            personalityType,
            relevantQuests,
            currentMessages,     // History (ChatMessage[])
            todaysCheckups,      // Today's Checkups (CheckupEntry[])
            recentEntries        // Recent Daily Summaries (JournalEntry[])
        ] = await Promise.all([
            activeTasksPromise,
            personalityTypePromise,
            relevantQuestsPromise,
            historyPromise,
            checkupsPromise,
            recentEntriesPromise
        ]);

        // Get personality based on fetched type
        const personality = getPersonality(personalityType);

        // Log the counts of fetched items for debugging
        console.log(`Fetched context: ${relevantQuests.length} quests, ${activeTasks.length} tasks, ${currentMessages.length} history, ${todaysCheckups.length} checkups, ${recentEntries.length} summaries.`);


        // --- 2. Build Prompt Context Parts ---

        // Build context string for relevant quests and their tasks
        let questContext = '';
        if (relevantQuests.length > 0) {
            questContext = '\nRELEVANT QUEST AND TASK DETAILS:\n' + relevantQuests.map((quest: Quest) => {
                let questInfo = `\nQuest: ${quest.title} (Status: ${quest.status || 'Unknown'})\n`;
                questInfo += `Description: ${quest.description || 'No description available'}\n`;

                // Add specifically relevant tasks mentioned in the quest context
                if (quest.relevantTasks && quest.relevantTasks.length > 0) {
                    questInfo += 'Relevant Tasks Mentioned:\n';
                    // Assuming Task type is correct, use 'any' as fallback if structure varies
                    quest.relevantTasks.forEach((task: Task | any) => {
                        questInfo += `- ${task.name} (Desc: ${task.description || 'N/A'}, Why Relevant: ${task.relevance})\n`;
                    });
                }

                // Add other tasks related to the quest for broader context
                const otherTasks = quest.tasks?.filter((task: Task) =>
                    !quest.relevantTasks?.some(rt => rt.taskId === task.id)
                );
                if (otherTasks && otherTasks.length > 0) {
                    questInfo += 'Other Related Tasks:\n';
                    otherTasks.forEach((task: Task) => {
                        questInfo += `- ${task.title} (${task.status})\n`;
                    });
                }

                // Add the reason why the quest itself is relevant
                if (quest.relevance) {
                    questInfo += `\nRelevance to Current Conversation: ${quest.relevance}\n`;
                }
                return questInfo;
             }).join('\n---\n'); // Separator between quests
        }

        // Build context string for currently active tasks
        let tasksContext = '';
        if (activeTasks.length > 0) {
            tasksContext = '\nACTIVE / CURRENT TASKS (User is working on these):\n' + activeTasks.map((task: Task) => {
                let taskInfo = `- ${task.title} (ID: ${task.id}, Status: ${task.status})\n`;
                if (task.description) {
                    taskInfo += `  Description: ${task.description}\n`;
                }
                // Include associated quest if available
                if (task.quest?.title) {
                    taskInfo += `  Part of Quest: ${task.quest.title}\n`;
                }
                return taskInfo;
            }).join(''); // Join task info lines
        }

        // Build context string for today's checkup entries
        let checkupContext = '';
        if (todaysCheckups && todaysCheckups.length > 0) {
            checkupContext = todaysCheckups.map((checkup: CheckupEntry) => {
                // Format time HH:MM
                const time = new Date(checkup.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
                return `[${time}] Checkup: "${checkup.content || ''}"\n[${time}] My Response: "${checkup.ai_checkup_response || 'No response recorded'}"`;
            }).join('\n\n'); // Separate checkups with double newline
        } else {
             console.log("[ChatAgent] No checkup entries found for today's context.");
        }

        // Build context string for recent daily journal summaries
        let journalContext = '';
        if (recentEntries && recentEntries.length > 0) {
            journalContext = recentEntries
                // Optional: Ensure entries belong to the user (should be handled by service ideally)
                .filter((entry: JournalEntry) => entry.clerk_id === userId)
                .map((entry: JournalEntry) => {
                    // Format date like 'Jan 1'
                    const entryDate = new Date(entry.updated_at || entry.created_at); // Use updated_at if available
                    const formattedDate = entryDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    // Use user_entry and ai_response from JournalEntry
                    return `[${formattedDate}] Past Daily Summary: "${entry.user_entry || ''}"\n[${formattedDate}] My Response: "${entry.ai_response || 'No response recorded'}"`;
                }).join('\n\n'); // Separate summaries with double newline
        } else {
            console.log("[ChatAgent] No recent journal entries found for context.");
        }
        // --- 3. Format History & Messages ---
        // ... (Mapping currentMessages to chatMessages remains the same) ...
         const chatMessages: ChatCompletionMessageParam[] = currentMessages?.map((msg: ChatMessage): ChatCompletionMessageParam => ({
            role: msg.is_user ? 'user' : 'assistant',
            content: msg.message
        })) || [];

        const messages: ChatCompletionMessageParam[] = [
            { role: "system", content: personality.prompts.chat.system + `\nQuests: ${questContext || 'None'}\nTasks: ${tasksContext || 'None'}\nJournal: ${journalContext || 'None'}\nCheckups: ${checkupContext || 'None'}` },
            ...chatMessages,
            { role: "user", content: message }
        ];


                // --- 4. Define Concurrent Promises ---
                console.log('[ChatAgent] Starting concurrent: Task Status Change Check (Assumed Gemini) + Main Response (DeepSeek)'); // Added log for clarity

                const statusChangePromise = this.suggestionAgent.detectTaskStatusChangeIntent(message, userId, activeTasks)
                    .catch((err: any) => {
                        // <<< FIX: Added error logging back
                        console.error("[ChatAgent] Error during concurrent status change detection:", err);
                        return null; // Ensure null is returned on error
                    });
        
                console.log('\n=== SENDING TO DEEPSEEK LLM ==='); // Added log for clarity
                console.log(`FULL PROMPT:\n${JSON.stringify(messages)}`); // Added log for clarity
                const responsePromise = this.openai.chat.completions.create({
                    model: "deepseek-chat",
                    messages: messages,
                    // <<< FIX: Added temperature and max_tokens back
                    temperature: 0.6,
                    max_tokens: 420
                }).catch((err: any) => {
                    // <<< FIX: Added error logging back
                    console.error("[ChatAgent] Error during concurrent main response generation (DeepSeek):", err);
                    return null; // Ensure null is returned on error
                });

        // --- 5. Run Concurrently ---
        // ... (Promise.all remains the same) ...
        const [statusResult, dsResponse] = await Promise.all([ statusChangePromise, responsePromise ]);
        statusChangeResult = statusResult;
        deepseekResponse = dsResponse;

        // --- 6. Process Results ---
        if (statusChangeResult?.isStatusChangeDetected && statusChangeResult.existingTaskId && statusChangeResult.newStatus) {
          console.log(`Triggering task update: ${statusChangeResult.existingTaskId} to ${statusChangeResult.newStatus}`);
          // <<< Make sure actual update logic is here
          updateTask(statusChangeResult.existingTaskId, { status: statusChangeResult.newStatus }, userId)
            .catch(updateError => console.error(`Task update FAILED for ${statusChangeResult?.existingTaskId}:`, updateError));
      }

      let responseText = "Apologies, encountered an issue generating a response.";
      if (deepseekResponse) {
           // <<< Make sure actual response processing is here
          responseText = deepseekResponse.choices?.[0]?.message?.content || "Received empty response content.";
          console.log('AI response received (DeepSeek).');
      } else {
           // <<< Make sure actual error handling is here
           console.error("[ChatAgent] Main chat response generation failed (DeepSeek response is null).");
           responseText = "Damn netrunners must be messing with our connection. Try again in a bit.";
      }

       // <<< Make sure actual cleanup/splitting logic is here
      const cleanedResponse = responseText.replace(/^["'](.*)["']$/, '$1');
      const splitMessages = cleanedResponse.split(/\n+/).map(msg => msg.trim()).filter(msg => msg.length > 0);
      console.log('Final split messages:', splitMessages.length);
      return splitMessages.length > 0 ? splitMessages : [responseText]; // Ensure always return array


  } catch (error) {
      console.error('Critical Error in generateChatResponse:', error);
      return ["A critical system error occurred."];
  }
}






  // --- summarizeAndStoreSession ---
  async summarizeAndStoreSession(messages: ChatMessage[]): Promise<string> {
    const userId = messages[0]?.clerk_id;
    if (!userId) { throw new Error('User ID is required to store session'); }
    try {
      if (!messages || messages.length === 0) { throw new Error('No messages to store'); }
      if (messages.some(msg => msg.clerk_id !== userId)) { throw new Error('Session contains messages from multiple users'); }
      console.log('\n=== ChatAgent.summarizeAndStoreSession ===');
      console.log(`Processing ${messages.length} messages for user ${userId}`);
      const messageCount = messages.length;
      const timestamp = new Date().toLocaleString();
      const summary = `Chat session with ${messageCount} messages on ${timestamp}`;
      const userMessages = messages.filter(m => m.is_user).map(m => m.message).join(' ');
      const commonWords = ['the','is','in','it','and','to','a','of','I','you','that','for','was','my','on','with','me','do','be','at','this','have','from','or','by','what','go','can'];
      const potentialTags = userMessages.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/)
        .filter(word => word.length > 3 && !commonWords.includes(word))
        .filter((word, i, arr) => arr.indexOf(word) === i)
        .slice(0, 5);
        const sessionData = await chatDataUtils.createChatSession(summary, potentialTags, userId);
      console.log(`[ChatAgent] Created chat session with ID: ${sessionData.id}`);
      const validMessageIds = messages.map(m => m.id).filter((id): id is number => typeof id === 'number' && id > 0);
      if (validMessageIds.length > 0) {
        await chatDataUtils.updateMessagesWithSessionId(validMessageIds, sessionData.id, userId);
    }
    await this.generateSuggestionsFromChatSession(messages, userId).catch(/* ... */);
    return sessionData.id;
} catch (error) { console.error('Error in summarizeAndStoreSession:', error); throw error; }
}
// --- generateSuggestionsFromChatSession ---
private async generateSuggestionsFromChatSession(messages: ChatMessage[], userId: string): Promise<void> {
  if (!messages || messages.length === 0 || !userId) { return; }
  try {
      const conversationData: ConversationData = {
        messages: messages.map((msg) => ({
          role: msg.is_user ? "user" as const : "assistant" as const,
          content: msg.message,
          timestamp: msg.created_at
        })),
        metadata: {
          startTime: messages[0]?.created_at || new Date().toISOString(),
          endTime: messages[messages.length - 1]?.created_at || new Date().toISOString(), 
          totalMessages: messages.length
        }
      };
      await this.suggestionAgent.analyzeConversation(conversationData, userId);
  } catch (error: any) { console.error('Error in suggestion generation:', error); }
}

} // End of ChatAgent class



================================================================
End of Codebase
================================================================
