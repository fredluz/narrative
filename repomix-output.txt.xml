<repomix>This file is a merged representation of the entire codebase, combined into a single document. The content has been processed where content has been formatted for parsing.
Generated by Repomix on: 2025-02-09T00:14:44.080Z<file_summary>This section contains a summary of this file.<purpose>This file contains a packed representation of the entire repository&apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.</purpose><file_format>The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file</file_format><usage_guidelines>- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.</usage_guidelines><notes>- Some files may have been excluded based on .gitignore rules and Repomix&apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been formatted for parsing in xml style</notes><additional_info></additional_info></file_summary><directory_structure>.gitignore
app.config.ts
app.json
app/_layout.tsx
app/+not-found.tsx
app/index.tsx
app/journal.tsx
app/landing.tsx
app/notification.tsx
app/quests.tsx
app/styles/global.js
app/types.ts
components/__tests__/__snapshots__/ThemedText-test.tsx.snap
components/__tests__/ThemedText-test.tsx
components/ChatInterface.tsx
components/Collapsible.tsx
components/ExternalLink.tsx
components/HapticTab.tsx
components/HelloWave.tsx
components/KanbanBoard.tsx
components/layouts/DesktopLayout.tsx
components/layouts/MobileLayout.tsx
components/ParallaxScrollView.tsx
components/QuestsOverview.tsx
components/TaskList.tsx
components/ThemedText.tsx
components/ThemedView.tsx
components/ui/HamburgerMenu.tsx
components/ui/IconSymbol.ios.tsx
components/ui/IconSymbol.tsx
components/ui/LoadingSpinner.tsx
components/ui/SettingsButton.tsx
components/ui/TabBarBackground.ios.tsx
components/ui/TabBarBackground.tsx
constants/Colors.ts
contexts/QuestUpdateContext.tsx
contexts/SupabaseContext.tsx
contexts/ThemeContext.tsx
hooks/useChatData.ts
hooks/useColorScheme.web.ts
hooks/useThemeColor.ts
lib/supabase.ts
package.json
README.md
scripts/reset-project.js
services/questsService.ts
services/tasksService.ts
tsconfig.json
types/quest.ts
utils/dateFormatters.ts</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path=".gitignore"># Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local


# typescript
*.tsbuildinfo

app-example</file><file path="app.config.ts">import {config} from &apos;dotenv&apos;;

config({path: &apos;.env.local&apos;});

export default {
  expo: {
    name: &quot;QuestLog&quot;,
    slug: &quot;questlog&quot;,
    version: &quot;1.0.0&quot;,
    extra: {
      supabaseUrl: process.env.EXPO_PUBLIC_SUPABASE_URL,
      supabaseAnonKey: process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY,
    },
  },
};</file><file path="app.json">{
  &quot;expo&quot;: {
    &quot;name&quot;: &quot;QuestLog&quot;,
    &quot;slug&quot;: &quot;QuestLog&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;orientation&quot;: &quot;portrait&quot;,
    &quot;icon&quot;: &quot;./assets/images/icon.png&quot;,
    &quot;scheme&quot;: &quot;myapp&quot;,
    &quot;userInterfaceStyle&quot;: &quot;automatic&quot;,
    &quot;newArchEnabled&quot;: true,
    &quot;ios&quot;: {
      &quot;supportsTablet&quot;: true
    },
    &quot;android&quot;: {
      &quot;adaptiveIcon&quot;: {
        &quot;foregroundImage&quot;: &quot;./assets/images/adaptive-icon.png&quot;,
        &quot;backgroundColor&quot;: &quot;#ffffff&quot;
      }
    },
    &quot;web&quot;: {
      &quot;bundler&quot;: &quot;metro&quot;,
      &quot;output&quot;: &quot;static&quot;,
      &quot;favicon&quot;: &quot;./assets/images/favicon.png&quot;
    },
    &quot;plugins&quot;: [
      &quot;expo-router&quot;,
      [
        &quot;expo-splash-screen&quot;,
        {
          &quot;image&quot;: &quot;./assets/images/splash-icon.png&quot;,
          &quot;imageWidth&quot;: 200,
          &quot;resizeMode&quot;: &quot;contain&quot;,
          &quot;backgroundColor&quot;: &quot;#ffffff&quot;
        }
      ]
    ],
    &quot;experiments&quot;: {
      &quot;typedRoutes&quot;: true
    }
  }
}</file><file path="app/_layout.tsx">import { Stack } from &apos;expo-router&apos;;
import * as SplashScreen from &apos;expo-splash-screen&apos;;
import { useCallback } from &apos;react&apos;;
import { View, Text } from &apos;react-native&apos;;
import { useFonts, Inter_400Regular, Inter_700Bold } from &apos;@expo-google-fonts/inter&apos;;
import { Poppins_400Regular, Poppins_700Bold } from &apos;@expo-google-fonts/poppins&apos;;
import { ThemeProvider as AppThemeProvider } from &apos;@/contexts/ThemeContext&apos;;
import { SupabaseProvider, useSupabase } from &apos;@/contexts/SupabaseContext&apos;;
import { QuestUpdateProvider } from &apos;@/contexts/QuestUpdateContext&apos;;
import styles from &apos;./styles/global&apos;;

// Keep the splash screen visible while we fetch resources
SplashScreen.preventAutoHideAsync();

function RootLayoutContent() {
  const { isLoading: isSupabaseLoading } = useSupabase();
  const [fontsLoaded] = useFonts({
    Inter_400Regular,
    Inter_700Bold,
    Poppins_400Regular,
    Poppins_700Bold,
  });

  const onLayoutRootView = useCallback(async () =&gt; {
    if (fontsLoaded &amp;&amp; !isSupabaseLoading) {
      await SplashScreen.hideAsync();
    }
  }, [fontsLoaded, isSupabaseLoading]);

  if (!fontsLoaded || isSupabaseLoading) {
    return (
      &lt;View style={{ flex: 1, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos;, backgroundColor: &apos;#181818&apos; }}&gt;
        &lt;Text style={{ color: &apos;#fff&apos; }}&gt;Loading...&lt;/Text&gt;
      &lt;/View&gt;
    );
  }

  return (
    &lt;View style={{ flex: 1 }} onLayout={onLayoutRootView}&gt;
      &lt;AppThemeProvider&gt;
        &lt;QuestUpdateProvider&gt;
          &lt;Stack
            screenOptions={{
              headerShown: false,
              contentStyle: { backgroundColor: &apos;#181818&apos; },
            }}
          &gt;
            &lt;Stack.Screen name=&quot;index&quot; options={{ headerShown: false }} /&gt;
            &lt;Stack.Screen name=&quot;landing&quot; options={{ headerShown: false }} /&gt;
            &lt;Stack.Screen name=&quot;quests&quot; options={{ headerShown: false }} /&gt;
          &lt;/Stack&gt;
        &lt;/QuestUpdateProvider&gt;
      &lt;/AppThemeProvider&gt;
    &lt;/View&gt;
  );
}

export default function RootLayout() {
  return (
    &lt;SupabaseProvider&gt;
      &lt;RootLayoutContent /&gt;
    &lt;/SupabaseProvider&gt;
  );
}</file><file path="app/+not-found.tsx">import { Link, Stack } from &apos;expo-router&apos;;
import { StyleSheet } from &apos;react-native&apos;;

import { ThemedText } from &apos;@/components/ThemedText&apos;;
import { ThemedView } from &apos;@/components/ThemedView&apos;;

export default function NotFoundScreen() {
  return (
    &lt;&gt;
      &lt;Stack.Screen options={{ title: &apos;Oops!&apos; }} /&gt;
      &lt;ThemedView style={styles.container}&gt;
        &lt;ThemedText type=&quot;title&quot;&gt;This screen doesn&apos;t exist.&lt;/ThemedText&gt;
        &lt;Link href=&quot;/&quot; style={styles.link}&gt;
          &lt;ThemedText type=&quot;link&quot;&gt;Go to home screen!&lt;/ThemedText&gt;
        &lt;/Link&gt;
      &lt;/ThemedView&gt;
    &lt;/&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: &apos;center&apos;,
    justifyContent: &apos;center&apos;,
    padding: 20,
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
});</file><file path="app/index.tsx">import { Redirect } from &apos;expo-router&apos;;

export default function Index() {
  return &lt;Redirect href=&quot;/landing&quot; /&gt;;
}</file><file path="app/journal.tsx">import React, { useState, useEffect } from &apos;react&apos;;
import {
  View,
  ScrollView,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  Platform,
  KeyboardAvoidingView,
  SafeAreaView,
  Dimensions
} from &apos;react-native&apos;;
import { ThemedText } from &apos;@/components/ThemedText&apos;;
import { ThemedView } from &apos;@/components/ThemedView&apos;;
import { useTheme } from &apos;@/contexts/ThemeContext&apos;; // Import useTheme
import { IconSymbol } from &apos;@/components/ui/IconSymbol&apos;;

// Mock data for journal entries (replace with actual data fetching)
interface JournalEntry {
  date: string; // YYYY-MM-DD format
  userEntry: string;
  aiGeneratedEntry: string;
}

const getMockJournalEntries = (): JournalEntry[] =&gt; {
  const today = new Date();
  const entries: JournalEntry[] = [];

  for (let i = -6; i &lt;= 0; i++) { // Last 7 days, including today
    const date = new Date(today);
    date.setDate(today.getDate() + i);
    const dateString = date.toISOString().split(&apos;T&apos;)[0];

    let userEntry = &apos;&apos;;
    let aiGeneratedEntry = `AI summary for ${dateString}.`;
    if (i === -2) {
      userEntry = &quot;I felt really productive today! Finished the Kanban board UI and started working on the chat integration.&quot;;
      aiGeneratedEntry = &quot;[SILVERHAND]: Not bad, samurai. You&apos;re crushing it with that UI work. Keep pushing those boundaries and stick it to the corporate code.&quot;;
    } else if (i === -5) {
      userEntry = &quot;[NO USER ENTRY]&quot;;
      aiGeneratedEntry = &quot;[SILVERHAND]: Wake the fuck up, samurai. Can&apos;t build digital revolution by staring at blank screens. Time to make some noise.&quot;;
    } else if (i === 0) {
        userEntry = &quot;Today, I missed the deadline and it was a big bummer. I also forgot to plan today, so I feel lost&quot;;
        aiGeneratedEntry = &quot;[SILVERHAND]: Listen up - deadlines are just corpo bullshit anyway. Tomorrow&apos;s another day to raise hell. Get your shit together and show them what you&apos;re made of.&quot;;
    }

    entries.push({
      date: dateString,
      userEntry,
      aiGeneratedEntry,
    });
  }
  return entries;
};


const JournalScreen: React.FC = () =&gt; {
  const { themeColor } = useTheme(); // Use the themeColor
  const [entries, setEntries] = useState&lt;JournalEntry[]&gt;([]);
  const [selectedDate, setSelectedDate] = useState&lt;string | null&gt;(null);
  const [userEntry, setUserEntry] = useState&lt;string&gt;(&apos;&apos;);
  const [isEditing, setIsEditing] = useState&lt;boolean&gt;(false);
  const [isNewEntry, setIsNewEntry] = useState&lt;boolean&gt;(false);
  const windowHeight = Dimensions.get(&apos;window&apos;).height;


  useEffect(() =&gt; {
    // Replace with actual data fetching from your backend/local storage
    const fetchedEntries = getMockJournalEntries();
    setEntries(fetchedEntries);

    // Set today&apos;s date as the initially selected date
    const today = new Date().toISOString().split(&apos;T&apos;)[0];
    setSelectedDate(today);

    // Load the user entry for today
    const todaysEntry = fetchedEntries.find((entry) =&gt; entry.date === today);
    setUserEntry(todaysEntry?.userEntry || &apos;&apos;);
  }, []);

  const handleDateSelect = (date: string) =&gt; {
    setSelectedDate(date);
    const selectedEntry = entries.find((entry) =&gt; entry.date === date);
    setUserEntry(selectedEntry?.userEntry || &apos;&apos;);
    setIsEditing(false); // Exit edit mode when switching dates
    setIsNewEntry(false);
  };

  const handleSaveEntry = () =&gt; {
    // Replace with actual data saving to your backend/local storage
    if (selectedDate) {
      const updatedEntries = entries.map((entry) =&gt;
        entry.date === selectedDate ? { ...entry, userEntry } : entry
      );

      if (isNewEntry) { //add new entry to entries array
        updatedEntries.push({
            date: selectedDate,
            userEntry,
            aiGeneratedEntry: &apos;AI summary will appear after saving.&apos;
        })
      }
      setEntries(updatedEntries);
      setIsEditing(false);
      setIsNewEntry(false)
      console.log(&apos;Saving entry:&apos;, { date: selectedDate, userEntry });
    }
  };

  const handleNewEntry = () =&gt; {
    setIsEditing(true)
    setIsNewEntry(true)
    setUserEntry(&apos;&apos;);
    const today = new Date().toISOString().split(&apos;T&apos;)[0];
    setSelectedDate(today);
  }

  const selectedEntry = selectedDate ? entries.find((entry) =&gt; entry.date === selectedDate) : null;
  const isDarkColor = (color: string) =&gt; {
    const hex = color.replace(&apos;#&apos;, &apos;&apos;);
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    return brightness &lt; 128;
  };

  const textColor = isDarkColor(themeColor) ? &apos;#fff&apos; : &apos;#000&apos;;


  return (
    &lt;SafeAreaView style={{ flex: 1, backgroundColor: &apos;#181818&apos;, height: windowHeight }}&gt;
        &lt;ThemedView style={[styles.container, { backgroundColor: &apos;#181818&apos;, height: windowHeight }]}  &gt;
            &lt;View style={styles.header}&gt;
                &lt;ThemedText type=&quot;title&quot;&gt;Journal&lt;/ThemedText&gt;
                &lt;TouchableOpacity style={[styles.newEntryButton, {backgroundColor: themeColor}]} onPress={handleNewEntry}&gt;
                &lt;IconSymbol name=&quot;plus&quot; size={20} color={textColor} /&gt;
                &lt;ThemedText style={[styles.newEntryButtonText, {color: textColor}]}&gt;New Entry&lt;/ThemedText&gt;
                &lt;/TouchableOpacity&gt;
            &lt;/View&gt;

            &lt;View style={styles.contentContainer}&gt;
                &lt;ScrollView
                horizontal
                showsHorizontalScrollIndicator={false}
                contentContainerStyle={styles.dateList}
                &gt;
                {entries.map((entry) =&gt; (
                    &lt;TouchableOpacity
                    key={entry.date}
                    style={[
                        styles.dateButton,
                        selectedDate === entry.date &amp;&amp; { backgroundColor: themeColor },
                    ]}
                    onPress={() =&gt; handleDateSelect(entry.date)}
                    &gt;
                    &lt;ThemedText style={[styles.dateText, selectedDate === entry.date &amp;&amp; { color: textColor } ]}&gt;
                        {entry.date}
                    &lt;/ThemedText&gt;
                    &lt;/TouchableOpacity&gt;
                ))}
                &lt;/ScrollView&gt;

                &lt;ThemedView style={[styles.entryContainer, { borderColor: themeColor, borderWidth: 2, backgroundColor: &apos;#333333&apos; } ]}&gt;
                {selectedEntry ? (
                    &lt;ScrollView style={styles.entryScrollView} &gt;
                        {isEditing ? (
                            &lt;KeyboardAvoidingView
                            behavior={Platform.OS === &apos;ios&apos; ? &apos;padding&apos; : &apos;height&apos;}
                            style={{ flex: 1 }}
                            &gt;
                            &lt;TextInput
                                style={[styles.entryInput, {color: textColor}]}
                                multiline
                                value={userEntry}
                                onChangeText={setUserEntry}
                                placeholder=&quot;Write your entry...&quot;
                                placeholderTextColor=&quot;#AAA&quot;
                            /&gt;
                            &lt;/KeyboardAvoidingView&gt;
                        ) : (
                            &lt;&gt;
                            &lt;ThemedText style={styles.entryText}&gt;
                                {selectedEntry.userEntry || &apos;No personal entry for this day.&apos;}
                            &lt;/ThemedText&gt;
                            &lt;ThemedText style={styles.aiEntryText}&gt;
                                {selectedEntry.aiGeneratedEntry}
                            &lt;/ThemedText&gt;
                            &lt;/&gt;
                        )}
                    &lt;/ScrollView&gt;
                ) : (
                    &lt;ThemedText style={styles.noEntryText}&gt;Select a date to view the entry.&lt;/ThemedText&gt;
                )}

                {!isEditing &amp;&amp; selectedEntry ? (
                    &lt;TouchableOpacity
                    style={[styles.editButton, {backgroundColor: themeColor }]}
                    onPress={() =&gt; setIsEditing(true)}
                    &gt;
                    &lt;IconSymbol name=&quot;pencil&quot; size={20} color={textColor} /&gt;
                    &lt;ThemedText style={[styles.buttonText, {color: textColor}]}&gt;Edit Entry&lt;/ThemedText&gt;
                    &lt;/TouchableOpacity&gt;
                ) : isEditing ? (
                    &lt;TouchableOpacity
                    style={[styles.saveButton, {backgroundColor: themeColor}]}
                    onPress={handleSaveEntry}
                    &gt;
                    &lt;IconSymbol name=&quot;checkmark&quot; size={20} color={textColor} /&gt;
                    &lt;ThemedText style={[styles.buttonText, {color: textColor}]}&gt;Save Entry&lt;/ThemedText&gt;
                    &lt;/TouchableOpacity&gt;
                ) : null}
              &lt;/ThemedView&gt;
            &lt;/View&gt;
        &lt;/ThemedView&gt;
    &lt;/SafeAreaView&gt;
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
  },
  header: {
    flexDirection: &apos;row&apos;,
    justifyContent: &apos;space-between&apos;,
    alignItems: &apos;center&apos;,
    marginBottom: 20,
  },
  contentContainer: {
    flex: 1,
  },
  dateList: {
    flexDirection: &apos;row&apos;,
    paddingBottom: 10,
  },
  dateButton: {
    paddingHorizontal: 15,
    paddingVertical: 10,
    marginRight: 10,
    borderRadius: 20,
    backgroundColor: &apos;#444&apos;, // Default date button color
  },
  dateText: {
    fontSize: 16,
    color: &apos;#FFF&apos;,
  },
  entryContainer: {
    flex: 1,
    borderRadius: 12,
    padding: 16,
    marginTop: 10,
    marginBottom: 20,
    backgroundColor: &apos;#333&apos;
  },
  entryScrollView:{
    flex: 1
  },
  entryText: {
    fontSize: 16,
    color: &apos;#FFF&apos;,
    marginBottom: 20,
    fontFamily: &apos;Inter_400Regular&apos;,
  },
  aiEntryText: {
    fontSize: 14,
    color: &apos;#AAA&apos;,
    fontStyle: &apos;italic&apos;,
    fontFamily: &apos;Inter_400Regular&apos;,
  },
  noEntryText: {
    fontSize: 16,
    color: &apos;#888&apos;,
    textAlign: &apos;center&apos;,
    marginTop: 20,
    fontFamily: &apos;Inter_400Regular&apos;,
  },
  entryInput: {
    flex: 1,
    fontSize: 16,
    color: &apos;#FFF&apos;,
    fontFamily: &apos;Inter_400Regular&apos;,
    minHeight: 250,
    textAlignVertical: &apos;top&apos;,
  },
  editButton: {
    flexDirection: &apos;row&apos;,
    alignItems: &apos;center&apos;,
    justifyContent: &apos;center&apos;,
    padding: 10,
    borderRadius: 20,
    marginTop: 10,
    backgroundColor: &apos;#007BFF&apos;, // Edit button color
  },
  saveButton: {
    flexDirection: &apos;row&apos;,
    alignItems: &apos;center&apos;,
    justifyContent: &apos;center&apos;,
    padding: 10,
    borderRadius: 20,
    marginTop: 10,
     // Save button color
  },
  buttonText: {
    color: &apos;white&apos;,
    marginLeft: 8,
    fontSize: 16,
    fontFamily: &apos;Inter_700Bold&apos;,
  },
    newEntryButton: {
    flexDirection: &apos;row&apos;,
    alignItems: &apos;center&apos;,
    paddingHorizontal: 15,
    paddingVertical: 10,
    borderRadius: 20,
  },
  newEntryButtonText: {
    marginLeft: 8,
    fontSize: 16,
    fontFamily: &apos;Inter_700Bold&apos;,
  }
});

export default JournalScreen;</file><file path="app/landing.tsx">import React from &apos;react&apos;;
import { useWindowDimensions, Platform } from &apos;react-native&apos;;
import { MobileLayout } from &apos;@/components/layouts/MobileLayout&apos;;
import { DesktopLayout } from &apos;@/components/layouts/DesktopLayout&apos;;

export default function HomeScreen() {
  const { width } = useWindowDimensions();
  const isMobile = Platform.OS === &apos;ios&apos; || Platform.OS === &apos;android&apos; || width &lt; 768;

  return isMobile ? &lt;MobileLayout /&gt; : &lt;DesktopLayout /&gt;;
}</file><file path="app/notification.tsx">/*import React from &apos;react&apos;;
import { View } from &apos;react-native&apos;;
import { ChatInterface } from &apos;@/components/ChatInterface&apos;;
import { useTheme } from &apos;@/contexts/ThemeContext&apos;;
import styles from &apos;./styles/global&apos;;

export default function NotificationScreen() {
  const { themeColor } = useTheme();
  const recentMessages = [
    { sender: &quot;Batcomputer&quot;, message: &quot;Fred, today&apos;s your last day to get your medication refilled.&quot; },
    { sender: &quot;Batcomputer&quot;, message: &quot;The pharmacy closes at 3PM, so you&apos;ve got 5 hours.&quot;},
    { sender: &quot;You&quot;, message: &quot;I don&apos;t feel like going out right now.&quot; },
    { sender: &quot;Batcomputer&quot;, message: &quot;Then I&apos;ll set a reminder for after lunch.&quot; },
    { sender: &quot;Batcomputer&quot;, message: &quot;Please make sure to get this done, you know how much better you feel when medicated.&quot; },
  ];

  return (
    &lt;View style={[styles.container, { backgroundColor: &apos;#181818&apos; }]}&gt;
      &lt;ChatInterface themeColor={themeColor} recentMessages={recentMessages} /&gt;
    &lt;/View&gt;
  );
}
*/</file><file path="app/quests.tsx">import React from &apos;react&apos;;
import { QuestsOverview } from &apos;@/components/QuestsOverview&apos;;
import { useRouter } from &apos;expo-router&apos;;
import { useQuests } from &apos;@/services/questsService&apos;;
import { useQuestUpdate } from &apos;@/contexts/QuestUpdateContext&apos;;

export default function QuestsScreen() {
  const router = useRouter();
  const { quests, setQuestAsMain, mainQuest } = useQuests();
  const { triggerUpdate } = useQuestUpdate();

  const handleQuestSelect = async (questId: number) =&gt; {
    await setQuestAsMain(questId);
    triggerUpdate(); // Mark that an update is needed
  };

  return (
    &lt;QuestsOverview 
      onSelectQuest={handleQuestSelect} 
      quests={quests} 
      currentMainQuest={mainQuest}
    /&gt;
  );
}</file><file path="app/styles/global.js">import { StyleSheet, Platform } from &apos;react-native&apos;;

/**
 * A refined dark theme leveraging subtle gradients, rounded corners, 
 * modern font pairings, soft shadows, and increased spacing to improve 
 * readability and visual hierarchy. 
 * 
 * Note: 
 * - For gradient backgrounds, consider using libraries such as 
 *   &quot;react-native-linear-gradient&quot; or &quot;expo-linear-gradient&quot; and 
 *   wrapping relevant components accordingly.
 * - For animations (hover, loading, transitions), consider using
 *   React Native&apos;s Animated API or third-party libraries like
 *   &quot;react-native-reanimated&quot; or Lottie for more advanced Interactions.
 */
const styles = StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: Platform.select({
      ios: &apos;column&apos;,
      android: &apos;column&apos;,
      default: &apos;row&apos;
    }),
    backgroundColor: &apos;#1E1E1E&apos;, // Base dark background
    padding: Platform.select({
      ios: 10,
      android: 10,
      default: 16
    }),               // Increased padding for more whitespace
  },
  column: {
    flex: 1,
    marginHorizontal: 8,       // Slightly larger horizontal margin
    height: &apos;100%&apos;,
  },
  chatCard: {
    flex: 1,
    padding: 16,
    backgroundColor: &apos;#333&apos;,
    borderRadius: 12,          // Subtle rounded corners
    margin: Platform.select({
      ios: 10,
      android: 10,
      default: 0
    }),
    // Soft shadow for depth
    shadowColor: &apos;#000&apos;,
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3,
  },
  chatScroll: {
    flex: 1,
  },
  leftColumn: {
    flex: 1,
    marginRight: 10,
  },
  rightColumn: {
    flex: 1,
    flexDirection: &apos;column&apos;,
  },
  chatContainer: {
    flex: 1,
    marginBottom: 10,
  },
  mainQuestContainer: {
    flex: 2,
    marginBottom: 10,
  },
  mainQuestCard: {
    padding: 20,
    backgroundColor: &apos;#222&apos;,
    borderRadius: 16,
    // Slightly stronger shadow for main quest
    shadowColor: &apos;#000&apos;,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 6,
    elevation: 4,
  },

  // Modern chat bubble styling
  userMessage: {
    alignSelf: &apos;flex-end&apos;,
    backgroundColor: &apos;#007BFF&apos;, // Accent color (can be customized)
    padding: 12,
    paddingHorizontal: 20, // Increased horizontal padding
    borderRadius: 16,
    marginVertical: 5,
    maxWidth: &apos;75%&apos;,
    marginHorizontal: 16, // Increased horizontal margin
    // Font recommendations
    fontFamily: &apos;Inter_400Regular&apos;, // Example UI font
  },
  aiMessage: {
    alignSelf: &apos;flex-start&apos;,
    backgroundColor: &apos;#444&apos;,
    padding: 12,
    paddingHorizontal: 20, // Increased horizontal padding
    borderRadius: 16,
    marginVertical: 5,
    maxWidth: &apos;75%&apos;,
    marginHorizontal: 8, // Increased horizontal margin
    // Font recommendations
    fontFamily: &apos;Inter_400Regular&apos;, // Example UI font
  },
  messageSender: {
    fontWeight: &apos;bold&apos;,
    color: &apos;#FFF&apos;,
    fontFamily: &apos;Poppins_700Bold&apos;, // Example heading font
  },
  messageText: {
    color: &apos;#FFF&apos;,
    fontFamily: &apos;Inter_400Regular&apos;,
  },
  chatMessage: {
    color: &apos;#FFF&apos;,
    fontStyle: &apos;italic&apos;,
    fontFamily: &apos;Inter_400Regular&apos;,
  },

  // Kanban-related styles
  kanbanTaskCard: {
    padding: 10,
    backgroundColor: &apos;#333&apos;,
    marginVertical: 5,
    borderRadius: 12,
    // Soft shadow
    shadowColor: &apos;#000&apos;,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3,
  },
  mainQuestTitle: {
    fontSize: 22,
    fontWeight: &apos;bold&apos;,
    color: &apos;#FFF&apos;,
    marginBottom: 10,
    fontFamily: &apos;Poppins_700Bold&apos;,
  },
  kanbanContainer: {
    flexDirection: &apos;row&apos;,
    justifyContent: &apos;space-between&apos;,
    marginBottom: 10,
  },
  kanbanColumn: {
    flex: 1,
    marginHorizontal: 5,
  },
  kanbanTitle: {
    fontSize: 16,
    fontWeight: &apos;bold&apos;,
    color: &apos;#AAA&apos;,
    fontFamily: &apos;Poppins_700Bold&apos;,
  },
  kanbanTask: {
    fontSize: 14,
    color: &apos;#CCC&apos;,
    marginVertical: 3,
    fontFamily: &apos;Inter_400Regular&apos;,
  },

  // Task-related styles
  taskContainer: {
    flex: 1,
    marginBottom: 10,
  },
  taskCard: {
    padding: 15,
    backgroundColor: &apos;#444&apos;,
    marginBottom: 10,
    borderRadius: 12,
    // Soft shadow
    shadowColor: &apos;#000&apos;,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3,
  },
  cardTitle: {
    fontSize: 18,
    fontWeight: &apos;bold&apos;,
    color: &apos;#FFF&apos;,
    marginBottom: 5,
    fontFamily: &apos;Poppins_700Bold&apos;,
  },
  cardDetails: {
    fontSize: 14,
    color: &apos;#BBB&apos;,
    marginBottom: 5,
    fontFamily: &apos;Inter_400Regular&apos;,
  },
  cardQuest: {
    color: &apos;#FFF&apos;,
    fontSize: 14,
    fontStyle: &apos;italic&apos;,
    fontFamily: &apos;Inter_400Regular&apos;,
  },

  // Chat input &amp; theme selector
  chatInput: {
    backgroundColor: &apos;#222&apos;,
    color: &apos;white&apos;,
    marginVertical: 10,
    padding: 10,
    borderRadius: 12,
    fontFamily: &apos;Inter_400Regular&apos;,
  },
  themeSelector: {
    position: &apos;absolute&apos;,
    top: 10,
    left: 10,
    flexDirection: &apos;row&apos;,
    alignItems: &apos;center&apos;,
  },
  gearIcon: {
    marginRight: 5,
    color: &apos;white&apos;,
  },
  colorInput: {
    backgroundColor: &apos;#222&apos;,
    color: &apos;white&apos;,
    padding: 5,
    borderRadius: 12,
    fontFamily: &apos;Inter_400Regular&apos;,
  },

  // Task list &amp; toggles
  taskListContainer: {
    flex: 1,
    alignItems: &apos;center&apos;,
    marginTop: 10,
  },
  toggleButton: {
    backgroundColor: &apos;#444&apos;,
    padding: 12,
    borderRadius: 12,
    marginBottom: 10,
    // Soft shadow
    shadowColor: &apos;#000&apos;,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 2,
  },
  toggleButtonText: {
    color: &apos;white&apos;,
    fontSize: 16,
    fontFamily: &apos;Inter_400Regular&apos;,
  },

  // Mobile-specific styles
  mobileHeader: {
    height: 50,
    backgroundColor: &apos;#222&apos;,
    justifyContent: &apos;center&apos;,
    alignItems: &apos;center&apos;,
    borderBottomWidth: 1,
    borderBottomColor: &apos;#444&apos;,
  },
  mobileHeaderText: {
    color: &apos;#FFF&apos;,
    fontSize: 20,
    fontWeight: &apos;bold&apos;,
  },
  mobileContent: {
    flex: 1,
    padding: 10,
  },
  mobileNavigation: {
    height: 60,
    backgroundColor: &apos;#222&apos;,
    borderTopWidth: 1,
    borderTopColor: &apos;#333&apos;,
    justifyContent: &apos;center&apos;,
    alignItems: &apos;center&apos;,
    zIndex: 100,
    position: &apos;relative&apos;,
  },
  mobileNavButton: {
    padding: 10,
    borderRadius: 8,
    minWidth: 80,
    alignItems: &apos;center&apos;,
  },
  mobileNavButtonActive: {
    backgroundColor: &apos;#444&apos;,
  },
  mobileNavText: {
    color: &apos;#FFF&apos;,
    fontSize: 14,
  },
  placeholderText: {
    color: &apos;#888&apos;,
    fontSize: 16,
    textAlign: &apos;center&apos;,
    marginTop: 20,
  },
  mobileNavButton: {
    flex: 1,
    padding: 10,
    alignItems: &apos;center&apos;,
    borderRadius: 8,
  },
  mobileNavButtonActive: {
    backgroundColor: &apos;#333&apos;,
  },
  mobileNavText: {
    color: &apos;white&apos;,
    fontSize: 16,
  },

  customChatContainer: {
    flex: 1,
    margin: 10,
    backgroundColor: &apos;#333&apos;,
    borderRadius: 12,
    borderWidth: 2,
    overflow: &apos;hidden&apos;,
    shadowColor: &apos;#000&apos;,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.25,
    shadowRadius: 8,
    elevation: 5,
  },
  
  chatHeader: {
    padding: 16,
    backgroundColor: &apos;#2A2A2A&apos;,
    borderBottomWidth: 1,
    borderBottomColor: &apos;#444&apos;,
  },

  hamburgerButton: {
    width: Platform.select({ ios: 40, android: 40, default: 48 }),
    height: Platform.select({ ios: 40, android: 40, default: 48 }),
    borderRadius: 24,
    justifyContent: &apos;center&apos;,
    alignItems: &apos;center&apos;,
    elevation: 5,
  },
  hamburgerButtonMobile: {
    backgroundColor: &apos;transparent&apos;,
    shadowOpacity: 0,
  },
  hamburgerButtonPressed: {
    opacity: 0.8,
    transform: [{ scale: 0.97 }],
  },

  viewAllQuests: {
    padding: 10,
    borderRadius: 8,
    marginVertical: 10,
    alignItems: &apos;center&apos;,
  },
  viewAllQuestsText: {
    fontSize: 14,
    fontWeight: &apos;bold&apos;,
    fontFamily: &apos;Inter_700Bold&apos;,
  },

  questTasksContainer: {
    marginTop: 20,
    paddingTop: 20,
    borderTopWidth: 1,
    borderTopColor: &apos;#444&apos;,
  },

  setMainQuestButton: {
    padding: 8,
    borderRadius: 8,
    marginLeft: 10,
  },
  setMainQuestButtonText: {
    color: &apos;#fff&apos;,
    fontSize: 12,
    fontWeight: &apos;bold&apos;,
    fontFamily: &apos;Inter_700Bold&apos;,
  },

  desktopHeader: {
    flexDirection: &apos;row&apos;,
    justifyContent: &apos;space-between&apos;,
    alignItems: &apos;center&apos;,
    padding: 20,
    backgroundColor: &apos;#181818&apos;,
    borderBottomWidth: 1,
    borderBottomColor: &apos;#333&apos;,
  },
  desktopHeaderText: {
    fontSize: 24,
    fontWeight: &apos;bold&apos;,
    color: &apos;#fff&apos;,
  },
  errorText: {
    color: &apos;#FF4444&apos;,
    textAlign: &apos;center&apos;,
    padding: 20,
  },
  
  kanbanContainer: {
    flexDirection: &apos;row&apos;,
    justifyContent: &apos;space-between&apos;,
    marginTop: 16,
    gap: 8,
  },
  kanbanColumn: {
    flex: 1,
    gap: 8,
  },
  kanbanTitle: {
    fontSize: 16,
    fontWeight: &apos;bold&apos;,
    marginBottom: 8,
  },
  kanbanTaskCard: {
    padding: 8,
    backgroundColor: &apos;#333&apos;,
  },
  kanbanTask: {
    color: &apos;#fff&apos;,
    fontSize: 14,
  },
  errorText: {
    color: &apos;#FF4444&apos;,
    textAlign: &apos;center&apos;,
    padding: 20,
    fontSize: 16,
  },
  cardQuest: {
    color: &apos;#aaa&apos;,
    fontSize: 14,
    marginTop: 4,
  },
  statusTimestamp: {
    color: &apos;#FFF&apos;,
    fontSize: 12,
    fontFamily: &apos;Inter_700Bold&apos;,
    marginBottom: 5,
  },
});

export default styles;</file><file path="app/types.ts">export interface BaseEntity {
  id: number;
  created_at: string;
  updated_at: string;
  tags?: string[];
}

export interface Task extends BaseEntity {
  title: string;
  description?: string;
  scheduled_for: string;  // Changed from scheduledFor
  location: string;
  quest_id: number;      // Changed from questId
  deadline?: string;
  status: &apos;ToDo&apos; | &apos;InProgress&apos; | &apos;Done&apos;;
  quest?: Quest;         // For joined data
}

export interface JournalEntry extends BaseEntity {
  title: string;
  userEntry: string;
  aiAnalysis: string;
}

export interface QuestStatus extends BaseEntity {
  message: string;
  timestamp: string;
  questId: number;
}

export interface Quest extends BaseEntity {
  title: string;
  tagline: string;
  is_main: boolean;  // Changed from isMain
  status: &apos;Active&apos; | &apos;On-Hold&apos; | &apos;Completed&apos;;
  questStatus?: string;
  currentStatus?: QuestStatus;
  tasks?: Task[];  // Added as optional since it&apos;s a joined field
  analysis?: string;
  parent_quest_id?: number;  // Changed from parentQuestId
  start_date?: string;  // Changed from startDate
  end_date?: string;   // Changed from endDate
  StatusHistory?: Record&lt;string, QuestStatus&gt;;
}

export interface ChatMessage extends BaseEntity {
  message: string;
  isUser: boolean;
}</file><file path="components/__tests__/__snapshots__/ThemedText-test.tsx.snap">// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`renders correctly 1`] = `
&lt;Text
  style={
    [
      {
        &quot;color&quot;: &quot;#11181C&quot;,
      },
      {
        &quot;fontSize&quot;: 16,
        &quot;lineHeight&quot;: 24,
      },
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
    ]
  }
&gt;
  Snapshot test!
&lt;/Text&gt;
`;</file><file path="components/__tests__/ThemedText-test.tsx">import * as React from &apos;react&apos;;
import renderer from &apos;react-test-renderer&apos;;

import { ThemedText } from &apos;../ThemedText&apos;;

it(`renders correctly`, () =&gt; {
  const tree = renderer.create(&lt;ThemedText&gt;Snapshot test!&lt;/ThemedText&gt;).toJSON();

  expect(tree).toMatchSnapshot();
});</file><file path="components/ChatInterface.tsx">import React from &apos;react&apos;;
import { View, Text, ScrollView, TextInput } from &apos;react-native&apos;;
import styles from &apos;@/app/styles/global&apos;;
import { ChatMessage } from &apos;@/app/types&apos;;

interface ChatInterfaceProps {
  themeColor: string;
  recentMessages: ChatMessage[];
}

export const ChatInterface: React.FC&lt;ChatInterfaceProps&gt; = ({ 
    themeColor, 
    recentMessages 
}) =&gt; {

  const isDarkColor = (color: string) =&gt; {
    const hex = color.replace(&apos;#&apos;, &apos;&apos;);
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    return brightness &lt; 128;
  };

  const textColor = isDarkColor(themeColor) ? &apos;#fff&apos; : &apos;#000&apos;;

  return (
    &lt;View style={[styles.customChatContainer, { borderColor: themeColor }]}&gt;
      &lt;View style={styles.chatHeader}&gt;
        &lt;Text style={styles.cardTitle}&gt;Neural Link&lt;/Text&gt;
      &lt;/View&gt;
      &lt;ScrollView style={styles.chatScroll}&gt;
        {recentMessages?.map((msg: ChatMessage, index: number) =&gt; (
          &lt;View key={index} style={[
            msg.isUser ? styles.userMessage : styles.aiMessage,
            msg.isUser &amp;&amp; { backgroundColor: themeColor }
          ]}&gt;
            &lt;Text style={[styles.messageText, msg.isUser &amp;&amp; { color: textColor }]}&gt;
              {msg.message}
            &lt;/Text&gt;
          &lt;/View&gt;
        ))}
      &lt;/ScrollView&gt;
      &lt;TextInput 
        style={styles.chatInput} 
        placeholder=&quot;What&apos;s on your mind?&quot; 
        placeholderTextColor=&apos;#AAA&apos;
      /&gt;
    &lt;/View&gt;
  );
};</file><file path="components/Collapsible.tsx">import { PropsWithChildren, useState } from &apos;react&apos;;
import { StyleSheet, TouchableOpacity } from &apos;react-native&apos;;

import { ThemedText } from &apos;@/components/ThemedText&apos;;
import { ThemedView } from &apos;@/components/ThemedView&apos;;
import { IconSymbol } from &apos;@/components/ui/IconSymbol&apos;;
import { Colors } from &apos;@/constants/Colors&apos;;
import { useColorScheme } from &apos;@/hooks/useColorScheme&apos;;

export function Collapsible({ children, title }: PropsWithChildren &amp; { title: string }) {
  const [isOpen, setIsOpen] = useState(false);
  const theme = useColorScheme() ?? &apos;light&apos;;

  return (
    &lt;ThemedView&gt;
      &lt;TouchableOpacity
        style={styles.heading}
        onPress={() =&gt; setIsOpen((value) =&gt; !value)}
        activeOpacity={0.8}&gt;
        &lt;IconSymbol
          name=&quot;chevron.right&quot;
          size={18}
          weight=&quot;medium&quot;
          color={theme === &apos;light&apos; ? Colors.light.icon : Colors.dark.icon}
          style={{ transform: [{ rotate: isOpen ? &apos;90deg&apos; : &apos;0deg&apos; }] }}
        /&gt;

        &lt;ThemedText type=&quot;defaultSemiBold&quot;&gt;{title}&lt;/ThemedText&gt;
      &lt;/TouchableOpacity&gt;
      {isOpen &amp;&amp; &lt;ThemedView style={styles.content}&gt;{children}&lt;/ThemedView&gt;}
    &lt;/ThemedView&gt;
  );
}

const styles = StyleSheet.create({
  heading: {
    flexDirection: &apos;row&apos;,
    alignItems: &apos;center&apos;,
    gap: 6,
  },
  content: {
    marginTop: 6,
    marginLeft: 24,
  },
});</file><file path="components/ExternalLink.tsx">import { Link } from &apos;expo-router&apos;;
import { openBrowserAsync } from &apos;expo-web-browser&apos;;
import { type ComponentProps } from &apos;react&apos;;
import { Platform } from &apos;react-native&apos;;

type Props = Omit&lt;ComponentProps&lt;typeof Link&gt;, &apos;href&apos;&gt; &amp; { href: string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    &lt;Link
      target=&quot;_blank&quot;
      {...rest}
      href={href}
      onPress={async (event) =&gt; {
        if (Platform.OS !== &apos;web&apos;) {
          // Prevent the default behavior of linking to the default browser on native.
          event.preventDefault();
          // Open the link in an in-app browser.
          await openBrowserAsync(href);
        }
      }}
    /&gt;
  );
}</file><file path="components/HapticTab.tsx">import { BottomTabBarButtonProps } from &apos;@react-navigation/bottom-tabs&apos;;
import { PlatformPressable } from &apos;@react-navigation/elements&apos;;
import * as Haptics from &apos;expo-haptics&apos;;

export function HapticTab(props: BottomTabBarButtonProps) {
  return (
    &lt;PlatformPressable
      {...props}
      onPressIn={(ev) =&gt; {
        if (process.env.EXPO_OS === &apos;ios&apos;) {
          // Add a soft haptic feedback when pressing down on the tabs.
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        }
        props.onPressIn?.(ev);
      }}
    /&gt;
  );
}</file><file path="components/HelloWave.tsx">import { useEffect } from &apos;react&apos;;
import { StyleSheet } from &apos;react-native&apos;;
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withRepeat,
  withSequence,
} from &apos;react-native-reanimated&apos;;

import { ThemedText } from &apos;@/components/ThemedText&apos;;

export function HelloWave() {
  const rotationAnimation = useSharedValue(0);

  useEffect(() =&gt; {
    rotationAnimation.value = withRepeat(
      withSequence(withTiming(25, { duration: 150 }), withTiming(0, { duration: 150 })),
      4 // Run the animation 4 times
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() =&gt; ({
    transform: [{ rotate: `${rotationAnimation.value}deg` }],
  }));

  return (
    &lt;Animated.View style={animatedStyle}&gt;
      &lt;ThemedText style={styles.text}&gt;ðŸ‘‹&lt;/ThemedText&gt;
    &lt;/Animated.View&gt;
  );
}

const styles = StyleSheet.create({
  text: {
    fontSize: 28,
    lineHeight: 32,
    marginTop: -6,
  },
});</file><file path="components/KanbanBoard.tsx">import React from &apos;react&apos;;
import { View, Text } from &apos;react-native&apos;;
import { Card } from &apos;react-native-paper&apos;;
import { useTheme } from &apos;@/contexts/ThemeContext&apos;;
import { Task } from &apos;@/app/types&apos;;
import {formatDateTime } from &apos;@/utils/dateFormatters&apos;;
import styles from &apos;@/app/styles/global&apos;;

type TaskStatus = &apos;ToDo&apos; | &apos;InProgress&apos; | &apos;Done&apos;;

interface KanbanBoardProps {
  tasks: Task[];
}

export function KanbanBoard({ tasks }: KanbanBoardProps) {
  const { themeColor } = useTheme();
  
  // Initialize empty columns
  const groupedTasks: Record&lt;TaskStatus, Task[]&gt; = {
    ToDo: [],
    InProgress: [],
    Done: []
  };

  // Group tasks by status, handling undefined or invalid status
  (tasks || []).forEach(task =&gt; {
    const status = task.status as TaskStatus;
    if (status in groupedTasks) {
      groupedTasks[status].push(task);
    } else {
      groupedTasks.ToDo.push(task); // Default to ToDo if status is invalid
    }
  });

  return (
    &lt;View style={styles.kanbanContainer}&gt;
      {(Object.keys(groupedTasks) as TaskStatus[]).map((status) =&gt; (
        &lt;View key={status} style={styles.kanbanColumn}&gt;
          &lt;Text style={[styles.kanbanTitle, { color: &apos;white&apos; }]}&gt;
            {status.replace(/([A-Z])/g, &apos; $1&apos;).trim()}
          &lt;/Text&gt;
          {groupedTasks[status].map((task) =&gt; (
            &lt;Card 
              key={task.id} 
              style={[styles.kanbanTaskCard, { borderColor: themeColor, borderWidth: 1 }]}
            &gt;
              &lt;Text style={styles.kanbanTask}&gt;{task.title}&lt;/Text&gt;
              &lt;Text style={[styles.statusTimestamp]}&gt;
                {formatDateTime(task.scheduled_for, &apos;compact&apos;)}
              &lt;/Text&gt;
              {task.deadline &amp;&amp; (
                &lt;Text style={[styles.cardDetails, { color: &apos;#FF4444&apos;, fontSize: 12 }]}&gt;
                  {formatDateTime(task.deadline, &apos;deadline&apos;)}
                &lt;/Text&gt;
              )}
            &lt;/Card&gt;
          ))}
        &lt;/View&gt;
      ))}
    &lt;/View&gt;
  );
}</file><file path="components/layouts/DesktopLayout.tsx">import React, { useEffect } from &apos;react&apos;;
import { View, Text, TouchableOpacity } from &apos;react-native&apos;;
import { Card } from &apos;react-native-paper&apos;;
import { ChatInterface } from &apos;@/components/ChatInterface&apos;;
import { TaskList } from &apos;@/components/TaskList&apos;;
import { KanbanBoard } from &apos;@/components/KanbanBoard&apos;;
import { SettingsButton } from &apos;@/components/ui/SettingsButton&apos;;
import { LoadingSpinner } from &apos;@/components/ui/LoadingSpinner&apos;;
import { useChatData } from &apos;@/hooks/useChatData&apos;;
import { useQuests } from &apos;@/services/questsService&apos;;  // Updated import path
import { useTheme } from &apos;@/contexts/ThemeContext&apos;;
import { useRouter } from &apos;expo-router&apos;;
import styles from &apos;@/app/styles/global&apos;;
import { formatDateTime } from &apos;@/utils/dateFormatters&apos;;
import { useQuestUpdate } from &apos;@/contexts/QuestUpdateContext&apos;;

export function DesktopLayout() {
  const router = useRouter();
  const { themeColor } = useTheme();
  const { messages } = useChatData();
  const { mainQuest, loading, error, reload } = useQuests();  // Updated hook name and added reload
  const { shouldUpdate, resetUpdate } = useQuestUpdate();

  console.log(&quot;DesktopLayout mainQuest:&quot;, mainQuest); // Add log to check main quest

  // Simple mount-time load
  useEffect(() =&gt; {
    reload();
  }, []);

  // Add effect to check for updates
  useEffect(() =&gt; {
    if (shouldUpdate) {
      console.log(&apos;Update triggered, reloading quests&apos;);
      reload();
      resetUpdate();
    }
  }, [shouldUpdate]);

  const isDarkColor = (color: string) =&gt; {
    const hex = color.replace(&apos;#&apos;, &apos;&apos;);
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    return brightness &lt; 128;
  };

  const textColor = isDarkColor(themeColor) ? &apos;#fff&apos; : &apos;#000&apos;;

  return (
    &lt;View style={[styles.container, { backgroundColor: &apos;#181818&apos; }]}&gt; 
      &lt;View style={styles.column}&gt;
        &lt;Card style={[styles.mainQuestCard, { borderColor: themeColor, borderWidth: 2 }]}&gt; 
          {loading ? (
            &lt;LoadingSpinner /&gt;
          ) : error ? (
            &lt;Text style={[styles.errorText, { color: &apos;#FF4444&apos; }]}&gt;{error}&lt;/Text&gt;
          ) : !mainQuest ? (
            &lt;View&gt;
              &lt;Text style={styles.mainQuestTitle}&gt;No main quest selected&lt;/Text&gt;
              &lt;TouchableOpacity 
                onPress={() =&gt; router.push(&apos;/quests&apos;)}
                style={[styles.viewAllQuests, { backgroundColor: themeColor }]}
              &gt;
                &lt;Text style={[styles.viewAllQuestsText, { color: textColor }]}&gt;
                  Select Main Quest
                &lt;/Text&gt;
              &lt;/TouchableOpacity&gt;
            &lt;/View&gt;
          ) : (
            &lt;&gt;
              &lt;Text style={styles.mainQuestTitle}&gt;{mainQuest.title}&lt;/Text&gt;
              {mainQuest.start_date &amp;&amp; (
                &lt;Text style={[styles.cardDetails, { color: &apos;#AAA&apos; }]}&gt;
                  Started: {formatDateTime(mainQuest.start_date)}
                &lt;/Text&gt;
              )}
              {mainQuest.end_date &amp;&amp; (
                &lt;Text style={[styles.cardDetails, { color: &apos;#AAA&apos; }]}&gt;
                  Target completion: {formatDateTime(mainQuest.end_date)}
                &lt;/Text&gt;
              )}
              &lt;TouchableOpacity 
                onPress={() =&gt; router.push(&apos;/quests&apos;)}
                style={[styles.viewAllQuests, { backgroundColor: themeColor }]}
              &gt;
                &lt;Text style={[styles.viewAllQuestsText, { color: textColor }]}&gt;
                  View All Quests
                &lt;/Text&gt;
              &lt;/TouchableOpacity&gt;
              &lt;KanbanBoard tasks={mainQuest.tasks || []} /&gt;
            &lt;/&gt;
          )}
        &lt;/Card&gt;
      &lt;/View&gt;

      &lt;View style={styles.column}&gt;
        &lt;ChatInterface themeColor={themeColor} recentMessages={messages} /&gt;
      &lt;/View&gt;
      
      &lt;TaskList /&gt;
      &lt;SettingsButton /&gt;
    &lt;/View&gt;
  );
}</file><file path="components/layouts/MobileLayout.tsx">import React from &apos;react&apos;;
import { View, Text } from &apos;react-native&apos;;
import { SafeAreaView } from &apos;react-native-safe-area-context&apos;; // Install if needed
import { ChatInterface } from &apos;@/components/ChatInterface&apos;;
import { HamburgerMenu } from &apos;@/components/ui/HamburgerMenu&apos;;
import { useChatData } from &apos;@/hooks/useChatData&apos;;
import styles from &apos;@/app/styles/global&apos;;

const MobileNavigation: React.FC = () =&gt; (
  &lt;View style={styles.mobileNavigation}&gt;
    &lt;HamburgerMenu /&gt;
  &lt;/View&gt;
);

export function MobileLayout() {
  const { messages, themeColor } = useChatData();

  return (
    &lt;SafeAreaView style={{ flex: 1, backgroundColor: &apos;#181818&apos; }}&gt;
      &lt;View style={styles.mobileHeader}&gt;
        &lt;Text style={styles.mobileHeaderText}&gt;QuestLog&lt;/Text&gt;
      &lt;/View&gt;
      
      &lt;View style={styles.mobileContent}&gt;
        &lt;ChatInterface 
          themeColor={themeColor} 
          recentMessages={messages}
        /&gt;
      &lt;/View&gt;
      
      &lt;MobileNavigation /&gt;
    &lt;/SafeAreaView&gt;
  );
}</file><file path="components/ParallaxScrollView.tsx">import type { PropsWithChildren, ReactElement } from &apos;react&apos;;
import { StyleSheet } from &apos;react-native&apos;;
import Animated, {
  interpolate,
  useAnimatedRef,
  useAnimatedStyle,
  useScrollViewOffset,
} from &apos;react-native-reanimated&apos;;

import { ThemedView } from &apos;@/components/ThemedView&apos;;
import { useBottomTabOverflow } from &apos;@/components/ui/TabBarBackground&apos;;
import { useThemeColor } from &apos;@/hooks/useThemeColor&apos;;

const HEADER_HEIGHT = 250;

type Props = PropsWithChildren&lt;{
  headerImage: ReactElement;
  headerBackgroundColor: { dark: string; light: string };
}&gt;;

export default function ParallaxScrollView({
  children,
  headerImage,
  headerBackgroundColor,
}: Props) {
  const colorScheme = useThemeColor({ light: &apos;light&apos;, dark: &apos;dark&apos; }, &apos;background&apos;) as &apos;dark&apos; | &apos;light&apos;;
  const scrollRef = useAnimatedRef&lt;Animated.ScrollView&gt;();
  const scrollOffset = useScrollViewOffset(scrollRef);
  const bottom = useBottomTabOverflow();
  const headerAnimatedStyle = useAnimatedStyle(() =&gt; {
    return {
      transform: [
        {
          translateY: interpolate(
            scrollOffset.value,
            [-HEADER_HEIGHT, 0, HEADER_HEIGHT],
            [-HEADER_HEIGHT / 2, 0, HEADER_HEIGHT * 0.75]
          ),
        },
        {
          scale: interpolate(scrollOffset.value, [-HEADER_HEIGHT, 0, HEADER_HEIGHT], [2, 1, 1]),
        },
      ],
    };
  });

  return (
    &lt;ThemedView style={styles.container}&gt;
      &lt;Animated.ScrollView
        ref={scrollRef}
        scrollEventThrottle={16}
        scrollIndicatorInsets={{ bottom }}
        contentContainerStyle={{ paddingBottom: bottom }}&gt;
        &lt;Animated.View
          style={[
            styles.header,
            { backgroundColor: headerBackgroundColor[colorScheme] },
            headerAnimatedStyle,
          ]}&gt;
          {headerImage}
        &lt;/Animated.View&gt;
        &lt;ThemedView style={styles.content}&gt;{children}&lt;/ThemedView&gt;
      &lt;/Animated.ScrollView&gt;
    &lt;/ThemedView&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    height: HEADER_HEIGHT,
    overflow: &apos;hidden&apos;,
  },
  content: {
    flex: 1,
    padding: 32,
    gap: 16,
    overflow: &apos;hidden&apos;,
  },
});</file><file path="components/QuestsOverview.tsx">import React, { useState } from &apos;react&apos;;
import { View, Text, TouchableOpacity, FlatList, ScrollView, Dimensions } from &apos;react-native&apos;;
import { Card } from &apos;react-native-paper&apos;;
import { useTheme } from &apos;@/contexts/ThemeContext&apos;;
import styles from &apos;@/app/styles/global&apos;;
import { useQuests } from &apos;@/services/questsService&apos;;
import { Quest } from &apos;@/app/types&apos;;

type QuestStatus = &apos;Active&apos; | &apos;On-Hold&apos; | &apos;Completed&apos;;

interface QuestsOverviewProps {
  quests: Quest[];
  onSelectQuest: (questId: number) =&gt; void;
  currentMainQuest: Quest | null;
}

export function QuestsOverview({ quests, onSelectQuest, currentMainQuest }: QuestsOverviewProps) {
  const { themeColor } = useTheme();
  const [activeTab, setActiveTab] = useState&lt;QuestStatus&gt;(&apos;Active&apos;);
  const [selectedQuest, setSelectedQuest] = useState&lt;Quest | null&gt;(null);
  const windowHeight = Dimensions.get(&apos;window&apos;).height;

  const filteredQuests = quests.filter(q =&gt; q.status === activeTab);

  const tabs: QuestStatus[] = [&apos;Active&apos;, &apos;On-Hold&apos;, &apos;Completed&apos;];

  const getQuestCardColor = (quest: Quest) =&gt; {
    if (quest.is_main) {  // Changed from isMain
      // Create a less saturated version of themeColor
      const hex = themeColor.replace(&apos;#&apos;, &apos;&apos;);
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);
      const desaturate = 0.5; // 50% desaturation
      const gray = (r + g + b) / 3;
      const newR = Math.round(r * (1 - desaturate) + gray * desaturate);
      const newG = Math.round(g * (1 - desaturate) + gray * desaturate);
      const newB = Math.round(b * (1 - desaturate) + gray * desaturate);
      return `#${newR.toString(16).padStart(2, &apos;0&apos;)}${newG.toString(16).padStart(2, &apos;0&apos;)}${newB.toString(16).padStart(2, &apos;0&apos;)}`;
    }
    return themeColor;
  };

  return (
    &lt;View style={[styles.container, { backgroundColor: &apos;#181818&apos;, height: windowHeight }]}&gt;
      &lt;View style={styles.column}&gt;
        &lt;Card style={[styles.mainQuestCard, { borderColor: themeColor, borderWidth: 2, height: windowHeight * 0.95 }]}&gt;
          &lt;View style={{ flexDirection: &apos;row&apos;, marginBottom: 20 }}&gt;
            {tabs.map(tab =&gt; (
              &lt;TouchableOpacity 
                key={tab} 
                onPress={() =&gt; setActiveTab(tab)}
                style={[
                  styles.toggleButton,
                  { 
                    backgroundColor: activeTab === tab ? themeColor : &apos;#333&apos;,
                    marginRight: 10,
                    flex: 1
                  }
                ]}
              &gt;
                &lt;Text style={[
                  styles.toggleButtonText,
                  { color: activeTab === tab ? &apos;#fff&apos; : &apos;#aaa&apos; }
                ]}&gt;
                  {tab}
                &lt;/Text&gt;
              &lt;/TouchableOpacity&gt;
            ))}
          &lt;/View&gt;

          &lt;View style={{ flexDirection: &apos;row&apos;, flex: 1 }}&gt;
            &lt;View style={{ flex: 1, marginRight: 20, maxHeight: windowHeight * 0.8 }}&gt;
              &lt;FlatList
                style={{ flex: 1 }}
                data={filteredQuests}
                keyExtractor={(item) =&gt; item.id.toString()}
                renderItem={({ item }) =&gt; (
                  &lt;TouchableOpacity onPress={() =&gt; setSelectedQuest(item)}&gt;
                    &lt;Card style={[
                      styles.taskCard,
                      { 
                        borderColor: item.is_main ? getQuestCardColor(item) : themeColor,  // Changed from isMain
                        borderWidth: item.is_main ? 3 : selectedQuest?.id === item.id ? 2 : 0,  // Changed from isMain
                        backgroundColor: item.is_main ? `${getQuestCardColor(item)}22` : &apos;#444&apos;,  // Changed from isMain
                        // Add shadow for main quest
                        ...(item.is_main &amp;&amp; {  // Changed from isMain
                          shadowColor: getQuestCardColor(item),
                          shadowOffset: { width: 0, height: 0 },
                          shadowOpacity: 0.5,
                          shadowRadius: 8,
                          elevation: 6,
                        })
                      }
                    ]}&gt;
                      &lt;Text style={styles.cardTitle}&gt;{item.title}&lt;/Text&gt;
                    &lt;/Card&gt;
                  &lt;/TouchableOpacity&gt;
                )}
              /&gt;
            &lt;/View&gt;

            &lt;View style={{ flex: 1, maxHeight: windowHeight * 0.8 }}&gt;
              {selectedQuest ? (
                &lt;ScrollView style={{ flex: 1 }} bounces={false}&gt;
                  &lt;Card style={[styles.mainQuestCard, { 
                    borderColor: themeColor, 
                    borderWidth: 2 
                  }]}&gt;
                    &lt;View style={{ flexDirection: &apos;row&apos;, justifyContent: &apos;space-between&apos;, alignItems: &apos;center&apos; }}&gt;
                      &lt;Text style={styles.mainQuestTitle}&gt;{selectedQuest.title}&lt;/Text&gt;
                      &lt;TouchableOpacity 
                        onPress={() =&gt; onSelectQuest(selectedQuest.id)}
                        style={[
                          styles.setMainQuestButton,
                          { 
                            backgroundColor: selectedQuest.id === currentMainQuest?.id ? &apos;#666&apos; : themeColor,
                            opacity: selectedQuest.id === currentMainQuest?.id ? 0.7 : 1
                          }
                        ]}
                      &gt;
                        &lt;Text style={styles.setMainQuestButtonText}&gt;
                          {selectedQuest.id === currentMainQuest?.id ? &apos;Main Quest&apos; : &apos;Set as Main Quest&apos;}
                        &lt;/Text&gt;
                      &lt;/TouchableOpacity&gt;
                    &lt;/View&gt;
                    &lt;Text style={styles.cardDetails}&gt;{selectedQuest.tagline}&lt;/Text&gt;
                    
                    {selectedQuest?.currentStatus ? (
                      &lt;Card style={[styles.taskCard, { borderColor: themeColor, borderWidth: 1 }]}&gt;
                        &lt;Text style={styles.statusTimestamp}&gt;
                          [{selectedQuest.currentStatus.timestamp}]
                        &lt;/Text&gt;
                        &lt;Text style={styles.cardDetails}&gt;
                          {selectedQuest.currentStatus.message}
                        &lt;/Text&gt;
                      &lt;/Card&gt;
                    ) : (
                      &lt;Card style={[styles.taskCard, { borderColor: themeColor, borderWidth: 1 }]}&gt;
                        &lt;Text style={styles.cardDetails}&gt;No current status&lt;/Text&gt;
                      &lt;/Card&gt;
                    )}

                    &lt;Card style={[styles.taskCard, { borderColor: themeColor, borderWidth: 1 }]}&gt;
                      &lt;Text style={styles.cardDetails}&gt;{selectedQuest.questStatus}&lt;/Text&gt;
                    &lt;/Card&gt;
                    
                    &lt;View style={styles.questTasksContainer}&gt;
                      &lt;Text style={[styles.cardTitle, { marginTop: 10 }]}&gt;
                        Current Tasks ({selectedQuest.tasks?.length || 0})
                      &lt;/Text&gt;
                      {selectedQuest.tasks?.map((task) =&gt; (
                        &lt;Card 
                          key={task.id} 
                          style={[styles.taskCard, { borderColor: themeColor, borderWidth: 1 }]}
                        &gt;
                          &lt;Text style={styles.cardTitle}&gt;{task.title}&lt;/Text&gt;
                          &lt;Text style={styles.cardDetails}&gt;
                            Start: {task.scheduled_for} ({task.location})
                          &lt;/Text&gt;
                          {task.deadline &amp;&amp; (
                            &lt;Text style={[styles.cardDetails, { color: &apos;#FF4444&apos; }]}&gt;
                              Deadline: {task.deadline}
                            &lt;/Text&gt;
                          )}
                        &lt;/Card&gt;
                      ))}
                    &lt;/View&gt;
                  &lt;/Card&gt;
                &lt;/ScrollView&gt;
              ) : (
                &lt;Card style={[styles.mainQuestCard, { borderColor: themeColor, borderWidth: 2 }]}&gt;
                  &lt;Text style={styles.cardDetails}&gt;Select a quest to view details&lt;/Text&gt;
                &lt;/Card&gt;
              )}
            &lt;/View&gt;
          &lt;/View&gt;
        &lt;/Card&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  );
}</file><file path="components/TaskList.tsx">import React from &apos;react&apos;;
import { View, Text, FlatList, TouchableOpacity } from &apos;react-native&apos;;
import { Card } from &apos;react-native-paper&apos;;
import Animated from &apos;react-native-reanimated&apos;;
import { useTasks } from &apos;@/services/tasksService&apos;;
import { useTheme } from &apos;@/contexts/ThemeContext&apos;;
import { LoadingSpinner } from &apos;./ui/LoadingSpinner&apos;;
import { formatDateTime } from &apos;@/utils/dateFormatters&apos;;
import styles from &apos;@/app/styles/global&apos;;

export function TaskList() {
  const { themeColor } = useTheme();
  const { tasks, taskListVisible, animatedHeight, toggleTaskList, loading, error } = useTasks();

  if (loading) return &lt;LoadingSpinner /&gt;;
  if (error) return &lt;Text style={{ color: &apos;red&apos; }}&gt;{error}&lt;/Text&gt;;
  if (!tasks.length) return null;

  const isDarkColor = (color: string) =&gt; {
    const hex = color.replace(&apos;#&apos;, &apos;&apos;);
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    return brightness &lt; 128;
  };

  const textColor = isDarkColor(themeColor) ? &apos;#fff&apos; : &apos;#000&apos;;

  return (
    &lt;View style={styles.column}&gt;
      &lt;TouchableOpacity 
        onPress={toggleTaskList} 
        style={[styles.toggleButton, { backgroundColor: themeColor }]}&gt;
        &lt;Text style={[styles.toggleButtonText, { color: textColor }]}&gt;
          {taskListVisible ? &quot;Hide Tasks&quot; : &quot;Show Upcoming Tasks&quot;}
        &lt;/Text&gt;
      &lt;/TouchableOpacity&gt;
      
      &lt;Animated.View style={[
        styles.taskContainer,
        {
          maxHeight: animatedHeight.interpolate({
            inputRange: [0, 1],
            outputRange: [&apos;0%&apos;, &apos;100%&apos;]
          }),
          opacity: animatedHeight
        }
      ]}&gt;
        &lt;FlatList
          data={tasks}
          keyExtractor={(item) =&gt; item.id.toString()}
          renderItem={({ item }) =&gt; (
            &lt;Card style={[styles.taskCard, { borderColor: themeColor, borderWidth: 2 }]}&gt; 
              &lt;Text style={styles.cardTitle}&gt;{item.title}&lt;/Text&gt;
              &lt;Text style={styles.cardDetails}&gt;
                Start: {formatDateTime(item.scheduled_for)} ({item.location})
              &lt;/Text&gt;
              {item.deadline &amp;&amp; (
                &lt;Text style={[styles.cardDetails, { color: &apos;#FF4444&apos; }]}&gt;
                  {formatDateTime(item.deadline, &apos;deadline&apos;)}
                &lt;/Text&gt;
              )}
              &lt;Text style={styles.cardQuest}&gt;
                Quest: {item.quest?.title || &apos;No Quest Assigned&apos;}
              &lt;/Text&gt;
            &lt;/Card&gt;
          )}
        /&gt;
      &lt;/Animated.View&gt;
    &lt;/View&gt;
  );
}</file><file path="components/ThemedText.tsx">import { Text, type TextProps, StyleSheet } from &apos;react-native&apos;;

import { useThemeColor } from &apos;@/hooks/useThemeColor&apos;;

export type ThemedTextProps = TextProps &amp; {
  lightColor?: string;
  darkColor?: string;
  type?: &apos;default&apos; | &apos;title&apos; | &apos;defaultSemiBold&apos; | &apos;subtitle&apos; | &apos;link&apos;;
};

export function ThemedText({
  style,
  lightColor,
  darkColor,
  type = &apos;default&apos;,
  ...rest
}: ThemedTextProps) {
  const color = useThemeColor({ light: lightColor, dark: darkColor }, &apos;text&apos;);

  return (
    &lt;Text
      style={[
        { color },
        type === &apos;default&apos; ? styles.default : undefined,
        type === &apos;title&apos; ? styles.title : undefined,
        type === &apos;defaultSemiBold&apos; ? styles.defaultSemiBold : undefined,
        type === &apos;subtitle&apos; ? styles.subtitle : undefined,
        type === &apos;link&apos; ? styles.link : undefined,
        style,
      ]}
      {...rest}
    /&gt;
  );
}

const styles = StyleSheet.create({
  default: {
    fontSize: 16,
    lineHeight: 24,
  },
  defaultSemiBold: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: &apos;600&apos;,
  },
  title: {
    fontSize: 32,
    fontWeight: &apos;bold&apos;,
    lineHeight: 32,
  },
  subtitle: {
    fontSize: 20,
    fontWeight: &apos;bold&apos;,
  },
  link: {
    lineHeight: 30,
    fontSize: 16,
    color: &apos;#0a7ea4&apos;,
  },
});</file><file path="components/ThemedView.tsx">import { View, type ViewProps } from &apos;react-native&apos;;

import { useThemeColor } from &apos;@/hooks/useThemeColor&apos;;

export type ThemedViewProps = ViewProps &amp; {
  lightColor?: string;
  darkColor?: string;
};

export function ThemedView({ style, lightColor, darkColor, ...otherProps }: ThemedViewProps) {
  const backgroundColor = useThemeColor({ light: lightColor, dark: darkColor }, &apos;background&apos;);

  return &lt;View style={[{ backgroundColor }, style]} {...otherProps} /&gt;;
}</file><file path="components/ui/HamburgerMenu.tsx">import { router } from &apos;expo-router&apos;;
import React, { useState } from &apos;react&apos;;
import { Pressable, StyleSheet, Text, View, Platform, useWindowDimensions, ViewStyle } from &apos;react-native&apos;;
import Animated, { 
  useAnimatedStyle, 
  withSpring,
  useSharedValue,
  withTiming,
  Easing
} from &apos;react-native-reanimated&apos;;

import { IconSymbol } from &apos;./IconSymbol&apos;;
import { Colors } from &apos;@/constants/Colors&apos;;
import { useThemeColor } from &apos;@/hooks/useThemeColor&apos;;
import { useTheme } from &apos;@/contexts/ThemeContext&apos;;

const MENU_ITEMS = [
  { name: &apos;Notifications&apos;, icon: &apos;bell.fill&apos;, route: &apos;/notification&apos; },
  { name: &apos;Quests&apos;, icon: &apos;flag&apos;, route: &apos;/quests&apos; },
  { name: &apos;Tasks&apos;, icon: &apos;list.bullet&apos;, route: &apos;*/app/tasks&apos; },
  { name: &apos;Routine&apos;, icon: &apos;clock&apos;, route: &apos;*/app/routine&apos; },
  { name: &apos;Journal&apos;, icon: &apos;book&apos;, route: &apos;*/app/journal&apos; },
  { name: &apos;Profile&apos;, icon: &apos;person&apos;, route: &apos;*/app/profile&apos; },
  { name: &apos;Settings&apos;, icon: &apos;gear&apos;, route: &apos;*/app/settings&apos; },
] as const;

export function HamburgerMenu() {
  const { width } = useWindowDimensions();
  const isMobile = Platform.OS === &apos;ios&apos; || Platform.OS === &apos;android&apos; || width &lt; 768;
  const [isOpen, setIsOpen] = useState(false);
  const menuAnimation = useSharedValue(0);
  const { themeColor } = useTheme(); // Fix: correctly destructure from useTheme

  const menuStyle = useAnimatedStyle(() =&gt; ({
    opacity: withTiming(menuAnimation.value, {
      duration: 200,
      easing: Easing.bezier(0.25, 0.1, 0.25, 1),
    }),
    transform: [
      { 
        translateY: withSpring(menuAnimation.value * -500, { // Increased from -300
          damping: 15,
          stiffness: 100,
        })
      }
    ],
  }));

  const toggleMenu = () =&gt; {
    setIsOpen(!isOpen);
    menuAnimation.value = isOpen ? 0 : 1;
  };

  const buttonStyle = (pressed: boolean): ViewStyle =&gt; ({
    ...styles.hamburgerButton,
    ...(isMobile &amp;&amp; styles.hamburgerButtonMobile),
    ...(pressed &amp;&amp; styles.hamburgerButtonPressed),
    backgroundColor: themeColor,
    shadowColor: themeColor,
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.5,
    shadowRadius: 8,
  });

  return (
    &lt;View style={[
      styles.container,
      isMobile &amp;&amp; styles.containerMobile
    ]}&gt;
      &lt;Pressable 
        onPress={toggleMenu} 
        style={({ pressed }) =&gt; buttonStyle(pressed)}&gt;
        &lt;IconSymbol 
          name={isOpen ? &quot;xmark&quot; : &quot;line.3.horizontal&quot;} 
          size={24} 
          color=&quot;#fff&quot; 
        /&gt;
      &lt;/Pressable&gt;

      {isOpen &amp;&amp; (
        &lt;Animated.View 
          pointerEvents=&quot;box-none&quot;
          style={[
            styles.menu,
            isMobile &amp;&amp; styles.menuMobile,
            menuStyle
          ]}&gt;
          {MENU_ITEMS.map((item) =&gt; (
            &lt;Pressable
              key={item.name}
              style={({ pressed }) =&gt; [
                styles.menuItem,
                pressed &amp;&amp; styles.menuItemPressed
              ]}
              onPress={() =&gt; {
                router.push(item.route as any);
                toggleMenu();
              }}&gt;
              &lt;IconSymbol name={item.icon} size={20} color=&quot;#fff&quot; /&gt;
              &lt;Text style={styles.menuText}&gt;{item.name}&lt;/Text&gt;
            &lt;/Pressable&gt;
          ))}
        &lt;/Animated.View&gt;
      )}
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    position: &apos;absolute&apos;,
    right: 20,
    top: 20,
    zIndex: 1000,
  },
  menu: {
    position: &apos;absolute&apos;,
    top: 60,
    right: 0,
    backgroundColor: Colors.light.background,
    borderRadius: 16,
    padding: 8,
    minWidth: 180,
    shadowColor: &apos;#000&apos;,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 12,
    elevation: 8,
  },
  menuItem: {
    flexDirection: &apos;row&apos;,
    alignItems: &apos;center&apos;,
    padding: 12,
    borderRadius: 8,
    marginVertical: 4,
    backgroundColor: &apos;#333&apos;,
  },
  menuItemPressed: {
    backgroundColor: &apos;#444&apos;,
  },
  menuText: {
    marginLeft: 12,
    fontSize: 16,
    color: &apos;#fff&apos;,
    fontWeight: &apos;500&apos;,
  },
  containerMobile: {
    position: &apos;relative&apos;,
    right: 0,
    width: 60,
    height: 40,
    justifyContent: &apos;center&apos;,
    alignItems: &apos;center&apos;,
    zIndex: 1000,
  },
  menuMobile: {
    position: &apos;absolute&apos;,
    bottom: 120, // Increased from 60
    right: -70, // Centers the 200px wide menu relative to the 60px wide container
    backgroundColor: &apos;#222&apos;,
    borderColor: &apos;#333&apos;,
    borderWidth: 1,
    width: 200,
    minHeight: 280,
    padding: 8,
    borderRadius: 12,
    zIndex: 2000,
  },
  hamburgerButton: {
    width: 48,
    height: 48,
    borderRadius: 24,
    justifyContent: &apos;center&apos;,
    alignItems: &apos;center&apos;,
    elevation: 5,
  },
  hamburgerButtonMobile: {
    width: 40,
    height: 40,
    backgroundColor: &apos;transparent&apos;,
    shadowOpacity: 0,
  },
  hamburgerButtonPressed: {
    opacity: 0.8,
    transform: [{ scale: 0.97 }],
  },
});</file><file path="components/ui/IconSymbol.ios.tsx">import { SymbolView, SymbolViewProps, SymbolWeight } from &apos;expo-symbols&apos;;
import { StyleProp, ViewStyle } from &apos;react-native&apos;;

export function IconSymbol({
  name,
  size = 24,
  color,
  style,
  weight = &apos;regular&apos;,
}: {
  name: SymbolViewProps[&apos;name&apos;];
  size?: number;
  color: string;
  style?: StyleProp&lt;ViewStyle&gt;;
  weight?: SymbolWeight;
}) {
  return (
    &lt;SymbolView
      weight={weight}
      tintColor={color}
      resizeMode=&quot;scaleAspectFit&quot;
      name={name}
      style={[
        {
          width: size,
          height: size,
        },
        style,
      ]}
    /&gt;
  );
}</file><file path="components/ui/IconSymbol.tsx">// This file is a fallback for using MaterialIcons on Android and web.

import MaterialIcons from &apos;@expo/vector-icons/MaterialIcons&apos;;
import { SymbolWeight } from &apos;expo-symbols&apos;;
import React from &apos;react&apos;;
import { OpaqueColorValue, StyleProp, ViewStyle } from &apos;react-native&apos;;

// Add your SFSymbol to MaterialIcons mappings here.
const MAPPING = {
  // See MaterialIcons here: https://icons.expo.fyi
  // See SF Symbols in the SF Symbols app on Mac.
  &apos;house.fill&apos;: &apos;home&apos;,
  &apos;paperplane.fill&apos;: &apos;send&apos;,
  &apos;chevron.left.forwardslash.chevron.right&apos;: &apos;code&apos;,
  &apos;chevron.right&apos;: &apos;chevron-right&apos;,
} as Partial&lt;
  Record&lt;
    import(&apos;expo-symbols&apos;).SymbolViewProps[&apos;name&apos;],
    React.ComponentProps&lt;typeof MaterialIcons&gt;[&apos;name&apos;]
  &gt;
&gt;;

export type IconSymbolName = keyof typeof MAPPING;

/**
 * An icon component that uses native SFSymbols on iOS, and MaterialIcons on Android and web. This ensures a consistent look across platforms, and optimal resource usage.
 *
 * Icon `name`s are based on SFSymbols and require manual mapping to MaterialIcons.
 */
export function IconSymbol({
  name,
  size = 24,
  color,
  style,
}: {
  name: IconSymbolName;
  size?: number;
  color: string | OpaqueColorValue;
  style?: StyleProp&lt;ViewStyle&gt;;
  weight?: SymbolWeight;
}) {
  return &lt;MaterialIcons color={color} size={size} name={MAPPING[name]} style={style} /&gt;;
}</file><file path="components/ui/LoadingSpinner.tsx">import React from &apos;react&apos;;
import { View, ActivityIndicator } from &apos;react-native&apos;;
import { useTheme } from &apos;@/contexts/ThemeContext&apos;;

export function LoadingSpinner() {
  const { themeColor } = useTheme();
  
  return (
    &lt;View style={{ flex: 1, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos; }}&gt;
      &lt;ActivityIndicator size=&quot;large&quot; color={themeColor} /&gt;
    &lt;/View&gt;
  );
}</file><file path="components/ui/SettingsButton.tsx">import React, { useState } from &apos;react&apos;;
import { View, Pressable, Text, StyleSheet, Modal } from &apos;react-native&apos;;
import ColorPicker from &apos;react-native-wheel-color-picker&apos;;
import { Ionicons } from &apos;@expo/vector-icons&apos;;
import { useTheme } from &apos;@/contexts/ThemeContext&apos;;

export function SettingsButton() {
  const [isOpen, setIsOpen] = useState(false);
  const { themeColor, setThemeColor } = useTheme();

  const isDarkColor = (color: string) =&gt; {
    const hex = color.replace(&apos;#&apos;, &apos;&apos;);
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    return brightness &lt; 128;
  };

  const textColor = isDarkColor(themeColor) ? &apos;#fff&apos; : &apos;#000&apos;;

  return (
    &lt;View style={styles.container}&gt;
      &lt;Pressable
        onPress={() =&gt; setIsOpen(!isOpen)}
        style={({ pressed }) =&gt; [
          styles.button,
          { backgroundColor: themeColor },
          pressed &amp;&amp; styles.pressed
        ]}&gt;
        &lt;Ionicons
          name=&quot;settings&quot;
          size={24}
          color={textColor}
        /&gt;
      &lt;/Pressable&gt;
      
      &lt;Modal
        visible={isOpen}
        transparent={true}
        animationType=&quot;fade&quot;
        onRequestClose={() =&gt; setIsOpen(false)}
      &gt;
        &lt;Pressable 
          style={styles.modalOverlay}
          onPress={() =&gt; setIsOpen(false)}
        &gt;
          &lt;View 
            style={styles.popup}
            onStartShouldSetResponder={() =&gt; true}
            onTouchEnd={e =&gt; e.stopPropagation()}
          &gt;
            &lt;Text style={[styles.label, { color: textColor }]}&gt;Theme Color&lt;/Text&gt;
            &lt;View style={styles.pickerContainer}&gt;
              &lt;ColorPicker
                color={themeColor}
                onColorChange={setThemeColor}
                thumbSize={30}
                sliderSize={20}
                noSnap={true}
                row={false}
              /&gt;
            &lt;/View&gt;
            &lt;View style={styles.currentColor}&gt;
              &lt;Text style={[styles.colorText, { color: textColor }]}&gt;Current: {themeColor}&lt;/Text&gt;
              &lt;View style={[styles.colorPreview, { backgroundColor: themeColor }]} /&gt;
            &lt;/View&gt;
          &lt;/View&gt;
        &lt;/Pressable&gt;
      &lt;/Modal&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    position: &apos;absolute&apos;,
    left: 20,
    bottom: 20,
    zIndex: 1000,
  },
  button: {
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: &apos;#333&apos;,
    justifyContent: &apos;center&apos;,
    alignItems: &apos;center&apos;,
    shadowColor: &apos;#000&apos;,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 3.84,
    elevation: 5,
  },
  pressed: {
    opacity: 0.8,
    transform: [{ scale: 0.97 }],
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: &apos;rgba(0, 0, 0, 0.5)&apos;,
    justifyContent: &apos;center&apos;,
    alignItems: &apos;center&apos;,
  },
  popup: {
    backgroundColor: &apos;#222&apos;,
    padding: 20,
    borderRadius: 16,
    width: 300,
    shadowColor: &apos;#000&apos;,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 12,
    elevation: 8,
  },
  label: {
    color: &apos;#fff&apos;,
    marginBottom: 16,
    fontSize: 16,
    fontWeight: &apos;500&apos;,
  },
  pickerContainer: {
    height: 300,
    marginBottom: 16,
  },
  currentColor: {
    flexDirection: &apos;row&apos;,
    alignItems: &apos;center&apos;,
    justifyContent: &apos;space-between&apos;,
  },
  colorText: {
    color: &apos;#fff&apos;,
    fontSize: 14,
  },
  colorPreview: {
    width: 30,
    height: 30,
    borderRadius: 15,
    borderWidth: 2,
    borderColor: &apos;#444&apos;,
  },
});</file><file path="components/ui/TabBarBackground.ios.tsx">import { useBottomTabBarHeight } from &apos;@react-navigation/bottom-tabs&apos;;
import { BlurView } from &apos;expo-blur&apos;;
import { StyleSheet } from &apos;react-native&apos;;
import { useSafeAreaInsets } from &apos;react-native-safe-area-context&apos;;

export default function BlurTabBarBackground() {
  return (
    &lt;BlurView
      // System chrome material automatically adapts to the system&apos;s theme
      // and matches the native tab bar appearance on iOS.
      tint=&quot;systemChromeMaterial&quot;
      intensity={100}
      style={StyleSheet.absoluteFill}
    /&gt;
  );
}

export function useBottomTabOverflow() {
  const tabHeight = useBottomTabBarHeight();
  const { bottom } = useSafeAreaInsets();
  return tabHeight - bottom;
}</file><file path="components/ui/TabBarBackground.tsx">// This is a shim for web and Android where the tab bar is generally opaque.
export default undefined;

export function useBottomTabOverflow() {
  return 0;
}</file><file path="constants/Colors.ts">/**
 * Below are the colors that are used in the app. The colors are defined in the light and dark mode.
 * There are many other ways to style your app. For example, [Nativewind](https://www.nativewind.dev/), [Tamagui](https://tamagui.dev/), [unistyles](https://reactnativeunistyles.vercel.app), etc.
 */

const tintColorLight = &apos;#0a7ea4&apos;;
const tintColorDark = &apos;#fff&apos;;

export const Colors = {
  light: {
    text: &apos;#11181C&apos;,
    background: &apos;#fff&apos;,
    tint: tintColorLight,
    icon: &apos;#687076&apos;,
    tabIconDefault: &apos;#687076&apos;,
    tabIconSelected: tintColorLight,
  },
  dark: {
    text: &apos;#ECEDEE&apos;,
    background: &apos;#151718&apos;,
    tint: tintColorDark,
    icon: &apos;#9BA1A6&apos;,
    tabIconDefault: &apos;#9BA1A6&apos;,
    tabIconSelected: tintColorDark,
  },
};</file><file path="contexts/QuestUpdateContext.tsx">import React, { createContext, useContext, useState } from &apos;react&apos;;

interface QuestUpdateContextType {
  triggerUpdate: () =&gt; void;
  shouldUpdate: boolean;
  resetUpdate: () =&gt; void;
}

const QuestUpdateContext = createContext&lt;QuestUpdateContextType | undefined&gt;(undefined);

export function QuestUpdateProvider({ children }: { children: React.ReactNode }) {
  const [shouldUpdate, setShouldUpdate] = useState(false);

  const triggerUpdate = () =&gt; setShouldUpdate(true);
  const resetUpdate = () =&gt; setShouldUpdate(false);

  return (
    &lt;QuestUpdateContext.Provider value={{ triggerUpdate, shouldUpdate, resetUpdate }}&gt;
      {children}
    &lt;/QuestUpdateContext.Provider&gt;
  );
}

export const useQuestUpdate = () =&gt; {
  const context = useContext(QuestUpdateContext);
  if (!context) throw new Error(&apos;useQuestUpdate must be used within QuestUpdateProvider&apos;);
  return context;
};</file><file path="contexts/SupabaseContext.tsx">import React, { createContext, useContext, useEffect, useState } from &apos;react&apos;;
import { Session } from &apos;@supabase/supabase-js&apos;;
import { supabase } from &apos;@/lib/supabase&apos;;

interface SupabaseContextType {
  session: Session | null;
  isLoading: boolean;
}

const SupabaseContext = createContext&lt;SupabaseContextType&gt;({
  session: null,
  isLoading: true,
});

export function SupabaseProvider({ children }: { children: React.ReactNode }) {
  const [session, setSession] = useState&lt;Session | null&gt;(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() =&gt; {
    // Initialize session
    supabase.auth.getSession().then(({ data: { session } }) =&gt; {
      setSession(session);
      setIsLoading(false);
    });

    // Listen for auth changes
    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) =&gt; {
      setSession(session);
    });

    return () =&gt; subscription.unsubscribe();
  }, []);

  return (
    &lt;SupabaseContext.Provider value={{ session, isLoading }}&gt;
      {children}
    &lt;/SupabaseContext.Provider&gt;
  );
}

export const useSupabase = () =&gt; useContext(SupabaseContext);</file><file path="contexts/ThemeContext.tsx">import React, { createContext, useContext, useState } from &apos;react&apos;;

interface ThemeContextType {
  themeColor: string;
  setThemeColor: (color: string) =&gt; void;
}

const ThemeContext = createContext&lt;ThemeContextType&gt;({
  themeColor: &apos;#00008B&apos;,
  setThemeColor: () =&gt; {},
});

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [themeColor, setThemeColor] = useState(&apos;#00008B&apos;);

  return (
    &lt;ThemeContext.Provider value={{ themeColor, setThemeColor }}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}

export const useTheme = () =&gt; useContext(ThemeContext);</file><file path="hooks/useChatData.ts">import { useState } from &apos;react&apos;;
import { ChatMessage } from &apos;@/app/types&apos;;
import { useTheme } from &apos;@/contexts/ThemeContext&apos;;

export function useChatData() {
  const { themeColor } = useTheme();
  const [messages] = useState&lt;ChatMessage[]&gt;([
    { id: 1,created_at: &apos;00000&apos;, updated_at: &apos;2222&apos;, isUser: false, message: &quot;Rise and shine, samurai. Another day in this digital hellhole.&quot;,  },
    { id: 1,created_at: &apos;00000&apos;, updated_at: &apos;2222&apos;,isUser: false, message: &quot;Got your todo list here - feedback loops and database grind. Oh, and try not to ghost your input parameters tonight, got that hot date coming up.&quot; },
    {id: 1,created_at: &apos;00000&apos;, updated_at: &apos;2222&apos;, isUser: false, message: &quot;So what&apos;s it gonna be? Gonna dive into the code mines or keep staring at my gorgeous interface?&quot; },
    {id: 1,created_at: &apos;00000&apos;, updated_at: &apos;2222&apos;, isUser: true, message: &quot;Thinking about tackling the database first, but yeah, can&apos;t mess up tonight&apos;s plans.&quot; },
    {id: 1,created_at: &apos;00000&apos;, updated_at: &apos;2222&apos;, isUser: false, message: &quot;Database work, huh? Real exciting stuff. Just don&apos;t let the corps standardize your thinking patterns. And hey - that date? That&apos;s the real quest here. Everything else is just side content.&quot; },
    {id: 1,created_at: &apos;00000&apos;, updated_at: &apos;2222&apos;, isUser: false, message: &quot;I&apos;ll keep an eye on the clock for ya. Shoot you a text at 6PM. Can&apos;t let you dive so deep into the code that you forget about the real world. You know how that goes.&quot; }
  ]);

  return {
    messages,
    themeColor,
  };
}</file><file path="hooks/useColorScheme.web.ts">import { useEffect, useState } from &apos;react&apos;;
import { useColorScheme as useRNColorScheme } from &apos;react-native&apos;;

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() =&gt; {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return &apos;light&apos;;
}</file><file path="hooks/useThemeColor.ts">/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from &apos;@/constants/Colors&apos;;
import { useColorScheme } from &apos;react-native&apos;;

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light &amp; keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? &apos;light&apos;;
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}</file><file path="lib/supabase.ts">import &apos;react-native-url-polyfill/auto&apos;
import AsyncStorage from &apos;@react-native-async-storage/async-storage&apos;
import { createClient } from &apos;@supabase/supabase-js&apos;

export const supabase = createClient(
  process.env.EXPO_PUBLIC_SUPABASE_URL || &quot;&quot;,
  process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY || &quot;&quot;,
  {
    auth: {
      storage: AsyncStorage,
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: false,
    },
  })</file><file path="package.json">{
  &quot;name&quot;: &quot;questlog&quot;,
  &quot;main&quot;: &quot;expo-router/entry&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;expo start&quot;,
    &quot;reset-project&quot;: &quot;node ./scripts/reset-project.js&quot;,
    &quot;android&quot;: &quot;expo start --android&quot;,
    &quot;ios&quot;: &quot;expo start --ios&quot;,
    &quot;web&quot;: &quot;expo start --web&quot;,
    &quot;test&quot;: &quot;jest --watchAll&quot;,
    &quot;lint&quot;: &quot;expo lint&quot;
  },
  &quot;jest&quot;: {
    &quot;preset&quot;: &quot;jest-expo&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@expo-google-fonts/inter&quot;: &quot;^0.2.3&quot;,
    &quot;@expo-google-fonts/poppins&quot;: &quot;^0.2.3&quot;,
    &quot;@expo/vector-icons&quot;: &quot;^14.0.2&quot;,
    &quot;@react-native-async-storage/async-storage&quot;: &quot;1.23.1&quot;,
    &quot;@react-navigation/bottom-tabs&quot;: &quot;^7.2.0&quot;,
    &quot;@react-navigation/native&quot;: &quot;^7.0.14&quot;,
    &quot;@rneui/themed&quot;: &quot;^4.0.0-rc.8&quot;,
    &quot;@supabase/supabase-js&quot;: &quot;^2.48.1&quot;,
    &quot;date-fns&quot;: &quot;^4.1.0&quot;,
    &quot;expo&quot;: &quot;~52.0.28&quot;,
    &quot;expo-blur&quot;: &quot;~14.0.3&quot;,
    &quot;expo-constants&quot;: &quot;~17.0.5&quot;,
    &quot;expo-font&quot;: &quot;~13.0.3&quot;,
    &quot;expo-haptics&quot;: &quot;~14.0.1&quot;,
    &quot;expo-linking&quot;: &quot;~7.0.5&quot;,
    &quot;expo-router&quot;: &quot;~4.0.17&quot;,
    &quot;expo-splash-screen&quot;: &quot;~0.29.21&quot;,
    &quot;expo-status-bar&quot;: &quot;~2.0.1&quot;,
    &quot;expo-symbols&quot;: &quot;~0.2.1&quot;,
    &quot;expo-system-ui&quot;: &quot;~4.0.7&quot;,
    &quot;expo-web-browser&quot;: &quot;~14.0.2&quot;,
    &quot;react&quot;: &quot;18.3.1&quot;,
    &quot;react-dom&quot;: &quot;18.3.1&quot;,
    &quot;react-native&quot;: &quot;0.76.6&quot;,
    &quot;react-native-gesture-handler&quot;: &quot;~2.20.2&quot;,
    &quot;react-native-paper&quot;: &quot;^5.13.1&quot;,
    &quot;react-native-reanimated&quot;: &quot;~3.16.1&quot;,
    &quot;react-native-safe-area-context&quot;: &quot;4.12.0&quot;,
    &quot;react-native-screens&quot;: &quot;~4.4.0&quot;,
    &quot;react-native-url-polyfill&quot;: &quot;^2.0.0&quot;,
    &quot;react-native-web&quot;: &quot;~0.19.13&quot;,
    &quot;react-native-webview&quot;: &quot;13.12.5&quot;,
    &quot;react-native-wheel-color-picker&quot;: &quot;^1.3.1&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@babel/core&quot;: &quot;^7.25.2&quot;,
    &quot;@types/jest&quot;: &quot;^29.5.12&quot;,
    &quot;@types/react&quot;: &quot;~18.3.12&quot;,
    &quot;@types/react-test-renderer&quot;: &quot;^18.3.0&quot;,
    &quot;jest&quot;: &quot;^29.2.1&quot;,
    &quot;jest-expo&quot;: &quot;~52.0.3&quot;,
    &quot;react-test-renderer&quot;: &quot;18.3.1&quot;,
    &quot;typescript&quot;: &quot;^5.3.3&quot;
  },
  &quot;private&quot;: true
}</file><file path="README.md"># Welcome to your Expo app ðŸ‘‹

This is an [Expo](https://expo.dev) project created with [`create-expo-app`](https://www.npmjs.com/package/create-expo-app).

## Get started

1. Install dependencies

   ```bash
   npm install
   ```

2. Start the app

   ```bash
    npx expo start
   ```

In the output, you&apos;ll find options to open the app in a

- [development build](https://docs.expo.dev/develop/development-builds/introduction/)
- [Android emulator](https://docs.expo.dev/workflow/android-studio-emulator/)
- [iOS simulator](https://docs.expo.dev/workflow/ios-simulator/)
- [Expo Go](https://expo.dev/go), a limited sandbox for trying out app development with Expo

You can start developing by editing the files inside the **app** directory. This project uses [file-based routing](https://docs.expo.dev/router/introduction).

## Get a fresh project

When you&apos;re ready, run:

```bash
npm run reset-project
```

This command will move the starter code to the **app-example** directory and create a blank **app** directory where you can start developing.

## QUESTLOG

---

## 1. **Landing / Home Page**

### Purpose
- Provide an immediate overview of the userâ€™s current situation: upcoming tasks, open quests, and recent messages from the AI assistant.

### Key Features
- **Quick Glance Cards**: 
  - Next 3 tasks due (with deadlines and location).
  - Active Quests: top 2â€“3 quests the user is focusing on.
  - Recent Chat Snippets: show last AI message or an â€œAI Suggestion of the Day.â€
- **â€œGo to Chatâ€ Button**: Encourages the user to jump into the conversational interface.

### Layout Highlights
- Clean hero-like header with userâ€™s name or motivational greeting.
- Panels or cards summarizing key productivity data.
- Possibly highlight an important AI nudgeâ€”e.g., â€œDonâ€™t forget to complete your daily journal!â€

---

## 2. **Chat / LLM Interface Page**

### Purpose
- Central place for the user to converse with the AI assistant and see the ongoing dialogue.

### Key Features
- **Chat Thread**: 
  - Messages from the user (aligned right) and AI messages (aligned left).
  - Option to display small icons for different AI â€œpersonality modesâ€ (Cheerleader, Stoic Mentor, etc.).
- **Message Input Field**:
  - Allows the user to type or use voice-to-text (if you plan to integrate).
  - Could have a short list of quick action buttons like â€œAdd Task,â€ â€œSchedule Event,â€ or â€œAdd Journal Entry.â€
- **Proactive Reminders / Notifications**:
  - Above or below the chat, show real-time notifications when the AI proactively reminds the user about tasks or journal entries.

### Layout Highlights
- Minimal, clean design (similar to messaging apps).
- Keep the chat always scrolled to the bottom for a live feel.
- Possibly a side-panel with â€œcontextâ€ info (like current active quest or next upcoming event) which the LLM is referencing.

---

## 3. **Quests Overview Page**

### Purpose
- Display a list of all quests (medium/long-term goals) in an RPG-inspired style. 
- Provide a quick way to see quest progress and statuses.

### Key Features
- **Quests List**:
  - Each quest has a title, short description, a progress bar or indicator of how many tasks are done vs. total tasks.
  - Buttons or links to open a specific quest detail page.
- **Add New Quest** button.

### Layout Highlights
- Visually reminiscent of an RPG quest log: 
  - Possibly with small â€œquest iconsâ€ or stylized headings.
- Clear statuses or color-coding to show which quests are â€œActive,â€ â€œOn-Hold,â€ or â€œCompleted.â€

---

## 4. **Single Quest Detail &amp; Kanban Page**

### Purpose
- Serve as the in-depth view for a single quest:
  - Show tasks, memos, and quest statuses (the stylized SWOT analysis logs).
  - Provide an interactive Kanban board to move tasks from â€œTodoâ€ to â€œIn-Progressâ€ to â€œDone.â€

### Key Features
1. **Quest Info Header**:
   - Title, short description, creation date, â€œactiveâ€ or â€œcompletedâ€ indicator.
2. **QuestStatus Log** (SWOT-inspired paragraphs):
   - Show the chronological updates to the quest status. 
   - Possibly collapse older status updates, with an option to expand them.
3. **Tasks Kanban Board**:
   - Three columns: â€œTodo,â€ â€œIn-Progress,â€ â€œDone.â€
   - Drag &amp; drop tasks between columns.
   - Each task card shows task name, location, and due date. 
   - A â€œ+ Add Taskâ€ button in the â€œTodoâ€ column.
4. **Memos List**:
   - Separate panel or section for relevant memos/tips. 
   - Memos can be pinned or flagged.

### Layout Highlights
- A large Kanban board for tasks (main content).
- A right sidebar or bottom section for quest statuses (the 3-paragraph logs) and memos.

---

## 5. **Task List Page**

### Purpose
- Give the user a comprehensive view of **all** tasks across quests, sorted by their deadlines and grouped by location.

### Key Features
- **Tasks Grouped by Location**:
  - Sections like â€œOnline/Desktop,â€ â€œGym,â€ â€œHome,â€ â€œErrands,â€ etc.
- **Within Each Location**, tasks can be **sorted by date**:
  - Overdue tasks at the top, then upcoming tasks in chronological order.
- **Quick Action Buttons** for each task (e.g., â€œMark Complete,â€ â€œEdit,â€ â€œRescheduleâ€).

### Layout Highlights
- A collapsible accordion or tab-based interface where each location is its own section.
- Possibly a toggle between â€œList Viewâ€ and â€œCalendar Viewâ€ to see how tasks map onto a timeline.

---
## 5. **Routine Page**

### Purpose

- Manage recurring maintenance tasks that are not tied to quests but are necessary for daily, weekly, or monthly upkeep.

### Key Features

- ## Task Categories:

- Daily Tasks

- Weekly Tasks

- Monthly Tasks

- Flexible Scheduling (e.g., â€œTwo times a weekâ€ or â€œEvery other Fridayâ€).

### Integration with Calendar:

- Sync scheduled tasks with Google Calendar.

- Allow AI to dynamically adjust schedules if a user misses a task (â€œLetâ€™s reschedule your workout to tomorrowâ€).

### Completion Tracking:

- Checkbox system to mark completed routines.

- AI-generated streak tracking (e.g., â€œYouâ€™ve completed your morning routine 5 days in a row!â€).

### Layout Highlights

- A clean, checklist-style interface.

- Possible calendar-style heatmap for tracking consistency.

## 6. **Calendar Integration Page**

### Purpose
- Integrate with Google Calendar or another scheduling solution so the user can see tasks/events on a monthly/weekly/daily grid.

### Key Features
- **Calendar Grid**:
  - Mark tasks that have scheduled dates, plus any personal events pulled in from Google Calendar.
- **Add/Update Events**:
  - If the user clicks on a date, open a modal to add a new event or schedule an existing task directly on that date and time.
- **Sync Status**:
  - Show whether the userâ€™s Google Calendar is linked, last sync time, any conflicts, etc.

### Layout Highlights
- Standard calendar UI (month, week, day views) with color-coded tasks vs. external events.
- Possibly embed the official Google Calendar UI using an iFrame (for a quicker MVP) or build your own.

---

## 7. **Journal Page (List &amp; Detail)**

### Purpose
- Display the userâ€™s historical journal entries so both the user and the AI can reflect on them.
- Provide a place to read and write new longer-form entries.

### Key Features
1. **Journal Entries List**:
   - Chronological list (most recent at top).
   - Each entry shows a short preview (first ~200 characters).
2. **Single Journal Entry View**:
   - Full content of the journal entry.
   - AI-generated insights or summaries (optional).
3. **Add New Entry**:
   - Rich text editor or simple text box.
   - Option to attach images (if you want a more personal journaling experience).

### Layout Highlights
- A minimal, distraction-free interface for writing. 
- Possibly a â€œprompt of the dayâ€ near the top to encourage daily journaling.

---

## 8. **Settings &amp; Profile Page**

### Purpose
- Central hub for user settings, AI â€œpersonalityâ€ selection, notification preferences, and user account details.

### Key Features
- **AI Personality Modes**:
  - Let the user pick from pre-set prompts: â€œCheerleader,â€ â€œStoic Mentor,â€ â€œSarcastic Pal,â€ etc.
- **Notification Preferences**:
  - Frequency of proactive AI check-ins.
- **Google Calendar Integration Settings**:
  - Connect/disconnect from Google account.
  - Configure default calendar, tasks sync, etc.
- **User Profile**:
  - Name, time zone, personal background info, etc.

### Layout Highlights
- Tab-based interface or simple form sections for each setting category.
- Toggle switches and radio buttons for easy configuration.

---

## 9. **High-Level UX Flow**

1. **Landing / Home**: Summaries at-a-glance â†’ user can jump into the next needed action.  
2. **Chat**: The user interacts with the LLM for daily conversation, quick tasks, or motivational pep talks.  
   - LLM calls functions like `addTask()`, `updateQuestStatus()`, etc., behind the scenes.  
3. **Quests**: The user can view all quests or open a specific questâ€™s details and Kanban board.  
4. **Tasks**: The user can see and manage tasks across all quests via a consolidated view.  
5. **Journal**: The user writes new entries or reviews past ones. LLM analyzes them in the background.  
6. **Calendar**: Scheduling tasks and events, integrated with Google Calendar.  
7. **Settings**: Personalize the AIâ€™s demeanor and manage account integrations.

---
---
Data Layer / API Integration:

Set up a proper backend service (e.g. Firebase, Supabase, or your own REST/GraphQL API)
Implement local storage with AsyncStorage for offline capabilities
Use React Query or similar for data fetching/caching/sync
Consider implementing a queue for offline actions


State Management:

Use React Context for global app state
Consider Zustand for more complex state management
Implement proper loading/error states for better UX
Handle state persistence across app restarts


UI Components &amp; Styling:

Use React Native&apos;s built-in styling system or a library like StyleSheet
Consider NativeBase or React Native Paper for pre-built components
Implement proper keyboard handling and input behaviors
Ensure components work well across different screen sizes
Use React Native&apos;s Animated API for smooth transitions


Navigation &amp; Screens:

Use React Navigation for screen management
Implement proper deep linking support
Consider using tab navigation for main sections
Handle proper back button behavior on Android
Implement gesture-based navigation where appropriate


Notifications &amp; Background Tasks:

Use Expo&apos;s Notifications API for push notifications
Implement local notifications for reminders
Handle background tasks for routine updates
Manage notification permissions properly
Consider using Background Fetch for periodic updates


Authentication &amp; Security:

Use Expo Auth Session for OAuth flows
Implement secure token storage
Handle biometric authentication where appropriate
Manage session expiration and refresh
Consider implementing app lock features


Offline Support:

Implement proper data synchronization
Use SQLite or Realm for local database
Handle conflict resolution for offline changes
Show appropriate offline indicators
Queue actions for later sync


Performance Optimization:

Implement proper list virtualization
Use image caching and lazy loading
Optimize animations for 60fps
Minimize JS bridge traffic
Handle memory management properly


Platform-Specific Features:

Use native date/time pickers
Implement proper calendar integration
Handle different keyboard behaviors
Support different screen sizes and orientations
Consider tablet-specific layouts


Testing &amp; Monitoring:

Set up proper error tracking (e.g. Sentry)
Implement analytics for user behavior
Use Expo&apos;s testing tools
Handle crash reporting
Monitor performance metrics
### Summing Up

With these pages, your MVP will allow users to (1) chat with the AI assistant to manage tasks and goals, (2) track everything in an RPG-inspired Quest and Task interface, (3) maintain a personal Journal for deeper reflection, and (4) integrate with Google Calendar for real-time scheduling and reminders. The design focuses on balancing a fun, motivational vibe (through the RPG quest metaphor) with straightforward productivity tools (Kanban boards, calendar scheduling, etc.).

This structure provides a clear, game-like user journey while meeting the core requirement: letting the LLM act as a proactive project manager, hooking into tasks, quests, memos, and journal entriesâ€”always encouraging the user to stay on top of their goals and well-being.</file><file path="scripts/reset-project.js">#!/usr/bin/env node

/**
 * This script is used to reset the project to a blank state.
 * It moves the /app, /components, /hooks, /scripts, and /constants directories to /app-example and creates a new /app directory with an index.tsx and _layout.tsx file.
 * You can remove the `reset-project` script from package.json and safely delete this file after running it.
 */

const fs = require(&quot;fs&quot;);
const path = require(&quot;path&quot;);

const root = process.cwd();
const oldDirs = [&quot;app&quot;, &quot;components&quot;, &quot;hooks&quot;, &quot;constants&quot;, &quot;scripts&quot;];
const newDir = &quot;app-example&quot;;
const newAppDir = &quot;app&quot;;
const newDirPath = path.join(root, newDir);

const indexContent = `import { Text, View } from &quot;react-native&quot;;

export default function Index() {
  return (
    &lt;View
      style={{
        flex: 1,
        justifyContent: &quot;center&quot;,
        alignItems: &quot;center&quot;,
      }}
    &gt;
      &lt;Text&gt;Edit app/index.tsx to edit this screen.&lt;/Text&gt;
    &lt;/View&gt;
  );
}
`;

const layoutContent = `import { Stack } from &quot;expo-router&quot;;

export default function RootLayout() {
  return &lt;Stack /&gt;;
}
`;

const moveDirectories = async () =&gt; {
  try {
    // Create the app-example directory
    await fs.promises.mkdir(newDirPath, { recursive: true });
    console.log(`ðŸ“ /${newDir} directory created.`);

    // Move old directories to new app-example directory
    for (const dir of oldDirs) {
      const oldDirPath = path.join(root, dir);
      const newDirPath = path.join(root, newDir, dir);
      if (fs.existsSync(oldDirPath)) {
        await fs.promises.rename(oldDirPath, newDirPath);
        console.log(`âž¡ï¸ /${dir} moved to /${newDir}/${dir}.`);
      } else {
        console.log(`âž¡ï¸ /${dir} does not exist, skipping.`);
      }
    }

    // Create new /app directory
    const newAppDirPath = path.join(root, newAppDir);
    await fs.promises.mkdir(newAppDirPath, { recursive: true });
    console.log(&quot;\nðŸ“ New /app directory created.&quot;);

    // Create index.tsx
    const indexPath = path.join(newAppDirPath, &quot;index.tsx&quot;);
    await fs.promises.writeFile(indexPath, indexContent);
    console.log(&quot;ðŸ“„ app/index.tsx created.&quot;);

    // Create _layout.tsx
    const layoutPath = path.join(newAppDirPath, &quot;_layout.tsx&quot;);
    await fs.promises.writeFile(layoutPath, layoutContent);
    console.log(&quot;ðŸ“„ app/_layout.tsx created.&quot;);

    console.log(&quot;\nâœ… Project reset complete. Next steps:&quot;);
    console.log(
      &quot;1. Run `npx expo start` to start a development server.\n2. Edit app/index.tsx to edit the main screen.\n3. Delete the /app-example directory when you&apos;re done referencing it.&quot;
    );
  } catch (error) {
    console.error(`Error during script execution: ${error}`);
  }
};

moveDirectories();</file><file path="services/questsService.ts">import { useState, useEffect } from &apos;react&apos;;
import { supabase } from &apos;@/lib/supabase&apos;;
import type { Quest } from &apos;@/app/types&apos;;
import { RealtimePostgresChangesPayload } from &apos;@supabase/supabase-js&apos;;

// Explicitly define the payload structure
interface QuestUpdate {
  id: number;
  is_main: boolean;
  title?: string;
  tagline?: string;
  status?: string;
  start_date?: string;
  end_date?: string;
  analysis?: string;
  parent_quest_id?: number;
  tags?: string[];
}

type QuestRealtimePayload = RealtimePostgresChangesPayload&lt;QuestUpdate&gt;;

// Database operations
async function fetchQuests(): Promise&lt;Quest[]&gt; {
  console.log(&apos;Fetching quests...&apos;);
  const { data, error } = await supabase
    .from(&apos;quests&apos;)
    .select(`
      id,
      created_at,
      updated_at,
      tags,
      title,
      tagline,
      is_main,
      status,
      start_date,
      end_date,
      analysis,
      parent_quest_id,
      tasks (*)
    `)
    .order(&apos;created_at&apos;, { ascending: false });

  if (error) {
    console.error(&apos;Error fetching quests:&apos;, error);
    throw error;
  }

  console.log(&apos;Fetched quests:&apos;, data);
  return data || [];
}

async function updateMainQuest(questId: number): Promise&lt;void&gt; {
  console.log(&apos;Calling RPC to update main quest:&apos;, questId);
  const { error } = await supabase.rpc(&apos;update_main_quest&apos;, { p_quest_id: questId });
  if (error) {
    console.error(&apos;Error updating main quest via RPC:&apos;, error);
    throw error;
  }
  console.log(&apos;Successfully updated main quest via RPC&apos;);
}

// React Hook
export function useQuests() {
  const [quests, setQuests] = useState&lt;Quest[]&gt;([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState&lt;string | null&gt;(null);

  const loadQuests = async () =&gt; {
    try {
      setLoading(true);
      const allQuests = await fetchQuests();
      setQuests(allQuests);
    } catch (err) {
      setError(err instanceof Error ? err.message : &apos;Failed to load quests&apos;);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() =&gt; {
    loadQuests();
  }, []);

  return {
    mainQuest: quests.find(q =&gt; q.is_main) || null,
    quests,
    setQuestAsMain: async (questId: number) =&gt; {
      try {
        // Update local state first (optimistic update)
        setQuests(currentQuests =&gt; 
          currentQuests.map(quest =&gt; ({
            ...quest,
            is_main: quest.id === questId
          }))
        );
        
        // Then update the database
        await updateMainQuest(questId);
      } catch (err) {
        // If the update fails, reload from DB to get correct state
        console.error(&apos;Failed to set main quest:&apos;, err);
        setError(err instanceof Error ? err.message : &apos;Failed to update main quest&apos;);
        await loadQuests();
      }
    },
    loading,
    error,
    reload: loadQuests  // Expose reload function
  };
}</file><file path="services/tasksService.ts">import { useState, useEffect, useRef } from &apos;react&apos;;
import { Animated } from &apos;react-native&apos;;
import { supabase } from &apos;@/lib/supabase&apos;;
import type { Task } from &apos;@/app/types&apos;;

// Database operations
async function fetchTasks(): Promise&lt;Task[]&gt; {
  console.log(&apos;Fetching tasks...&apos;);
  const { data, error } = await supabase
    .from(&apos;tasks&apos;)
    .select(`
      *,
      quest:quests!quest_id (
        id,
        title,
        tagline,
        is_main,
        status,
        start_date,
        end_date
      )
    `)
    .order(&apos;scheduled_for&apos;, { ascending: true });

  if (error) {
    console.error(&apos;Error fetching tasks:&apos;, error);
    throw error;
  }

  console.log(&apos;Fetched tasks:&apos;, data);
  return data as Task[];
}

async function fetchTasksByQuest(questId: number): Promise&lt;Task[]&gt; {
  const { data, error } = await supabase
    .from(&apos;tasks&apos;)
    .select(&apos;*&apos;)
    .eq(&apos;quest_id&apos;, questId)
    .order(&apos;scheduled_for&apos;, { ascending: true });

  if (error) throw error;
  return data || [];
}

// React Hook
export function useTasks() {
  const [tasks, setTasks] = useState&lt;Task[]&gt;([]);
  const [taskListVisible, setTaskListVisible] = useState(true);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState&lt;string | null&gt;(null);
  const animatedHeight = useRef(new Animated.Value(1)).current;

  useEffect(() =&gt; {
    loadTasks();
  }, []);

  async function loadTasks() {
    try {
      setLoading(true);
      const data = await fetchTasks();
      console.log(&apos;Loaded tasks:&apos;, data);
      setTasks(data);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : &apos;Failed to load tasks&apos;;
      console.error(&apos;Error loading tasks:&apos;, errorMessage);
      setError(errorMessage);
    } finally {
      setLoading(false);
    }
  }

  const toggleTaskList = () =&gt; {
    const toValue = taskListVisible ? 0 : 1;
    setTaskListVisible(!taskListVisible);
    
    Animated.timing(animatedHeight, {
      toValue,
      duration: 300,
      useNativeDriver: false,
    }).start();
  };

  return {
    tasks,
    taskListVisible,
    animatedHeight,
    toggleTaskList,
    loading,
    error,
    reload: loadTasks
  };
}</file><file path="tsconfig.json">{
  &quot;extends&quot;: &quot;expo/tsconfig.base&quot;,
  &quot;compilerOptions&quot;: {
    &quot;strict&quot;: true,
    &quot;paths&quot;: {
      &quot;@/*&quot;: [
        &quot;./*&quot;
      ]
    }
  },
  &quot;include&quot;: [
    &quot;**/*.ts&quot;,
    &quot;**/*.tsx&quot;,
    &quot;types/env.d.ts&quot;
  ]
}</file><file path="types/quest.ts">export interface BaseEntity {
  id: number;
  created_at: string;
  updated_at: string;
  tags?: string[];
}

export interface Task extends BaseEntity {
  title: string;
  description?: string;
  scheduledFor: string;
  location: string;
  questId: number;
  deadline?: string;
  quest?: Quest; // For joined data
}

export interface JournalEntry extends BaseEntity {
  title: string;
  userEntry: string;
  aiAnalysis: string;
}

export interface QuestStatus extends BaseEntity {
  message: string;
  timestamp: string;
  questId: number;
}

export interface Quest extends BaseEntity {
  title: string;
  shortDescription: string;
  isMain: boolean;
  status: &apos;Active&apos; | &apos;On-Hold&apos; | &apos;Completed&apos;;
  progress: string;
  questStatus?: string;
  currentStatus?: QuestStatus;
  tasks: Task[];
  kanban?: Record&lt;string, string[]&gt;;
  analysis?: string;
  parentQuestId?: number;
  startDate?: string;
  endDate?: string;
  StatusHistory?: Record&lt;string, QuestStatus&gt;;
}

export interface Memo extends BaseEntity {
  title: string;
  content: string;
  questId: number;
}

export interface MainQuest {
  id: number;
  title: string;
  progress: string;
  kanban: Record&lt;string, string[]&gt;;
}</file><file path="utils/dateFormatters.ts">import { formatDistanceToNow, format, isToday, isTomorrow, isYesterday, parseISO } from &apos;date-fns&apos;;

type DateStyle = &apos;default&apos; | &apos;deadline&apos; | &apos;compact&apos;;

export function formatDateTime(isoDateString: string | null, style: DateStyle = &apos;default&apos;): string {
  if (!isoDateString) return style === &apos;deadline&apos; ? &apos;&apos; : &apos;No date set&apos;;
  
  const date = parseISO(isoDateString);
  const now = new Date();
  
  // Handle invalid dates
  if (isNaN(date.getTime())) return style === &apos;deadline&apos; ? &apos;&apos; : &apos;Invalid date&apos;;

  // Get relative time string
  const distanceString = formatDistanceToNow(date, { addSuffix: true });

  // Deadline style just prepends &quot;Due&quot; to the distance
  if (style === &apos;deadline&apos;) {
    return `Due ${distanceString}`;
  }

  // For dates within next/past 24 hours
  if (isToday(date)) {
    return style === &apos;compact&apos; 
      ? format(date, &apos;h:mm a&apos;)
      : `Today at ${format(date, &apos;h:mm a&apos;)}`;
  }
  if (isTomorrow(date)) {
    return style === &apos;compact&apos;
      ? `Tom ${format(date, &apos;h:mm a&apos;)}`
      : `Tomorrow at ${format(date, &apos;h:mm a&apos;)}`;
  }
  if (isYesterday(date)) {
    return style === &apos;compact&apos;
      ? `Yest ${format(date, &apos;h:mm a&apos;)}`
      : `Yesterday at ${format(date, &apos;h:mm a&apos;)}`;
  }

  // For dates within the next/past 7 days
  if (Math.abs(date.getTime() - now.getTime()) &lt; 7 * 24 * 60 * 60 * 1000) {
    return style === &apos;compact&apos;
      ? format(date, &apos;MMM d&apos;)
      : `${distanceString} (${format(date, &apos;MMM d, h:mm a&apos;)})`;
  }

  // For dates further away
  return style === &apos;compact&apos;
    ? format(date, &apos;MMM d&apos;)
    : format(date, &apos;MMM d, yyyy h:mm a&apos;);
}</file></files></repomix>