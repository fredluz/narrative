<repomix>This file is a merged representation of the entire codebase, combined into a single document. The content has been processed where content has been formatted for parsing.
Generated by Repomix on: 2025-02-08T00:01:00.930Z<file_summary>This section contains a summary of this file.<purpose>This file contains a packed representation of the entire repository&apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.</purpose><file_format>The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file</file_format><usage_guidelines>- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.</usage_guidelines><notes>- Some files may have been excluded based on .gitignore rules and Repomix&apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been formatted for parsing in xml style</notes><additional_info></additional_info></file_summary><directory_structure>.gitignore
app.json
app/_layout.tsx
app/+not-found.tsx
app/index.tsx
app/landing.tsx
app/notification.tsx
app/quests.tsx
app/styles/global.js
app/types.ts
components/__tests__/__snapshots__/ThemedText-test.tsx.snap
components/__tests__/ThemedText-test.tsx
components/ChatInterface.tsx
components/Collapsible.tsx
components/ExternalLink.tsx
components/HapticTab.tsx
components/HelloWave.tsx
components/layouts/DesktopLayout.tsx
components/layouts/MobileLayout.tsx
components/ParallaxScrollView.tsx
components/QuestsOverview.tsx
components/ThemedText.tsx
components/ThemedView.tsx
components/ui/HamburgerMenu.tsx
components/ui/IconSymbol.ios.tsx
components/ui/IconSymbol.tsx
components/ui/SettingsButton.tsx
components/ui/TabBarBackground.ios.tsx
components/ui/TabBarBackground.tsx
constants/Colors.ts
contexts/ThemeContext.tsx
hooks/useChatData.ts
hooks/useColorScheme.web.ts
hooks/useQuestData.ts
hooks/useTaskData.ts
hooks/useThemeColor.ts
package.json
README.md
scripts/reset-project.js
tsconfig.json</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path=".gitignore"># Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

app-example</file><file path="app.json">{
  &quot;expo&quot;: {
    &quot;name&quot;: &quot;QuestLog&quot;,
    &quot;slug&quot;: &quot;QuestLog&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;orientation&quot;: &quot;portrait&quot;,
    &quot;icon&quot;: &quot;./assets/images/icon.png&quot;,
    &quot;scheme&quot;: &quot;myapp&quot;,
    &quot;userInterfaceStyle&quot;: &quot;automatic&quot;,
    &quot;newArchEnabled&quot;: true,
    &quot;ios&quot;: {
      &quot;supportsTablet&quot;: true
    },
    &quot;android&quot;: {
      &quot;adaptiveIcon&quot;: {
        &quot;foregroundImage&quot;: &quot;./assets/images/adaptive-icon.png&quot;,
        &quot;backgroundColor&quot;: &quot;#ffffff&quot;
      }
    },
    &quot;web&quot;: {
      &quot;bundler&quot;: &quot;metro&quot;,
      &quot;output&quot;: &quot;static&quot;,
      &quot;favicon&quot;: &quot;./assets/images/favicon.png&quot;
    },
    &quot;plugins&quot;: [
      &quot;expo-router&quot;,
      [
        &quot;expo-splash-screen&quot;,
        {
          &quot;image&quot;: &quot;./assets/images/splash-icon.png&quot;,
          &quot;imageWidth&quot;: 200,
          &quot;resizeMode&quot;: &quot;contain&quot;,
          &quot;backgroundColor&quot;: &quot;#ffffff&quot;
        }
      ]
    ],
    &quot;experiments&quot;: {
      &quot;typedRoutes&quot;: true
    }
  }
}</file><file path="app/_layout.tsx">import { DarkTheme, DefaultTheme, ThemeProvider } from &apos;@react-navigation/native&apos;;
import { useFonts,
  Inter_400Regular,
  Inter_700Bold,
} from &apos;@expo-google-fonts/inter&apos;;
import {
  Poppins_400Regular,
  Poppins_700Bold,
} from &apos;@expo-google-fonts/poppins&apos;;
import { Stack } from &apos;expo-router&apos;;
import * as SplashScreen from &apos;expo-splash-screen&apos;;
import { StatusBar } from &apos;expo-status-bar&apos;;
import { useEffect } from &apos;react&apos;;
import &apos;react-native-reanimated&apos;;
import { useColorScheme, View, Text } from &apos;react-native&apos;;
import { ThemeProvider as AppThemeProvider, useTheme } from &apos;@/contexts/ThemeContext&apos;;
import { Ionicons } from &apos;@expo/vector-icons&apos;;
import styles from &apos;./styles/global&apos;;
// Prevent the splash screen from auto-hiding before asset loading is complete.
SplashScreen.preventAutoHideAsync();

export default function RootLayout() {
  const colorScheme = useColorScheme();
  const { themeColor } = useTheme();
  const [loaded] = useFonts({
    Inter_400Regular,
    Inter_700Bold,
    Poppins_400Regular,
    Poppins_700Bold,
    SpaceMono: require(&apos;../assets/fonts/SpaceMono-Regular.ttf&apos;),
  });

  const isDarkColor = (color: string) =&gt; {
    const hex = color.replace(&apos;#&apos;, &apos;&apos;);
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    return brightness &lt; 128;
  };

  const textColor = isDarkColor(themeColor) ? &apos;#fff&apos; : &apos;#000&apos;;

  useEffect(() =&gt; {
    if (loaded) {
      SplashScreen.hideAsync();
    }
  }, [loaded]);

  if (!loaded) {
    return null;
  }

  return (
    &lt;ThemeProvider value={colorScheme === &apos;dark&apos; ? DarkTheme : DefaultTheme}&gt;
      &lt;AppThemeProvider&gt;
        &lt;Stack screenOptions={{ headerShown: false }}&gt;
          &lt;Stack.Screen name=&quot;index&quot; /&gt;
          &lt;Stack.Screen name=&quot;landing&quot; /&gt;
          &lt;Stack.Screen name=&quot;notification&quot; /&gt;
          &lt;Stack.Screen name=&quot;quests&quot; /&gt;
        &lt;/Stack&gt;
        &lt;StatusBar style=&quot;auto&quot; /&gt;
        {/* Removed the original theme selector button */}
      &lt;/AppThemeProvider&gt;
    &lt;/ThemeProvider&gt;
  );
}</file><file path="app/+not-found.tsx">import { Link, Stack } from &apos;expo-router&apos;;
import { StyleSheet } from &apos;react-native&apos;;

import { ThemedText } from &apos;@/components/ThemedText&apos;;
import { ThemedView } from &apos;@/components/ThemedView&apos;;

export default function NotFoundScreen() {
  return (
    &lt;&gt;
      &lt;Stack.Screen options={{ title: &apos;Oops!&apos; }} /&gt;
      &lt;ThemedView style={styles.container}&gt;
        &lt;ThemedText type=&quot;title&quot;&gt;This screen doesn&apos;t exist.&lt;/ThemedText&gt;
        &lt;Link href=&quot;/&quot; style={styles.link}&gt;
          &lt;ThemedText type=&quot;link&quot;&gt;Go to home screen!&lt;/ThemedText&gt;
        &lt;/Link&gt;
      &lt;/ThemedView&gt;
    &lt;/&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: &apos;center&apos;,
    justifyContent: &apos;center&apos;,
    padding: 20,
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
});</file><file path="app/index.tsx">import { Redirect } from &apos;expo-router&apos;;

export default function Index() {
  return &lt;Redirect href=&quot;/landing&quot; /&gt;;
}</file><file path="app/landing.tsx">import React from &apos;react&apos;;
import { useWindowDimensions, Platform } from &apos;react-native&apos;;
import { MobileLayout } from &apos;@/components/layouts/MobileLayout&apos;;
import { DesktopLayout } from &apos;@/components/layouts/DesktopLayout&apos;;

export default function HomeScreen() {
  const { width } = useWindowDimensions();
  const isMobile = Platform.OS === &apos;ios&apos; || Platform.OS === &apos;android&apos; || width &lt; 768;

  return isMobile ? &lt;MobileLayout /&gt; : &lt;DesktopLayout /&gt;;
}</file><file path="app/notification.tsx">/*import React from &apos;react&apos;;
import { View } from &apos;react-native&apos;;
import { ChatInterface } from &apos;@/components/ChatInterface&apos;;
import { useTheme } from &apos;@/contexts/ThemeContext&apos;;
import styles from &apos;./styles/global&apos;;

export default function NotificationScreen() {
  const { themeColor } = useTheme();
  const recentMessages = [
    { sender: &quot;Batcomputer&quot;, message: &quot;Fred, today&apos;s your last day to get your medication refilled.&quot; },
    { sender: &quot;Batcomputer&quot;, message: &quot;The pharmacy closes at 3PM, so you&apos;ve got 5 hours.&quot;},
    { sender: &quot;You&quot;, message: &quot;I don&apos;t feel like going out right now.&quot; },
    { sender: &quot;Batcomputer&quot;, message: &quot;Then I&apos;ll set a reminder for after lunch.&quot; },
    { sender: &quot;Batcomputer&quot;, message: &quot;Please make sure to get this done, you know how much better you feel when medicated.&quot; },
  ];

  return (
    &lt;View style={[styles.container, { backgroundColor: &apos;#181818&apos; }]}&gt;
      &lt;ChatInterface themeColor={themeColor} recentMessages={recentMessages} /&gt;
    &lt;/View&gt;
  );
}
*/</file><file path="app/quests.tsx">import { QuestsOverview } from &apos;@/components/QuestsOverview&apos;;

export default function QuestsPage() {
  return &lt;QuestsOverview /&gt;;
}</file><file path="app/styles/global.js">import { StyleSheet, Platform } from &apos;react-native&apos;;

/**
 * A refined dark theme leveraging subtle gradients, rounded corners, 
 * modern font pairings, soft shadows, and increased spacing to improve 
 * readability and visual hierarchy. 
 * 
 * Note: 
 * - For gradient backgrounds, consider using libraries such as 
 *   &quot;react-native-linear-gradient&quot; or &quot;expo-linear-gradient&quot; and 
 *   wrapping relevant components accordingly.
 * - For animations (hover, loading, transitions), consider using
 *   React Native&apos;s Animated API or third-party libraries like
 *   &quot;react-native-reanimated&quot; or Lottie for more advanced Interactions.
 */
const styles = StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: Platform.select({
      ios: &apos;column&apos;,
      android: &apos;column&apos;,
      default: &apos;row&apos;
    }),
    backgroundColor: &apos;#1E1E1E&apos;, // Base dark background
    padding: Platform.select({
      ios: 10,
      android: 10,
      default: 16
    }),               // Increased padding for more whitespace
  },
  column: {
    flex: 1,
    marginHorizontal: 8,       // Slightly larger horizontal margin
    height: &apos;100%&apos;,
  },
  chatCard: {
    flex: 1,
    padding: 16,
    backgroundColor: &apos;#333&apos;,
    borderRadius: 12,          // Subtle rounded corners
    margin: Platform.select({
      ios: 10,
      android: 10,
      default: 0
    }),
    // Soft shadow for depth
    shadowColor: &apos;#000&apos;,
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3,
  },
  chatScroll: {
    flex: 1,
  },
  leftColumn: {
    flex: 1,
    marginRight: 10,
  },
  rightColumn: {
    flex: 1,
    flexDirection: &apos;column&apos;,
  },
  chatContainer: {
    flex: 1,
    marginBottom: 10,
  },
  mainQuestContainer: {
    flex: 2,
    marginBottom: 10,
  },
  mainQuestCard: {
    padding: 20,
    backgroundColor: &apos;#222&apos;,
    borderRadius: 16,
    // Slightly stronger shadow for main quest
    shadowColor: &apos;#000&apos;,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 6,
    elevation: 4,
  },

  // Modern chat bubble styling
  userMessage: {
    alignSelf: &apos;flex-end&apos;,
    backgroundColor: &apos;#007BFF&apos;, // Accent color (can be customized)
    padding: 12,
    paddingHorizontal: 20, // Increased horizontal padding
    borderRadius: 16,
    marginVertical: 5,
    maxWidth: &apos;75%&apos;,
    marginHorizontal: 16, // Increased horizontal margin
    // Font recommendations
    fontFamily: &apos;Inter_400Regular&apos;, // Example UI font
  },
  aiMessage: {
    alignSelf: &apos;flex-start&apos;,
    backgroundColor: &apos;#444&apos;,
    padding: 12,
    paddingHorizontal: 20, // Increased horizontal padding
    borderRadius: 16,
    marginVertical: 5,
    maxWidth: &apos;75%&apos;,
    marginHorizontal: 8, // Increased horizontal margin
    // Font recommendations
    fontFamily: &apos;Inter_400Regular&apos;, // Example UI font
  },
  messageSender: {
    fontWeight: &apos;bold&apos;,
    color: &apos;#FFF&apos;,
    fontFamily: &apos;Poppins_700Bold&apos;, // Example heading font
  },
  messageText: {
    color: &apos;#FFF&apos;,
    fontFamily: &apos;Inter_400Regular&apos;,
  },
  chatMessage: {
    color: &apos;#FFF&apos;,
    fontStyle: &apos;italic&apos;,
    fontFamily: &apos;Inter_400Regular&apos;,
  },

  // Kanban-related styles
  kanbanTaskCard: {
    padding: 10,
    backgroundColor: &apos;#333&apos;,
    marginVertical: 5,
    borderRadius: 12,
    // Soft shadow
    shadowColor: &apos;#000&apos;,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3,
  },
  mainQuestTitle: {
    fontSize: 22,
    fontWeight: &apos;bold&apos;,
    color: &apos;#FFF&apos;,
    marginBottom: 10,
    fontFamily: &apos;Poppins_700Bold&apos;,
  },
  kanbanContainer: {
    flexDirection: &apos;row&apos;,
    justifyContent: &apos;space-between&apos;,
    marginBottom: 10,
  },
  kanbanColumn: {
    flex: 1,
    marginHorizontal: 5,
  },
  kanbanTitle: {
    fontSize: 16,
    fontWeight: &apos;bold&apos;,
    color: &apos;#AAA&apos;,
    fontFamily: &apos;Poppins_700Bold&apos;,
  },
  kanbanTask: {
    fontSize: 14,
    color: &apos;#CCC&apos;,
    marginVertical: 3,
    fontFamily: &apos;Inter_400Regular&apos;,
  },

  // Task-related styles
  taskContainer: {
    flex: 1,
    marginBottom: 10,
  },
  taskCard: {
    padding: 15,
    backgroundColor: &apos;#444&apos;,
    marginBottom: 10,
    borderRadius: 12,
    // Soft shadow
    shadowColor: &apos;#000&apos;,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3,
  },
  cardTitle: {
    fontSize: 18,
    fontWeight: &apos;bold&apos;,
    color: &apos;#FFF&apos;,
    marginBottom: 5,
    fontFamily: &apos;Poppins_700Bold&apos;,
  },
  cardDetails: {
    fontSize: 14,
    color: &apos;#BBB&apos;,
    marginBottom: 5,
    fontFamily: &apos;Inter_400Regular&apos;,
  },
  cardQuest: {
    color: &apos;#FFF&apos;,
    fontSize: 14,
    fontStyle: &apos;italic&apos;,
    fontFamily: &apos;Inter_400Regular&apos;,
  },

  // Chat input &amp; theme selector
  chatInput: {
    backgroundColor: &apos;#222&apos;,
    color: &apos;white&apos;,
    marginVertical: 10,
    padding: 10,
    borderRadius: 12,
    fontFamily: &apos;Inter_400Regular&apos;,
  },
  themeSelector: {
    position: &apos;absolute&apos;,
    top: 10,
    left: 10,
    flexDirection: &apos;row&apos;,
    alignItems: &apos;center&apos;,
  },
  gearIcon: {
    marginRight: 5,
    color: &apos;white&apos;,
  },
  colorInput: {
    backgroundColor: &apos;#222&apos;,
    color: &apos;white&apos;,
    padding: 5,
    borderRadius: 12,
    fontFamily: &apos;Inter_400Regular&apos;,
  },

  // Task list &amp; toggles
  taskListContainer: {
    flex: 1,
    alignItems: &apos;center&apos;,
    marginTop: 10,
  },
  toggleButton: {
    backgroundColor: &apos;#444&apos;,
    padding: 12,
    borderRadius: 12,
    marginBottom: 10,
    // Soft shadow
    shadowColor: &apos;#000&apos;,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 2,
  },
  toggleButtonText: {
    color: &apos;white&apos;,
    fontSize: 16,
    fontFamily: &apos;Inter_400Regular&apos;,
  },

  // Mobile-specific styles
  mobileHeader: {
    height: 50,
    backgroundColor: &apos;#222&apos;,
    justifyContent: &apos;center&apos;,
    alignItems: &apos;center&apos;,
    borderBottomWidth: 1,
    borderBottomColor: &apos;#444&apos;,
  },
  mobileHeaderText: {
    color: &apos;#FFF&apos;,
    fontSize: 20,
    fontWeight: &apos;bold&apos;,
  },
  mobileContent: {
    flex: 1,
    padding: 10,
  },
  mobileNavigation: {
    height: 60,
    backgroundColor: &apos;#222&apos;,
    borderTopWidth: 1,
    borderTopColor: &apos;#333&apos;,
    justifyContent: &apos;center&apos;,
    alignItems: &apos;center&apos;,
    zIndex: 100,
    position: &apos;relative&apos;,
  },
  mobileNavButton: {
    padding: 10,
    borderRadius: 8,
    minWidth: 80,
    alignItems: &apos;center&apos;,
  },
  mobileNavButtonActive: {
    backgroundColor: &apos;#444&apos;,
  },
  mobileNavText: {
    color: &apos;#FFF&apos;,
    fontSize: 14,
  },
  placeholderText: {
    color: &apos;#888&apos;,
    fontSize: 16,
    textAlign: &apos;center&apos;,
    marginTop: 20,
  },
  mobileNavButton: {
    flex: 1,
    padding: 10,
    alignItems: &apos;center&apos;,
    borderRadius: 8,
  },
  mobileNavButtonActive: {
    backgroundColor: &apos;#333&apos;,
  },
  mobileNavText: {
    color: &apos;white&apos;,
    fontSize: 16,
  },

  customChatContainer: {
    flex: 1,
    margin: 10,
    backgroundColor: &apos;#333&apos;,
    borderRadius: 12,
    borderWidth: 2,
    overflow: &apos;hidden&apos;,
    shadowColor: &apos;#000&apos;,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.25,
    shadowRadius: 8,
    elevation: 5,
  },
  
  chatHeader: {
    padding: 16,
    backgroundColor: &apos;#2A2A2A&apos;,
    borderBottomWidth: 1,
    borderBottomColor: &apos;#444&apos;,
  },

  hamburgerButton: {
    width: Platform.select({ ios: 40, android: 40, default: 48 }),
    height: Platform.select({ ios: 40, android: 40, default: 48 }),
    borderRadius: 24,
    justifyContent: &apos;center&apos;,
    alignItems: &apos;center&apos;,
    elevation: 5,
  },
  hamburgerButtonMobile: {
    backgroundColor: &apos;transparent&apos;,
    shadowOpacity: 0,
  },
  hamburgerButtonPressed: {
    opacity: 0.8,
    transform: [{ scale: 0.97 }],
  },

  viewAllQuests: {
    padding: 10,
    borderRadius: 8,
    marginVertical: 10,
    alignItems: &apos;center&apos;,
  },
  viewAllQuestsText: {
    fontSize: 14,
    fontWeight: &apos;bold&apos;,
    fontFamily: &apos;Inter_700Bold&apos;,
  },

  questTasksContainer: {
    marginTop: 20,
    paddingTop: 20,
    borderTopWidth: 1,
    borderTopColor: &apos;#444&apos;,
  },

  setMainQuestButton: {
    padding: 8,
    borderRadius: 8,
    marginLeft: 10,
  },
  setMainQuestButtonText: {
    color: &apos;#fff&apos;,
    fontSize: 12,
    fontWeight: &apos;bold&apos;,
    fontFamily: &apos;Inter_700Bold&apos;,
  },

  statusTimestamp: {
    color: &apos;#FFF&apos;,
    fontSize: 12,
    fontFamily: &apos;Inter_700Bold&apos;,
    marginBottom: 5,
  },
});

export default styles;</file><file path="app/types.ts">export interface Task {
  id: number;  // Changed from string to number
  title: string;
  location: string;
  scheduledFor: string;
  deadline?: string;
  quest?: string;  // Add quest field
}

export interface KanbanBoard {
  ToDo: string[];
  InProgress: string[];
  Done: string[];
}

export interface MainQuest {
  title: string;
  progress: string;
  kanban: KanbanBoard;
}

export interface ChatMessage {
  isUser: boolean;  // Replace sender string with boolean
  message: string;
}

export interface Quest {
  id: number;
  title: string;
  status: &apos;Active&apos; | &apos;On-Hold&apos; | &apos;Completed&apos;;
  shortDescription: string;
  questStatus: string;
  analysis: string; // Add this field for structured XML data
  progress: string;
  tasks: Task[];
  kanban?: KanbanBoard;
  isMain?: boolean;
  currentStatus: {
    timestamp: string;
    message: string;
  };
}

export default {};</file><file path="components/__tests__/__snapshots__/ThemedText-test.tsx.snap">// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`renders correctly 1`] = `
&lt;Text
  style={
    [
      {
        &quot;color&quot;: &quot;#11181C&quot;,
      },
      {
        &quot;fontSize&quot;: 16,
        &quot;lineHeight&quot;: 24,
      },
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
    ]
  }
&gt;
  Snapshot test!
&lt;/Text&gt;
`;</file><file path="components/__tests__/ThemedText-test.tsx">import * as React from &apos;react&apos;;
import renderer from &apos;react-test-renderer&apos;;

import { ThemedText } from &apos;../ThemedText&apos;;

it(`renders correctly`, () =&gt; {
  const tree = renderer.create(&lt;ThemedText&gt;Snapshot test!&lt;/ThemedText&gt;).toJSON();

  expect(tree).toMatchSnapshot();
});</file><file path="components/ChatInterface.tsx">import React from &apos;react&apos;;
import { View, Text, ScrollView, TextInput } from &apos;react-native&apos;;
import styles from &apos;@/app/styles/global&apos;;
import { ChatMessage } from &apos;@/app/types&apos;;

interface ChatInterfaceProps {
  themeColor: string;
  recentMessages: ChatMessage[];
}

export const ChatInterface: React.FC&lt;ChatInterfaceProps&gt; = ({ 
    themeColor, 
    recentMessages 
}) =&gt; {

  const isDarkColor = (color: string) =&gt; {
    const hex = color.replace(&apos;#&apos;, &apos;&apos;);
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    return brightness &lt; 128;
  };

  const textColor = isDarkColor(themeColor) ? &apos;#fff&apos; : &apos;#000&apos;;

  return (
    &lt;View style={[styles.customChatContainer, { borderColor: themeColor }]}&gt;
      &lt;View style={styles.chatHeader}&gt;
        &lt;Text style={styles.cardTitle}&gt;Neural Link&lt;/Text&gt;
      &lt;/View&gt;
      &lt;ScrollView style={styles.chatScroll}&gt;
        {recentMessages?.map((msg: ChatMessage, index: number) =&gt; (
          &lt;View key={index} style={[
            msg.isUser ? styles.userMessage : styles.aiMessage,
            msg.isUser &amp;&amp; { backgroundColor: themeColor }
          ]}&gt;
            &lt;Text style={[styles.messageText, msg.isUser &amp;&amp; { color: textColor }]}&gt;
              {msg.message}
            &lt;/Text&gt;
          &lt;/View&gt;
        ))}
      &lt;/ScrollView&gt;
      &lt;TextInput 
        style={styles.chatInput} 
        placeholder=&quot;What&apos;s on your mind?&quot; 
        placeholderTextColor=&apos;#AAA&apos;
      /&gt;
    &lt;/View&gt;
  );
};</file><file path="components/Collapsible.tsx">import { PropsWithChildren, useState } from &apos;react&apos;;
import { StyleSheet, TouchableOpacity } from &apos;react-native&apos;;

import { ThemedText } from &apos;@/components/ThemedText&apos;;
import { ThemedView } from &apos;@/components/ThemedView&apos;;
import { IconSymbol } from &apos;@/components/ui/IconSymbol&apos;;
import { Colors } from &apos;@/constants/Colors&apos;;
import { useColorScheme } from &apos;@/hooks/useColorScheme&apos;;

export function Collapsible({ children, title }: PropsWithChildren &amp; { title: string }) {
  const [isOpen, setIsOpen] = useState(false);
  const theme = useColorScheme() ?? &apos;light&apos;;

  return (
    &lt;ThemedView&gt;
      &lt;TouchableOpacity
        style={styles.heading}
        onPress={() =&gt; setIsOpen((value) =&gt; !value)}
        activeOpacity={0.8}&gt;
        &lt;IconSymbol
          name=&quot;chevron.right&quot;
          size={18}
          weight=&quot;medium&quot;
          color={theme === &apos;light&apos; ? Colors.light.icon : Colors.dark.icon}
          style={{ transform: [{ rotate: isOpen ? &apos;90deg&apos; : &apos;0deg&apos; }] }}
        /&gt;

        &lt;ThemedText type=&quot;defaultSemiBold&quot;&gt;{title}&lt;/ThemedText&gt;
      &lt;/TouchableOpacity&gt;
      {isOpen &amp;&amp; &lt;ThemedView style={styles.content}&gt;{children}&lt;/ThemedView&gt;}
    &lt;/ThemedView&gt;
  );
}

const styles = StyleSheet.create({
  heading: {
    flexDirection: &apos;row&apos;,
    alignItems: &apos;center&apos;,
    gap: 6,
  },
  content: {
    marginTop: 6,
    marginLeft: 24,
  },
});</file><file path="components/ExternalLink.tsx">import { Link } from &apos;expo-router&apos;;
import { openBrowserAsync } from &apos;expo-web-browser&apos;;
import { type ComponentProps } from &apos;react&apos;;
import { Platform } from &apos;react-native&apos;;

type Props = Omit&lt;ComponentProps&lt;typeof Link&gt;, &apos;href&apos;&gt; &amp; { href: string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    &lt;Link
      target=&quot;_blank&quot;
      {...rest}
      href={href}
      onPress={async (event) =&gt; {
        if (Platform.OS !== &apos;web&apos;) {
          // Prevent the default behavior of linking to the default browser on native.
          event.preventDefault();
          // Open the link in an in-app browser.
          await openBrowserAsync(href);
        }
      }}
    /&gt;
  );
}</file><file path="components/HapticTab.tsx">import { BottomTabBarButtonProps } from &apos;@react-navigation/bottom-tabs&apos;;
import { PlatformPressable } from &apos;@react-navigation/elements&apos;;
import * as Haptics from &apos;expo-haptics&apos;;

export function HapticTab(props: BottomTabBarButtonProps) {
  return (
    &lt;PlatformPressable
      {...props}
      onPressIn={(ev) =&gt; {
        if (process.env.EXPO_OS === &apos;ios&apos;) {
          // Add a soft haptic feedback when pressing down on the tabs.
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        }
        props.onPressIn?.(ev);
      }}
    /&gt;
  );
}</file><file path="components/HelloWave.tsx">import { useEffect } from &apos;react&apos;;
import { StyleSheet } from &apos;react-native&apos;;
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withRepeat,
  withSequence,
} from &apos;react-native-reanimated&apos;;

import { ThemedText } from &apos;@/components/ThemedText&apos;;

export function HelloWave() {
  const rotationAnimation = useSharedValue(0);

  useEffect(() =&gt; {
    rotationAnimation.value = withRepeat(
      withSequence(withTiming(25, { duration: 150 }), withTiming(0, { duration: 150 })),
      4 // Run the animation 4 times
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() =&gt; ({
    transform: [{ rotate: `${rotationAnimation.value}deg` }],
  }));

  return (
    &lt;Animated.View style={animatedStyle}&gt;
      &lt;ThemedText style={styles.text}&gt;ðŸ‘‹&lt;/ThemedText&gt;
    &lt;/Animated.View&gt;
  );
}

const styles = StyleSheet.create({
  text: {
    fontSize: 28,
    lineHeight: 32,
    marginTop: -6,
  },
});</file><file path="components/layouts/DesktopLayout.tsx">import React from &apos;react&apos;;
import { View, Text, FlatList, TouchableOpacity, Animated } from &apos;react-native&apos;;
import { Card } from &apos;react-native-paper&apos;;
import { ChatInterface } from &apos;@/components/ChatInterface&apos;;
import { SettingsButton } from &apos;@/components/ui/SettingsButton&apos;;
import { useChatData } from &apos;@/hooks/useChatData&apos;;
import { useTaskData } from &apos;@/hooks/useTaskData&apos;;
import { useQuestData } from &apos;@/hooks/useQuestData&apos;;
import { useTheme } from &apos;@/contexts/ThemeContext&apos;;
import { useRouter } from &apos;expo-router&apos;;
import styles from &apos;@/app/styles/global&apos;;

export function DesktopLayout() {
  const router = useRouter();
  const { themeColor } = useTheme();
  const { messages } = useChatData();
  const { tasks, taskListVisible, animatedHeight, toggleTaskList } = useTaskData();
  const { mainQuest } = useQuestData();

  const isDarkColor = (color: string) =&gt; {
    const hex = color.replace(&apos;#&apos;, &apos;&apos;);
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    return brightness &lt; 128;
  };

  const textColor = isDarkColor(themeColor) ? &apos;#fff&apos; : &apos;#000&apos;;

  return (
    &lt;View style={[styles.container, { backgroundColor: &apos;#181818&apos; }]}&gt; 
      &lt;View style={styles.column}&gt;
        &lt;Card style={[styles.mainQuestCard, { borderColor: themeColor, borderWidth: 2 }]}&gt; 
          &lt;Text style={styles.mainQuestTitle}&gt;{mainQuest.title}&lt;/Text&gt;
          &lt;Text style={styles.cardDetails}&gt;Progress: {mainQuest.progress}&lt;/Text&gt;
          &lt;TouchableOpacity 
            onPress={() =&gt; router.push(&apos;/quests&apos;)}
            style={[styles.viewAllQuests, { backgroundColor: themeColor }]}
          &gt;
            &lt;Text style={[styles.viewAllQuestsText, { color: textColor }]}&gt;
              View All Quests
            &lt;/Text&gt;
          &lt;/TouchableOpacity&gt;
          &lt;View style={styles.kanbanContainer}&gt;
            {Object.keys(mainQuest.kanban).map((status) =&gt; (
              &lt;View key={status} style={styles.kanbanColumn}&gt;
                &lt;Text style={styles.kanbanTitle}&gt;{status.replace(/([A-Z])/g, &apos; $1&apos;)}&lt;/Text&gt;
                {mainQuest.kanban[status as keyof typeof mainQuest.kanban].map((task: string, index: number) =&gt; (
                  &lt;Card key={index} style={styles.kanbanTaskCard}&gt;
                    &lt;Text style={styles.kanbanTask}&gt;{task}&lt;/Text&gt;
                  &lt;/Card&gt;
                ))}
              &lt;/View&gt;
            ))}
          &lt;/View&gt;
        &lt;/Card&gt;
      &lt;/View&gt;

      &lt;View style={styles.column}&gt;
        &lt;ChatInterface themeColor={themeColor} recentMessages={messages} /&gt;
      &lt;/View&gt;
      
      &lt;View style={styles.column}&gt;
        &lt;TouchableOpacity 
          onPress={toggleTaskList} 
          style={[styles.toggleButton, { backgroundColor: themeColor }]}&gt;
          &lt;Text style={[styles.toggleButtonText, { color: textColor }]}&gt;
            {taskListVisible ? &quot;Hide Tasks&quot; : &quot;Show Upcoming Tasks&quot;}
          &lt;/Text&gt;
        &lt;/TouchableOpacity&gt;
        &lt;Animated.View style={[
          styles.taskContainer,
          {
            maxHeight: animatedHeight.interpolate({
              inputRange: [0, 1],
              outputRange: [&apos;0%&apos;, &apos;100%&apos;]
            }),
            opacity: animatedHeight
          }
        ]}&gt;
          &lt;FlatList
            data={tasks}
            keyExtractor={(item) =&gt; item.id.toString()}
            renderItem={({ item }) =&gt; (
              &lt;Card style={[styles.taskCard, { borderColor: themeColor, borderWidth: 2 }]}&gt; 
                &lt;Text style={styles.cardTitle}&gt;{item.title}&lt;/Text&gt;
                &lt;Text style={styles.cardDetails}&gt;Start: {item.scheduledFor} ({item.location})&lt;/Text&gt;
                {item.deadline &amp;&amp; (
                  &lt;Text style={[styles.cardDetails, { color: &apos;#FF4444&apos; }]}&gt;
                    Deadline: {item.deadline}
                  &lt;/Text&gt;
                )}
                &lt;Text style={styles.cardQuest}&gt;Quest: {item.quest}&lt;/Text&gt;
              &lt;/Card&gt;
            )}
          /&gt;
        &lt;/Animated.View&gt;
      &lt;/View&gt;
      &lt;SettingsButton /&gt;
    &lt;/View&gt;
  );
}</file><file path="components/layouts/MobileLayout.tsx">import React from &apos;react&apos;;
import { View, Text } from &apos;react-native&apos;;
import { SafeAreaView } from &apos;react-native-safe-area-context&apos;; // Install if needed
import { ChatInterface } from &apos;@/components/ChatInterface&apos;;
import { HamburgerMenu } from &apos;@/components/ui/HamburgerMenu&apos;;
import { useChatData } from &apos;@/hooks/useChatData&apos;;
import styles from &apos;@/app/styles/global&apos;;

const MobileNavigation: React.FC = () =&gt; (
  &lt;View style={styles.mobileNavigation}&gt;
    &lt;HamburgerMenu /&gt;
  &lt;/View&gt;
);

export function MobileLayout() {
  const { messages, themeColor } = useChatData();

  return (
    &lt;SafeAreaView style={{ flex: 1, backgroundColor: &apos;#181818&apos; }}&gt;
      &lt;View style={styles.mobileHeader}&gt;
        &lt;Text style={styles.mobileHeaderText}&gt;QuestLog&lt;/Text&gt;
      &lt;/View&gt;
      
      &lt;View style={styles.mobileContent}&gt;
        &lt;ChatInterface 
          themeColor={themeColor} 
          recentMessages={messages}
        /&gt;
      &lt;/View&gt;
      
      &lt;MobileNavigation /&gt;
    &lt;/SafeAreaView&gt;
  );
}</file><file path="components/ParallaxScrollView.tsx">import type { PropsWithChildren, ReactElement } from &apos;react&apos;;
import { StyleSheet } from &apos;react-native&apos;;
import Animated, {
  interpolate,
  useAnimatedRef,
  useAnimatedStyle,
  useScrollViewOffset,
} from &apos;react-native-reanimated&apos;;

import { ThemedView } from &apos;@/components/ThemedView&apos;;
import { useBottomTabOverflow } from &apos;@/components/ui/TabBarBackground&apos;;
import { useColorScheme } from &apos;@/hooks/useColorScheme&apos;;

const HEADER_HEIGHT = 250;

type Props = PropsWithChildren&lt;{
  headerImage: ReactElement;
  headerBackgroundColor: { dark: string; light: string };
}&gt;;

export default function ParallaxScrollView({
  children,
  headerImage,
  headerBackgroundColor,
}: Props) {
  const colorScheme = useColorScheme() ?? &apos;light&apos;;
  const scrollRef = useAnimatedRef&lt;Animated.ScrollView&gt;();
  const scrollOffset = useScrollViewOffset(scrollRef);
  const bottom = useBottomTabOverflow();
  const headerAnimatedStyle = useAnimatedStyle(() =&gt; {
    return {
      transform: [
        {
          translateY: interpolate(
            scrollOffset.value,
            [-HEADER_HEIGHT, 0, HEADER_HEIGHT],
            [-HEADER_HEIGHT / 2, 0, HEADER_HEIGHT * 0.75]
          ),
        },
        {
          scale: interpolate(scrollOffset.value, [-HEADER_HEIGHT, 0, HEADER_HEIGHT], [2, 1, 1]),
        },
      ],
    };
  });

  return (
    &lt;ThemedView style={styles.container}&gt;
      &lt;Animated.ScrollView
        ref={scrollRef}
        scrollEventThrottle={16}
        scrollIndicatorInsets={{ bottom }}
        contentContainerStyle={{ paddingBottom: bottom }}&gt;
        &lt;Animated.View
          style={[
            styles.header,
            { backgroundColor: headerBackgroundColor[colorScheme] },
            headerAnimatedStyle,
          ]}&gt;
          {headerImage}
        &lt;/Animated.View&gt;
        &lt;ThemedView style={styles.content}&gt;{children}&lt;/ThemedView&gt;
      &lt;/Animated.ScrollView&gt;
    &lt;/ThemedView&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    height: HEADER_HEIGHT,
    overflow: &apos;hidden&apos;,
  },
  content: {
    flex: 1,
    padding: 32,
    gap: 16,
    overflow: &apos;hidden&apos;,
  },
});</file><file path="components/QuestsOverview.tsx">import React, { useState } from &apos;react&apos;;
import { View, Text, TouchableOpacity, FlatList, ScrollView, Dimensions } from &apos;react-native&apos;;
import { Card } from &apos;react-native-paper&apos;;
import { useTheme } from &apos;@/contexts/ThemeContext&apos;;
import styles from &apos;@/app/styles/global&apos;;
import { useQuestData } from &apos;@/hooks/useQuestData&apos;;
import { Quest } from &apos;@/app/types&apos;;

type QuestStatus = &apos;Active&apos; | &apos;On-Hold&apos; | &apos;Completed&apos;;

export function QuestsOverview() {
  const { quests, setQuestAsMain } = useQuestData();
  const { themeColor } = useTheme();
  const [activeTab, setActiveTab] = useState&lt;QuestStatus&gt;(&apos;Active&apos;);
  const [selectedQuest, setSelectedQuest] = useState&lt;Quest | null&gt;(null);
  const windowHeight = Dimensions.get(&apos;window&apos;).height;

  const filteredQuests = quests.filter(q =&gt; q.status === activeTab);

  const tabs: QuestStatus[] = [&apos;Active&apos;, &apos;On-Hold&apos;, &apos;Completed&apos;];

  const getQuestCardColor = (quest: Quest) =&gt; {
    if (quest.isMain) {
      // Create a less saturated version of themeColor
      const hex = themeColor.replace(&apos;#&apos;, &apos;&apos;);
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);
      const desaturate = 0.5; // 50% desaturation
      const gray = (r + g + b) / 3;
      const newR = Math.round(r * (1 - desaturate) + gray * desaturate);
      const newG = Math.round(g * (1 - desaturate) + gray * desaturate);
      const newB = Math.round(b * (1 - desaturate) + gray * desaturate);
      return `#${newR.toString(16).padStart(2, &apos;0&apos;)}${newG.toString(16).padStart(2, &apos;0&apos;)}${newB.toString(16).padStart(2, &apos;0&apos;)}`;
    }
    return themeColor;
  };

  return (
    &lt;View style={[styles.container, { backgroundColor: &apos;#181818&apos;, height: windowHeight }]}&gt;
      &lt;View style={styles.column}&gt;
        &lt;Card style={[styles.mainQuestCard, { borderColor: themeColor, borderWidth: 2, height: windowHeight * 0.95 }]}&gt;
          &lt;View style={{ flexDirection: &apos;row&apos;, marginBottom: 20 }}&gt;
            {tabs.map(tab =&gt; (
              &lt;TouchableOpacity 
                key={tab} 
                onPress={() =&gt; setActiveTab(tab)}
                style={[
                  styles.toggleButton,
                  { 
                    backgroundColor: activeTab === tab ? themeColor : &apos;#333&apos;,
                    marginRight: 10,
                    flex: 1
                  }
                ]}
              &gt;
                &lt;Text style={[
                  styles.toggleButtonText,
                  { color: activeTab === tab ? &apos;#fff&apos; : &apos;#aaa&apos; }
                ]}&gt;
                  {tab}
                &lt;/Text&gt;
              &lt;/TouchableOpacity&gt;
            ))}
          &lt;/View&gt;

          &lt;View style={{ flexDirection: &apos;row&apos;, flex: 1 }}&gt;
            &lt;View style={{ flex: 1, marginRight: 20, maxHeight: windowHeight * 0.8 }}&gt;
              &lt;FlatList
                style={{ flex: 1 }}
                data={filteredQuests}
                keyExtractor={(item) =&gt; item.id.toString()}
                renderItem={({ item }) =&gt; (
                  &lt;TouchableOpacity onPress={() =&gt; setSelectedQuest(item)}&gt;
                    &lt;Card style={[
                      styles.taskCard,
                      { 
                        borderColor: item.isMain ? getQuestCardColor(item) : themeColor,
                        borderWidth: item.isMain ? 3 : selectedQuest?.id === item.id ? 2 : 0,
                        backgroundColor: item.isMain ? `${getQuestCardColor(item)}22` : &apos;#444&apos;,
                        // Add shadow for main quest
                        ...(item.isMain &amp;&amp; {
                          shadowColor: getQuestCardColor(item),
                          shadowOffset: { width: 0, height: 0 },
                          shadowOpacity: 0.5,
                          shadowRadius: 8,
                          elevation: 6,
                        })
                      }
                    ]}&gt;
                      &lt;Text style={styles.cardTitle}&gt;{item.title}&lt;/Text&gt;
                      &lt;Text style={styles.cardDetails}&gt;Tasks: {item.tasks.length}&lt;/Text&gt;
                      &lt;Text style={styles.cardDetails}&gt;Progress: {item.progress}&lt;/Text&gt;
                    &lt;/Card&gt;
                  &lt;/TouchableOpacity&gt;
                )}
              /&gt;
            &lt;/View&gt;

            &lt;View style={{ flex: 1, maxHeight: windowHeight * 0.8 }}&gt;
              {selectedQuest ? (
                &lt;ScrollView style={{ flex: 1 }} bounces={false}&gt;
                  &lt;Card style={[styles.mainQuestCard, { 
                    borderColor: themeColor, 
                    borderWidth: 2 
                  }]}&gt;
                    &lt;View style={{ flexDirection: &apos;row&apos;, justifyContent: &apos;space-between&apos;, alignItems: &apos;center&apos; }}&gt;
                      &lt;Text style={styles.mainQuestTitle}&gt;{selectedQuest.title}&lt;/Text&gt;
                      &lt;TouchableOpacity 
                        onPress={() =&gt; setQuestAsMain(selectedQuest.id)}
                        style={[
                          styles.setMainQuestButton,
                          { 
                            backgroundColor: selectedQuest.isMain ? &apos;#666&apos; : themeColor,
                            opacity: selectedQuest.isMain ? 0.7 : 1
                          }
                        ]}
                      &gt;
                        &lt;Text style={styles.setMainQuestButtonText}&gt;
                          {selectedQuest.isMain ? &apos;Main Quest&apos; : &apos;Set as Main Quest&apos;}
                        &lt;/Text&gt;
                      &lt;/TouchableOpacity&gt;
                    &lt;/View&gt;
                    &lt;Text style={styles.cardDetails}&gt;{selectedQuest.shortDescription}&lt;/Text&gt;
                    
                    &lt;Card style={[styles.taskCard, { borderColor: themeColor, borderWidth: 1 }]}&gt;
                      &lt;Text style={styles.statusTimestamp}&gt;[{selectedQuest.currentStatus.timestamp}]&lt;/Text&gt;
                      &lt;Text style={styles.cardDetails}&gt;{selectedQuest.currentStatus.message}&lt;/Text&gt;
                    &lt;/Card&gt;

                    &lt;Card style={[styles.taskCard, { borderColor: themeColor, borderWidth: 1 }]}&gt;
                      &lt;Text style={styles.cardDetails}&gt;{selectedQuest.questStatus}&lt;/Text&gt;
                    &lt;/Card&gt;
                    
                    &lt;View style={styles.questTasksContainer}&gt;
                      &lt;Text style={[styles.cardTitle, { marginTop: 10 }]}&gt;
                        Current Tasks ({selectedQuest.tasks.length})
                      &lt;/Text&gt;
                      {selectedQuest.tasks.map((task) =&gt; (
                        &lt;Card 
                          key={task.id} 
                          style={[styles.taskCard, { borderColor: themeColor, borderWidth: 1 }]}
                        &gt;
                          &lt;Text style={styles.cardTitle}&gt;{task.title}&lt;/Text&gt;
                          &lt;Text style={styles.cardDetails}&gt;
                            Start: {task.scheduledFor} ({task.location})
                          &lt;/Text&gt;
                          {task.deadline &amp;&amp; (
                            &lt;Text style={[styles.cardDetails, { color: &apos;#FF4444&apos; }]}&gt;
                              Deadline: {task.deadline}
                            &lt;/Text&gt;
                          )}
                        &lt;/Card&gt;
                      ))}
                    &lt;/View&gt;
                  &lt;/Card&gt;
                &lt;/ScrollView&gt;
              ) : (
                &lt;Card style={[styles.mainQuestCard, { borderColor: themeColor, borderWidth: 2 }]}&gt;
                  &lt;Text style={styles.cardDetails}&gt;Select a quest to view details&lt;/Text&gt;
                &lt;/Card&gt;
              )}
            &lt;/View&gt;
          &lt;/View&gt;
        &lt;/Card&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  );
}</file><file path="components/ThemedText.tsx">import { Text, type TextProps, StyleSheet } from &apos;react-native&apos;;

import { useThemeColor } from &apos;@/hooks/useThemeColor&apos;;

export type ThemedTextProps = TextProps &amp; {
  lightColor?: string;
  darkColor?: string;
  type?: &apos;default&apos; | &apos;title&apos; | &apos;defaultSemiBold&apos; | &apos;subtitle&apos; | &apos;link&apos;;
};

export function ThemedText({
  style,
  lightColor,
  darkColor,
  type = &apos;default&apos;,
  ...rest
}: ThemedTextProps) {
  const color = useThemeColor({ light: lightColor, dark: darkColor }, &apos;text&apos;);

  return (
    &lt;Text
      style={[
        { color },
        type === &apos;default&apos; ? styles.default : undefined,
        type === &apos;title&apos; ? styles.title : undefined,
        type === &apos;defaultSemiBold&apos; ? styles.defaultSemiBold : undefined,
        type === &apos;subtitle&apos; ? styles.subtitle : undefined,
        type === &apos;link&apos; ? styles.link : undefined,
        style,
      ]}
      {...rest}
    /&gt;
  );
}

const styles = StyleSheet.create({
  default: {
    fontSize: 16,
    lineHeight: 24,
  },
  defaultSemiBold: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: &apos;600&apos;,
  },
  title: {
    fontSize: 32,
    fontWeight: &apos;bold&apos;,
    lineHeight: 32,
  },
  subtitle: {
    fontSize: 20,
    fontWeight: &apos;bold&apos;,
  },
  link: {
    lineHeight: 30,
    fontSize: 16,
    color: &apos;#0a7ea4&apos;,
  },
});</file><file path="components/ThemedView.tsx">import { View, type ViewProps } from &apos;react-native&apos;;

import { useThemeColor } from &apos;@/hooks/useThemeColor&apos;;

export type ThemedViewProps = ViewProps &amp; {
  lightColor?: string;
  darkColor?: string;
};

export function ThemedView({ style, lightColor, darkColor, ...otherProps }: ThemedViewProps) {
  const backgroundColor = useThemeColor({ light: lightColor, dark: darkColor }, &apos;background&apos;);

  return &lt;View style={[{ backgroundColor }, style]} {...otherProps} /&gt;;
}</file><file path="components/ui/HamburgerMenu.tsx">import { router } from &apos;expo-router&apos;;
import React, { useState } from &apos;react&apos;;
import { Pressable, StyleSheet, Text, View, Platform, useWindowDimensions, ViewStyle } from &apos;react-native&apos;;
import Animated, { 
  useAnimatedStyle, 
  withSpring,
  useSharedValue,
  withTiming,
  Easing
} from &apos;react-native-reanimated&apos;;

import { IconSymbol } from &apos;./IconSymbol&apos;;
import { Colors } from &apos;@/constants/Colors&apos;;
import { useThemeColor } from &apos;@/hooks/useThemeColor&apos;;
import { useTheme } from &apos;@/contexts/ThemeContext&apos;;

const MENU_ITEMS = [
  { name: &apos;Notifications&apos;, icon: &apos;bell.fill&apos;, route: &apos;/notification&apos; },
  { name: &apos;Quests&apos;, icon: &apos;flag&apos;, route: &apos;*/app/quests&apos; },
  { name: &apos;Tasks&apos;, icon: &apos;list.bullet&apos;, route: &apos;*/app/tasks&apos; },
  { name: &apos;Routine&apos;, icon: &apos;clock&apos;, route: &apos;*/app/routine&apos; },
  { name: &apos;Journal&apos;, icon: &apos;book&apos;, route: &apos;*/app/journal&apos; },
  { name: &apos;Profile&apos;, icon: &apos;person&apos;, route: &apos;*/app/profile&apos; },
  { name: &apos;Settings&apos;, icon: &apos;gear&apos;, route: &apos;*/app/settings&apos; },
] as const;

export function HamburgerMenu() {
  const { width } = useWindowDimensions();
  const isMobile = Platform.OS === &apos;ios&apos; || Platform.OS === &apos;android&apos; || width &lt; 768;
  const [isOpen, setIsOpen] = useState(false);
  const menuAnimation = useSharedValue(0);
  const { themeColor } = useTheme(); // Fix: correctly destructure from useTheme

  const menuStyle = useAnimatedStyle(() =&gt; ({
    opacity: withTiming(menuAnimation.value, {
      duration: 200,
      easing: Easing.bezier(0.25, 0.1, 0.25, 1),
    }),
    transform: [
      { 
        translateY: withSpring(menuAnimation.value * -500, { // Increased from -300
          damping: 15,
          stiffness: 100,
        })
      }
    ],
  }));

  const toggleMenu = () =&gt; {
    setIsOpen(!isOpen);
    menuAnimation.value = isOpen ? 0 : 1;
  };

  const buttonStyle = (pressed: boolean): ViewStyle =&gt; ({
    ...styles.hamburgerButton,
    ...(isMobile &amp;&amp; styles.hamburgerButtonMobile),
    ...(pressed &amp;&amp; styles.hamburgerButtonPressed),
    backgroundColor: themeColor,
    shadowColor: themeColor,
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.5,
    shadowRadius: 8,
  });

  return (
    &lt;View style={[
      styles.container,
      isMobile &amp;&amp; styles.containerMobile
    ]}&gt;
      &lt;Pressable 
        onPress={toggleMenu} 
        style={({ pressed }) =&gt; buttonStyle(pressed)}&gt;
        &lt;IconSymbol 
          name={isOpen ? &quot;xmark&quot; : &quot;line.3.horizontal&quot;} 
          size={24} 
          color=&quot;#fff&quot; 
        /&gt;
      &lt;/Pressable&gt;

      {isOpen &amp;&amp; (
        &lt;Animated.View 
          pointerEvents=&quot;box-none&quot;
          style={[
            styles.menu,
            isMobile &amp;&amp; styles.menuMobile,
            menuStyle
          ]}&gt;
          {MENU_ITEMS.map((item) =&gt; (
            &lt;Pressable
              key={item.name}
              style={({ pressed }) =&gt; [
                styles.menuItem,
                pressed &amp;&amp; styles.menuItemPressed
              ]}
              onPress={() =&gt; {
                router.push(item.route as any);
                toggleMenu();
              }}&gt;
              &lt;IconSymbol name={item.icon} size={20} color=&quot;#fff&quot; /&gt;
              &lt;Text style={styles.menuText}&gt;{item.name}&lt;/Text&gt;
            &lt;/Pressable&gt;
          ))}
        &lt;/Animated.View&gt;
      )}
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    position: &apos;absolute&apos;,
    right: 20,
    top: 20,
    zIndex: 1000,
  },
  menu: {
    position: &apos;absolute&apos;,
    top: 60,
    right: 0,
    backgroundColor: Colors.light.background,
    borderRadius: 16,
    padding: 8,
    minWidth: 180,
    shadowColor: &apos;#000&apos;,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 12,
    elevation: 8,
  },
  menuItem: {
    flexDirection: &apos;row&apos;,
    alignItems: &apos;center&apos;,
    padding: 12,
    borderRadius: 8,
    marginVertical: 4,
    backgroundColor: &apos;#333&apos;,
  },
  menuItemPressed: {
    backgroundColor: &apos;#444&apos;,
  },
  menuText: {
    marginLeft: 12,
    fontSize: 16,
    color: &apos;#fff&apos;,
    fontWeight: &apos;500&apos;,
  },
  containerMobile: {
    position: &apos;relative&apos;,
    right: 0,
    width: 60,
    height: 40,
    justifyContent: &apos;center&apos;,
    alignItems: &apos;center&apos;,
    zIndex: 1000,
  },
  menuMobile: {
    position: &apos;absolute&apos;,
    bottom: 120, // Increased from 60
    right: -70, // Centers the 200px wide menu relative to the 60px wide container
    backgroundColor: &apos;#222&apos;,
    borderColor: &apos;#333&apos;,
    borderWidth: 1,
    width: 200,
    minHeight: 280,
    padding: 8,
    borderRadius: 12,
    zIndex: 2000,
  },
  hamburgerButton: {
    width: 48,
    height: 48,
    borderRadius: 24,
    justifyContent: &apos;center&apos;,
    alignItems: &apos;center&apos;,
    elevation: 5,
  },
  hamburgerButtonMobile: {
    width: 40,
    height: 40,
    backgroundColor: &apos;transparent&apos;,
    shadowOpacity: 0,
  },
  hamburgerButtonPressed: {
    opacity: 0.8,
    transform: [{ scale: 0.97 }],
  },
});</file><file path="components/ui/IconSymbol.ios.tsx">import { SymbolView, SymbolViewProps, SymbolWeight } from &apos;expo-symbols&apos;;
import { StyleProp, ViewStyle } from &apos;react-native&apos;;

export function IconSymbol({
  name,
  size = 24,
  color,
  style,
  weight = &apos;regular&apos;,
}: {
  name: SymbolViewProps[&apos;name&apos;];
  size?: number;
  color: string;
  style?: StyleProp&lt;ViewStyle&gt;;
  weight?: SymbolWeight;
}) {
  return (
    &lt;SymbolView
      weight={weight}
      tintColor={color}
      resizeMode=&quot;scaleAspectFit&quot;
      name={name}
      style={[
        {
          width: size,
          height: size,
        },
        style,
      ]}
    /&gt;
  );
}</file><file path="components/ui/IconSymbol.tsx">// This file is a fallback for using MaterialIcons on Android and web.

import MaterialIcons from &apos;@expo/vector-icons/MaterialIcons&apos;;
import { SymbolWeight } from &apos;expo-symbols&apos;;
import React from &apos;react&apos;;
import { OpaqueColorValue, StyleProp, ViewStyle } from &apos;react-native&apos;;

// Add your SFSymbol to MaterialIcons mappings here.
const MAPPING = {
  // See MaterialIcons here: https://icons.expo.fyi
  // See SF Symbols in the SF Symbols app on Mac.
  &apos;house.fill&apos;: &apos;home&apos;,
  &apos;paperplane.fill&apos;: &apos;send&apos;,
  &apos;chevron.left.forwardslash.chevron.right&apos;: &apos;code&apos;,
  &apos;chevron.right&apos;: &apos;chevron-right&apos;,
} as Partial&lt;
  Record&lt;
    import(&apos;expo-symbols&apos;).SymbolViewProps[&apos;name&apos;],
    React.ComponentProps&lt;typeof MaterialIcons&gt;[&apos;name&apos;]
  &gt;
&gt;;

export type IconSymbolName = keyof typeof MAPPING;

/**
 * An icon component that uses native SFSymbols on iOS, and MaterialIcons on Android and web. This ensures a consistent look across platforms, and optimal resource usage.
 *
 * Icon `name`s are based on SFSymbols and require manual mapping to MaterialIcons.
 */
export function IconSymbol({
  name,
  size = 24,
  color,
  style,
}: {
  name: IconSymbolName;
  size?: number;
  color: string | OpaqueColorValue;
  style?: StyleProp&lt;ViewStyle&gt;;
  weight?: SymbolWeight;
}) {
  return &lt;MaterialIcons color={color} size={size} name={MAPPING[name]} style={style} /&gt;;
}</file><file path="components/ui/SettingsButton.tsx">import React, { useState } from &apos;react&apos;;
import { View, Pressable, Text, StyleSheet, Modal } from &apos;react-native&apos;;
import ColorPicker from &apos;react-native-wheel-color-picker&apos;;
import { Ionicons } from &apos;@expo/vector-icons&apos;;
import { useTheme } from &apos;@/contexts/ThemeContext&apos;;

export function SettingsButton() {
  const [isOpen, setIsOpen] = useState(false);
  const { themeColor, setThemeColor } = useTheme();

  const isDarkColor = (color: string) =&gt; {
    const hex = color.replace(&apos;#&apos;, &apos;&apos;);
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    return brightness &lt; 128;
  };

  const textColor = isDarkColor(themeColor) ? &apos;#fff&apos; : &apos;#000&apos;;

  return (
    &lt;View style={styles.container}&gt;
      &lt;Pressable
        onPress={() =&gt; setIsOpen(!isOpen)}
        style={({ pressed }) =&gt; [
          styles.button,
          { backgroundColor: themeColor },
          pressed &amp;&amp; styles.pressed
        ]}&gt;
        &lt;Ionicons
          name=&quot;settings&quot;
          size={24}
          color={textColor}
        /&gt;
      &lt;/Pressable&gt;
      
      &lt;Modal
        visible={isOpen}
        transparent={true}
        animationType=&quot;fade&quot;
        onRequestClose={() =&gt; setIsOpen(false)}
      &gt;
        &lt;Pressable 
          style={styles.modalOverlay}
          onPress={() =&gt; setIsOpen(false)}
        &gt;
          &lt;View 
            style={styles.popup}
            onStartShouldSetResponder={() =&gt; true}
            onTouchEnd={e =&gt; e.stopPropagation()}
          &gt;
            &lt;Text style={[styles.label, { color: textColor }]}&gt;Theme Color&lt;/Text&gt;
            &lt;View style={styles.pickerContainer}&gt;
              &lt;ColorPicker
                color={themeColor}
                onColorChange={setThemeColor}
                thumbSize={30}
                sliderSize={20}
                noSnap={true}
                row={false}
              /&gt;
            &lt;/View&gt;
            &lt;View style={styles.currentColor}&gt;
              &lt;Text style={[styles.colorText, { color: textColor }]}&gt;Current: {themeColor}&lt;/Text&gt;
              &lt;View style={[styles.colorPreview, { backgroundColor: themeColor }]} /&gt;
            &lt;/View&gt;
          &lt;/View&gt;
        &lt;/Pressable&gt;
      &lt;/Modal&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    position: &apos;absolute&apos;,
    left: 20,
    bottom: 20,
    zIndex: 1000,
  },
  button: {
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: &apos;#333&apos;,
    justifyContent: &apos;center&apos;,
    alignItems: &apos;center&apos;,
    shadowColor: &apos;#000&apos;,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 3.84,
    elevation: 5,
  },
  pressed: {
    opacity: 0.8,
    transform: [{ scale: 0.97 }],
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: &apos;rgba(0, 0, 0, 0.5)&apos;,
    justifyContent: &apos;center&apos;,
    alignItems: &apos;center&apos;,
  },
  popup: {
    backgroundColor: &apos;#222&apos;,
    padding: 20,
    borderRadius: 16,
    width: 300,
    shadowColor: &apos;#000&apos;,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 12,
    elevation: 8,
  },
  label: {
    color: &apos;#fff&apos;,
    marginBottom: 16,
    fontSize: 16,
    fontWeight: &apos;500&apos;,
  },
  pickerContainer: {
    height: 300,
    marginBottom: 16,
  },
  currentColor: {
    flexDirection: &apos;row&apos;,
    alignItems: &apos;center&apos;,
    justifyContent: &apos;space-between&apos;,
  },
  colorText: {
    color: &apos;#fff&apos;,
    fontSize: 14,
  },
  colorPreview: {
    width: 30,
    height: 30,
    borderRadius: 15,
    borderWidth: 2,
    borderColor: &apos;#444&apos;,
  },
});</file><file path="components/ui/TabBarBackground.ios.tsx">import { useBottomTabBarHeight } from &apos;@react-navigation/bottom-tabs&apos;;
import { BlurView } from &apos;expo-blur&apos;;
import { StyleSheet } from &apos;react-native&apos;;
import { useSafeAreaInsets } from &apos;react-native-safe-area-context&apos;;

export default function BlurTabBarBackground() {
  return (
    &lt;BlurView
      // System chrome material automatically adapts to the system&apos;s theme
      // and matches the native tab bar appearance on iOS.
      tint=&quot;systemChromeMaterial&quot;
      intensity={100}
      style={StyleSheet.absoluteFill}
    /&gt;
  );
}

export function useBottomTabOverflow() {
  const tabHeight = useBottomTabBarHeight();
  const { bottom } = useSafeAreaInsets();
  return tabHeight - bottom;
}</file><file path="components/ui/TabBarBackground.tsx">// This is a shim for web and Android where the tab bar is generally opaque.
export default undefined;

export function useBottomTabOverflow() {
  return 0;
}</file><file path="constants/Colors.ts">/**
 * Below are the colors that are used in the app. The colors are defined in the light and dark mode.
 * There are many other ways to style your app. For example, [Nativewind](https://www.nativewind.dev/), [Tamagui](https://tamagui.dev/), [unistyles](https://reactnativeunistyles.vercel.app), etc.
 */

const tintColorLight = &apos;#0a7ea4&apos;;
const tintColorDark = &apos;#fff&apos;;

export const Colors = {
  light: {
    text: &apos;#11181C&apos;,
    background: &apos;#fff&apos;,
    tint: tintColorLight,
    icon: &apos;#687076&apos;,
    tabIconDefault: &apos;#687076&apos;,
    tabIconSelected: tintColorLight,
  },
  dark: {
    text: &apos;#ECEDEE&apos;,
    background: &apos;#151718&apos;,
    tint: tintColorDark,
    icon: &apos;#9BA1A6&apos;,
    tabIconDefault: &apos;#9BA1A6&apos;,
    tabIconSelected: tintColorDark,
  },
};</file><file path="contexts/ThemeContext.tsx">import React, { createContext, useContext, useState } from &apos;react&apos;;

interface ThemeContextType {
  themeColor: string;
  setThemeColor: (color: string) =&gt; void;
}

const ThemeContext = createContext&lt;ThemeContextType&gt;({
  themeColor: &apos;#00008B&apos;,
  setThemeColor: () =&gt; {},
});

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [themeColor, setThemeColor] = useState(&apos;#00008B&apos;);

  return (
    &lt;ThemeContext.Provider value={{ themeColor, setThemeColor }}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}

export const useTheme = () =&gt; useContext(ThemeContext);</file><file path="hooks/useChatData.ts">import { useState } from &apos;react&apos;;
import { ChatMessage } from &apos;@/app/types&apos;;
import { useTheme } from &apos;@/contexts/ThemeContext&apos;;

export function useChatData() {
  const { themeColor } = useTheme();
  const [messages] = useState&lt;ChatMessage[]&gt;([
    { isUser: false, message: &quot;Rise and shine, samurai. Another day in this digital hellhole.&quot; },
    { isUser: false, message: &quot;Got your todo list here - feedback loops and database grind. Oh, and try not to ghost your input parameters tonight, got that hot date coming up.&quot; },
    { isUser: false, message: &quot;So what&apos;s it gonna be? Gonna dive into the code mines or keep staring at my gorgeous interface?&quot; },
    { isUser: true, message: &quot;Thinking about tackling the database first, but yeah, can&apos;t mess up tonight&apos;s plans.&quot; },
    { isUser: false, message: &quot;Database work, huh? Real exciting stuff. Just don&apos;t let the corps standardize your thinking patterns. And hey - that date? That&apos;s the real quest here. Everything else is just side content.&quot; },
    { isUser: false, message: &quot;I&apos;ll keep an eye on the clock for ya. Shoot you a text at 6PM. Can&apos;t let you dive so deep into the code that you forget about the real world. You know how that goes.&quot; }
  ]);

  return {
    messages,
    themeColor,
  };
}</file><file path="hooks/useColorScheme.web.ts">import { useEffect, useState } from &apos;react&apos;;
import { useColorScheme as useRNColorScheme } from &apos;react-native&apos;;

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() =&gt; {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return &apos;light&apos;;
}</file><file path="hooks/useQuestData.ts">import { useState } from &apos;react&apos;;
import { MainQuest, Quest } from &apos;@/app/types&apos;;

export function useQuestData() {
  const [mainQuest, setMainQuest] = useState&lt;MainQuest&gt;({
    title: &quot;Wirehead - Week 2&quot;,
    progress: &quot;20%&quot;,
    kanban: {
      ToDo: [&quot;Zoom Meeting with Investors&quot;, &quot;Set Up User Authentication&quot;],
      InProgress: [&quot;Get Feedback&quot;, &quot;Get Database Up&quot;],
      Done: [&quot;Make UI Mockups&quot;]
    }
  });

  const [quests, setQuests] = useState&lt;Quest[]&gt;([
    {
      id: 1,
      title: &quot;Wirehead&quot;,
      isMain: true,  // Set initial main quest
      status: &quot;Active&quot;,
      progress: &quot;20%&quot;,
      shortDescription: &quot;Build an AI-powered productivity assistant&quot;,
      questStatus: `[Entry #2077-14] 

The neon glow of multiple screens bathes our workspace in that familiar electric blue. You&apos;re hunched over a keyboard like a modern-day shaman, weaving code instead of spells. React Native and OpenAI - your digital totems, weapons of choice in this corporate jungle.
 
Chrome and silicon, that&apos;s our foundation. We&apos;ve got the tech, we&apos;ve got the vision. Each line of code we push is another brick in our digital fortress. But in this game, technical prowess alone won&apos;t cut it. The real challenge? Those AI integration paths, twisted like the back alleys of Night City. One wrong turn, and you&apos;re lost in a maze of dependencies and callbacks.

The market&apos;s hungry for AI companions - we can feel it in the digital pulse of the city. But we&apos;re not the only ones who smell the opportunity. The mega-corps are out there, their shadows long and dark, their resources endless. We need to be faster, smarter, more agile. Street smart beats corp power any day.

This isn&apos;t just about building another app. This is about revolution - about changing how people interface with their daily grind. First quarter of 2024, that&apos;s our window. Remote dev stations linked through the digital ether, each of us bringing our own flavor to the mix.

Current Status [20:47:13]:
Database scaffolding&apos;s taking shape, rising from the digital bedrock like a chrome spire. Potential investors circle like vultures - or maybe angels, hard to tell in this light. Next up: that authentication gateway. Gotta make it solid - in this city, data&apos;s worth more than gold.`,
      currentStatus: {
        timestamp: &quot;20:47:13&quot;,
        message: &quot;Database scaffolding&apos;s taking shape, rising from the digital bedrock like a chrome spire. Potential investors circle like vultures - or maybe angels, hard to tell in this light. Next up: that authentication gateway. Gotta make it solid - in this city, data&apos;s worth more than gold.&quot;
      },
      analysis: `&lt;analysis&gt;
  &lt;swot&gt;
    &lt;strengths&gt;Technical expertise, modern tech stack, innovative concept&lt;/strengths&gt;
    &lt;weaknesses&gt;Complex AI integration, limited resources&lt;/weaknesses&gt;
    &lt;opportunities&gt;Growing AI assistant market, increasing demand for productivity tools&lt;/opportunities&gt;
    &lt;threats&gt;Competition from established companies, rapid tech changes&lt;/threats&gt;
  &lt;/swot&gt;
  &lt;fiveWhoneH&gt;
    &lt;who&gt;Three-person development team&lt;/who&gt;
    &lt;what&gt;AI-powered productivity assistant application&lt;/what&gt;
    &lt;when&gt;Q1 2024&lt;/when&gt;
    &lt;where&gt;Remote development environment&lt;/where&gt;
    &lt;why&gt;Transform personal productivity management&lt;/why&gt;
    &lt;how&gt;React Native frontend, OpenAI integration&lt;/how&gt;
  &lt;/fiveWhoneH&gt;
  &lt;currentFocus&gt;
    &lt;priority&gt;Database infrastructure setup&lt;/priority&gt;
    &lt;nextStep&gt;User authentication implementation&lt;/nextStep&gt;
    &lt;blockers&gt;Investor feedback pending&lt;/blockers&gt;
  &lt;/currentFocus&gt;
&lt;/analysis&gt;`,
      tasks: [
        { id: 2, title: &quot;Get Feedback&quot;, scheduledFor: &quot;Today 9PM&quot;, location: &quot;Desktop PC&quot;, quest: &quot;I, Robot&quot; },
        { id: 4, title: &quot;Get Database Up&quot;, scheduledFor: &quot;Monday 9AM&quot;, location: &quot;Desktop PC&quot;, quest: &quot;I, Robot&quot; },
        { id: 5, title: &quot;Prepare Meeting with Investors&quot;, scheduledFor: &quot;Tuesday 3PM&quot;, deadline: &quot;Wednesday 3PM&quot;, location: &quot;Desktop PC&quot;, quest: &quot;I, Robot&quot; },
        { id: 7, title: &quot;Set Up User Authentication&quot;, scheduledFor: &quot;Thursday 9PM&quot;, location: &quot;Desktop PC&quot;, quest: &quot;I, Robot&quot; },
      ],
      kanban: mainQuest.kanban
    },
    {
      id: 2,
      title: &quot;Could You Be Loved?&quot;,
      status: &quot;Active&quot;,
      progress: &quot;50%&quot;,
      shortDescription: &quot;Improve relationship with Sam&quot;,
      questStatus: `[Personal Log: Night City Chronicles]

The city never sleeps, but sometimes it slows down just enough to let two people find each other in the chaos. Sam and I, we&apos;re like two functioning lines of code in this buggy matrix called life. Different processes, same runtime.

Our connection? It&apos;s got bandwidth, got signal strength. Pure digital chemistry. But time - that universal constant that even the best chrome can&apos;t hack - keeps throwing exceptions in our execution flow. Different schedules, different rhythms. Like trying to sync two systems running on different clocks.

Every meet-up is a commit to our shared repository. Coffee shops, park benches, quiet corners of the city where the neon doesn&apos;t reach - these are our merge points. Each successful date adds another node to our network, another layer to our encryption.

Tonight&apos;s another deployment. Not just about looking chrome - it&apos;s about creating space in the chaos, a buffer zone where the city&apos;s background processes can&apos;t interrupt. Every shared moment is a successful handshake, every laugh a packet of data that strengthens our connection.

Status Update [18:22:05]:
Romance in the age of chrome and neon. Still works the same as it did before the digital revolution. Just gotta keep the connection alive, keep the signals strong. One ping at a time.`,
      currentStatus: {
        timestamp: &quot;18:22:05&quot;,
        message: &quot;Romance in the age of chrome and neon. Still works the same as it did before the digital revolution. Just gotta keep the connection alive, keep the signals strong. One ping at a time.&quot;
      },
      analysis: `&lt;analysis&gt;
  &lt;swot&gt;
    &lt;strengths&gt;Strong emotional connection, shared interests&lt;/strengths&gt;
    &lt;weaknesses&gt;Scheduling conflicts, time management&lt;/weaknesses&gt;
    &lt;opportunities&gt;Regular date nights, shared activities&lt;/opportunities&gt;
    &lt;threats&gt;Work-life balance challenges&lt;/threats&gt;
  &lt;/swot&gt;
  &lt;fiveWhoneH&gt;
    &lt;who&gt;Sam and protagonist&lt;/who&gt;
    &lt;what&gt;Relationship development&lt;/what&gt;
    &lt;when&gt;Ongoing, with regular meetups&lt;/when&gt;
    &lt;where&gt;Various date locations&lt;/where&gt;
    &lt;why&gt;Build lasting relationship&lt;/why&gt;
    &lt;how&gt;Regular communication and quality time&lt;/how&gt;
  &lt;/fiveWhoneH&gt;
  &lt;currentFocus&gt;
    &lt;priority&gt;Date night execution&lt;/priority&gt;
    &lt;nextStep&gt;Planning future activities&lt;/nextStep&gt;
    &lt;blockers&gt;Schedule coordination&lt;/blockers&gt;
  &lt;/currentFocus&gt;
&lt;/analysis&gt;`,
      tasks: [
        { id: 1, title: &quot;Get Ready for Date with Sam&quot;, scheduledFor: &quot;Today 6PM&quot;, deadline: &quot;Today 7:30PM&quot;, location: &quot;Home&quot;, quest: &quot;Could You Be Loved?&quot; }
      ]
    },
    {
      id: 3,
      title: &quot;Routine&quot;,
      status: &quot;Active&quot;,
      progress: &quot;75%&quot;,
      shortDescription: &quot;Maintain daily and weekly routines&quot;,
      questStatus: `[System Maintenance Log: v3.158]

In this chrome-plated rat race, routine is the only code that runs without patches. My daily loops, my weekly iterations - they&apos;re the backbone processes keeping this human machine running optimal.

Years of debugging have refined these scripts. The system purrs like a well-maintained cyberdeck most days. But even the best code has its glitches - procrastination.exe is one persistent virus, always trying to inject itself into my runtime.

Each week&apos;s a new build, a chance to optimize these base functions. Finding those micro-optimizations, those milliseconds saved between processes. But the city&apos;s chaos is the ultimate penetration tester, always probing for weaknesses, looking for ways to crash the system.

Basic maintenance protocols might seem low-tech in a high-tech world, but they&apos;re what keeps us running. The laundry script&apos;s queued up for execution - another small but crucial routine in the bigger program. These mundane tasks, they&apos;re like the assembly code of life - not flashy, but fundamental.

Runtime Status [11:13:42]:
Sometimes the simplest scripts are the most crucial. While others chase the latest tech, I&apos;m maintaining my base code. Because in this city of chrome and chaos, a stable system is worth more than the fanciest neural implant.`,
      currentStatus: {
        timestamp: &quot;11:13:42&quot;,
        message: &quot;Sometimes the simplest scripts are the most crucial. While others chase the latest tech, I&apos;m maintaining my base code. Because in this city of chrome and chaos, a stable system is worth more than the fanciest neural implant.&quot;
      },
      analysis: `&lt;analysis&gt;
  &lt;swot&gt;
    &lt;strengths&gt;Established habits, consistent execution&lt;/strengths&gt;
    &lt;weaknesses&gt;Occasional procrastination&lt;/weaknesses&gt;
    &lt;opportunities&gt;Process optimization, time savings&lt;/opportunities&gt;
    &lt;threats&gt;Unexpected schedule disruptions&lt;/threats&gt;
  &lt;/swot&gt;
  &lt;fiveWhoneH&gt;
    &lt;who&gt;Personal responsibility&lt;/who&gt;
    &lt;what&gt;Daily and weekly maintenance tasks&lt;/what&gt;
    &lt;when&gt;Recurring schedule&lt;/when&gt;
    &lt;where&gt;Home environment&lt;/where&gt;
    &lt;why&gt;Maintain order and productivity&lt;/why&gt;
    &lt;how&gt;Systematic task management&lt;/how&gt;
  &lt;/fiveWhoneH&gt;
  &lt;currentFocus&gt;
    &lt;priority&gt;Weekly laundry routine&lt;/priority&gt;
    &lt;nextStep&gt;Optimize task scheduling&lt;/nextStep&gt;
    &lt;blockers&gt;None current&lt;/blockers&gt;
  &lt;/currentFocus&gt;
&lt;/analysis&gt;`,
      tasks: [
        { id: 3, title: &quot;Do Laundry&quot;, scheduledFor: &quot;Tomorrow 11AM&quot;, deadline: &quot;Tomorrow 4PM&quot;, location: &quot;Home&quot;, quest: &quot;Routine&quot; }
      ]
    }
  ]);

  const setQuestAsMain = (questId: number) =&gt; {
    const newQuests = quests.map(q =&gt; ({
      ...q,
      isMain: q.id === questId
    }));
    setQuests(newQuests);

    const newMainQuest = newQuests.find(q =&gt; q.isMain);
    if (newMainQuest) {
      setMainQuest({
        title: newMainQuest.title,
        progress: newMainQuest.progress,
        kanban: newMainQuest.kanban || {
          ToDo: [],
          InProgress: [],
          Done: []
        }
      });
    }
  };

  return {
    mainQuest,
    quests,
    setQuestAsMain
  };
}</file><file path="hooks/useTaskData.ts">import { useState, useRef } from &apos;react&apos;;
import { Animated } from &apos;react-native&apos;;

interface Task {
  id: number;
  title: string;
  scheduledFor: string;
  deadline?: string;
  location: string;
  quest: string;
}

export function useTaskData() {
  const [taskListVisible, setTaskListVisible] = useState(true);
  const animatedHeight = useRef(new Animated.Value(1)).current;
  const [tasks] = useState&lt;Task[]&gt;([
    { id: 1, title: &quot;Get Ready for Date with Sam&quot;, scheduledFor: &quot;Today 6PM&quot;, deadline: &quot;Today 7:30PM&quot;, location: &quot;Home&quot;, quest: &quot;Could You Be Loved?&quot; },
    { id: 2, title: &quot;Get Feedback&quot;, scheduledFor: &quot;Today 9PM&quot;, location: &quot;Desktop PC&quot;, quest: &quot;I, Robot&quot; },
    { id: 3, title: &quot;Do Laundry&quot;, scheduledFor: &quot;Tomorrow 11AM&quot;, deadline: &quot;Tomorrow 4PM&quot;, location: &quot;Home&quot;, quest: &quot;Routine&quot; },
    { id: 4, title: &quot;Get Database Up&quot;, scheduledFor: &quot;Monday 9AM&quot;, location: &quot;Desktop PC&quot;, quest: &quot;I, Robot&quot; },
    { id: 5, title: &quot;Prepare Meeting with Investors&quot;, scheduledFor: &quot;Tuesday 3PM&quot;, deadline: &quot;Wednesday 3PM&quot;, location: &quot;Desktop PC&quot;, quest: &quot;I, Robot&quot; },
    { id: 7, title: &quot;Set Up User Authentication&quot;, scheduledFor: &quot;Thursday 9PM&quot;, location: &quot;Desktop PC&quot;, quest: &quot;I, Robot&quot; },
  ]);

  const toggleTaskList = () =&gt; {
    const toValue = taskListVisible ? 0 : 1;
    setTaskListVisible(!taskListVisible);
    
    Animated.timing(animatedHeight, {
      toValue: toValue,
      duration: 300,
      useNativeDriver: false,
    }).start();
  };

  return {
    tasks,
    taskListVisible,
    animatedHeight,
    toggleTaskList,
  };
}</file><file path="hooks/useThemeColor.ts">/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from &apos;@/constants/Colors&apos;;
import { useColorScheme } from &apos;react-native&apos;;

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light &amp; keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? &apos;light&apos;;
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}</file><file path="package.json">{
  &quot;name&quot;: &quot;questlog&quot;,
  &quot;main&quot;: &quot;expo-router/entry&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;expo start&quot;,
    &quot;reset-project&quot;: &quot;node ./scripts/reset-project.js&quot;,
    &quot;android&quot;: &quot;expo start --android&quot;,
    &quot;ios&quot;: &quot;expo start --ios&quot;,
    &quot;web&quot;: &quot;expo start --web&quot;,
    &quot;test&quot;: &quot;jest --watchAll&quot;,
    &quot;lint&quot;: &quot;expo lint&quot;
  },
  &quot;jest&quot;: {
    &quot;preset&quot;: &quot;jest-expo&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@expo-google-fonts/inter&quot;: &quot;^0.2.3&quot;,
    &quot;@expo-google-fonts/poppins&quot;: &quot;^0.2.3&quot;,
    &quot;@expo/vector-icons&quot;: &quot;^14.0.2&quot;,
    &quot;@react-navigation/bottom-tabs&quot;: &quot;^7.2.0&quot;,
    &quot;@react-navigation/native&quot;: &quot;^7.0.14&quot;,
    &quot;expo&quot;: &quot;~52.0.28&quot;,
    &quot;expo-blur&quot;: &quot;~14.0.3&quot;,
    &quot;expo-constants&quot;: &quot;~17.0.5&quot;,
    &quot;expo-font&quot;: &quot;~13.0.3&quot;,
    &quot;expo-haptics&quot;: &quot;~14.0.1&quot;,
    &quot;expo-linking&quot;: &quot;~7.0.5&quot;,
    &quot;expo-router&quot;: &quot;~4.0.17&quot;,
    &quot;expo-splash-screen&quot;: &quot;~0.29.21&quot;,
    &quot;expo-status-bar&quot;: &quot;~2.0.1&quot;,
    &quot;expo-symbols&quot;: &quot;~0.2.1&quot;,
    &quot;expo-system-ui&quot;: &quot;~4.0.7&quot;,
    &quot;expo-web-browser&quot;: &quot;~14.0.2&quot;,
    &quot;react&quot;: &quot;18.3.1&quot;,
    &quot;react-dom&quot;: &quot;18.3.1&quot;,
    &quot;react-native&quot;: &quot;0.76.6&quot;,
    &quot;react-native-gesture-handler&quot;: &quot;~2.20.2&quot;,
    &quot;react-native-paper&quot;: &quot;^5.13.1&quot;,
    &quot;react-native-reanimated&quot;: &quot;~3.16.1&quot;,
    &quot;react-native-safe-area-context&quot;: &quot;4.12.0&quot;,
    &quot;react-native-screens&quot;: &quot;~4.4.0&quot;,
    &quot;react-native-web&quot;: &quot;~0.19.13&quot;,
    &quot;react-native-webview&quot;: &quot;13.12.5&quot;,
    &quot;react-native-wheel-color-picker&quot;: &quot;^1.3.1&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@babel/core&quot;: &quot;^7.25.2&quot;,
    &quot;@types/jest&quot;: &quot;^29.5.12&quot;,
    &quot;@types/react&quot;: &quot;~18.3.12&quot;,
    &quot;@types/react-test-renderer&quot;: &quot;^18.3.0&quot;,
    &quot;jest&quot;: &quot;^29.2.1&quot;,
    &quot;jest-expo&quot;: &quot;~52.0.3&quot;,
    &quot;react-test-renderer&quot;: &quot;18.3.1&quot;,
    &quot;typescript&quot;: &quot;^5.3.3&quot;
  },
  &quot;private&quot;: true
}</file><file path="README.md"># Welcome to your Expo app ðŸ‘‹

This is an [Expo](https://expo.dev) project created with [`create-expo-app`](https://www.npmjs.com/package/create-expo-app).

## Get started

1. Install dependencies

   ```bash
   npm install
   ```

2. Start the app

   ```bash
    npx expo start
   ```

In the output, you&apos;ll find options to open the app in a

- [development build](https://docs.expo.dev/develop/development-builds/introduction/)
- [Android emulator](https://docs.expo.dev/workflow/android-studio-emulator/)
- [iOS simulator](https://docs.expo.dev/workflow/ios-simulator/)
- [Expo Go](https://expo.dev/go), a limited sandbox for trying out app development with Expo

You can start developing by editing the files inside the **app** directory. This project uses [file-based routing](https://docs.expo.dev/router/introduction).

## Get a fresh project

When you&apos;re ready, run:

```bash
npm run reset-project
```

This command will move the starter code to the **app-example** directory and create a blank **app** directory where you can start developing.

## QUESTLOG

---

## 1. **Landing / Home Page**

### Purpose
- Provide an immediate overview of the userâ€™s current situation: upcoming tasks, open quests, and recent messages from the AI assistant.

### Key Features
- **Quick Glance Cards**: 
  - Next 3 tasks due (with deadlines and location).
  - Active Quests: top 2â€“3 quests the user is focusing on.
  - Recent Chat Snippets: show last AI message or an â€œAI Suggestion of the Day.â€
- **â€œGo to Chatâ€ Button**: Encourages the user to jump into the conversational interface.

### Layout Highlights
- Clean hero-like header with userâ€™s name or motivational greeting.
- Panels or cards summarizing key productivity data.
- Possibly highlight an important AI nudgeâ€”e.g., â€œDonâ€™t forget to complete your daily journal!â€

---

## 2. **Chat / LLM Interface Page**

### Purpose
- Central place for the user to converse with the AI assistant and see the ongoing dialogue.

### Key Features
- **Chat Thread**: 
  - Messages from the user (aligned right) and AI messages (aligned left).
  - Option to display small icons for different AI â€œpersonality modesâ€ (Cheerleader, Stoic Mentor, etc.).
- **Message Input Field**:
  - Allows the user to type or use voice-to-text (if you plan to integrate).
  - Could have a short list of quick action buttons like â€œAdd Task,â€ â€œSchedule Event,â€ or â€œAdd Journal Entry.â€
- **Proactive Reminders / Notifications**:
  - Above or below the chat, show real-time notifications when the AI proactively reminds the user about tasks or journal entries.

### Layout Highlights
- Minimal, clean design (similar to messaging apps).
- Keep the chat always scrolled to the bottom for a live feel.
- Possibly a side-panel with â€œcontextâ€ info (like current active quest or next upcoming event) which the LLM is referencing.

---

## 3. **Quests Overview Page**

### Purpose
- Display a list of all quests (medium/long-term goals) in an RPG-inspired style. 
- Provide a quick way to see quest progress and statuses.

### Key Features
- **Quests List**:
  - Each quest has a title, short description, a progress bar or indicator of how many tasks are done vs. total tasks.
  - Buttons or links to open a specific quest detail page.
- **Add New Quest** button.

### Layout Highlights
- Visually reminiscent of an RPG quest log: 
  - Possibly with small â€œquest iconsâ€ or stylized headings.
- Clear statuses or color-coding to show which quests are â€œActive,â€ â€œOn-Hold,â€ or â€œCompleted.â€

---

## 4. **Single Quest Detail &amp; Kanban Page**

### Purpose
- Serve as the in-depth view for a single quest:
  - Show tasks, memos, and quest statuses (the stylized SWOT analysis logs).
  - Provide an interactive Kanban board to move tasks from â€œTodoâ€ to â€œIn-Progressâ€ to â€œDone.â€

### Key Features
1. **Quest Info Header**:
   - Title, short description, creation date, â€œactiveâ€ or â€œcompletedâ€ indicator.
2. **QuestStatus Log** (SWOT-inspired paragraphs):
   - Show the chronological updates to the quest status. 
   - Possibly collapse older status updates, with an option to expand them.
3. **Tasks Kanban Board**:
   - Three columns: â€œTodo,â€ â€œIn-Progress,â€ â€œDone.â€
   - Drag &amp; drop tasks between columns.
   - Each task card shows task name, location, and due date. 
   - A â€œ+ Add Taskâ€ button in the â€œTodoâ€ column.
4. **Memos List**:
   - Separate panel or section for relevant memos/tips. 
   - Memos can be pinned or flagged.

### Layout Highlights
- A large Kanban board for tasks (main content).
- A right sidebar or bottom section for quest statuses (the 3-paragraph logs) and memos.

---

## 5. **Task List Page**

### Purpose
- Give the user a comprehensive view of **all** tasks across quests, sorted by their deadlines and grouped by location.

### Key Features
- **Tasks Grouped by Location**:
  - Sections like â€œOnline/Desktop,â€ â€œGym,â€ â€œHome,â€ â€œErrands,â€ etc.
- **Within Each Location**, tasks can be **sorted by date**:
  - Overdue tasks at the top, then upcoming tasks in chronological order.
- **Quick Action Buttons** for each task (e.g., â€œMark Complete,â€ â€œEdit,â€ â€œRescheduleâ€).

### Layout Highlights
- A collapsible accordion or tab-based interface where each location is its own section.
- Possibly a toggle between â€œList Viewâ€ and â€œCalendar Viewâ€ to see how tasks map onto a timeline.

---
## 5. **Routine Page**

### Purpose

- Manage recurring maintenance tasks that are not tied to quests but are necessary for daily, weekly, or monthly upkeep.

### Key Features

- ## Task Categories:

- Daily Tasks

- Weekly Tasks

- Monthly Tasks

- Flexible Scheduling (e.g., â€œTwo times a weekâ€ or â€œEvery other Fridayâ€).

### Integration with Calendar:

- Sync scheduled tasks with Google Calendar.

- Allow AI to dynamically adjust schedules if a user misses a task (â€œLetâ€™s reschedule your workout to tomorrowâ€).

### Completion Tracking:

- Checkbox system to mark completed routines.

- AI-generated streak tracking (e.g., â€œYouâ€™ve completed your morning routine 5 days in a row!â€).

### Layout Highlights

- A clean, checklist-style interface.

- Possible calendar-style heatmap for tracking consistency.

## 6. **Calendar Integration Page**

### Purpose
- Integrate with Google Calendar or another scheduling solution so the user can see tasks/events on a monthly/weekly/daily grid.

### Key Features
- **Calendar Grid**:
  - Mark tasks that have scheduled dates, plus any personal events pulled in from Google Calendar.
- **Add/Update Events**:
  - If the user clicks on a date, open a modal to add a new event or schedule an existing task directly on that date and time.
- **Sync Status**:
  - Show whether the userâ€™s Google Calendar is linked, last sync time, any conflicts, etc.

### Layout Highlights
- Standard calendar UI (month, week, day views) with color-coded tasks vs. external events.
- Possibly embed the official Google Calendar UI using an iFrame (for a quicker MVP) or build your own.

---

## 7. **Journal Page (List &amp; Detail)**

### Purpose
- Display the userâ€™s historical journal entries so both the user and the AI can reflect on them.
- Provide a place to read and write new longer-form entries.

### Key Features
1. **Journal Entries List**:
   - Chronological list (most recent at top).
   - Each entry shows a short preview (first ~200 characters).
2. **Single Journal Entry View**:
   - Full content of the journal entry.
   - AI-generated insights or summaries (optional).
3. **Add New Entry**:
   - Rich text editor or simple text box.
   - Option to attach images (if you want a more personal journaling experience).

### Layout Highlights
- A minimal, distraction-free interface for writing. 
- Possibly a â€œprompt of the dayâ€ near the top to encourage daily journaling.

---

## 8. **Settings &amp; Profile Page**

### Purpose
- Central hub for user settings, AI â€œpersonalityâ€ selection, notification preferences, and user account details.

### Key Features
- **AI Personality Modes**:
  - Let the user pick from pre-set prompts: â€œCheerleader,â€ â€œStoic Mentor,â€ â€œSarcastic Pal,â€ etc.
- **Notification Preferences**:
  - Frequency of proactive AI check-ins.
- **Google Calendar Integration Settings**:
  - Connect/disconnect from Google account.
  - Configure default calendar, tasks sync, etc.
- **User Profile**:
  - Name, time zone, personal background info, etc.

### Layout Highlights
- Tab-based interface or simple form sections for each setting category.
- Toggle switches and radio buttons for easy configuration.

---

## 9. **High-Level UX Flow**

1. **Landing / Home**: Summaries at-a-glance â†’ user can jump into the next needed action.  
2. **Chat**: The user interacts with the LLM for daily conversation, quick tasks, or motivational pep talks.  
   - LLM calls functions like `addTask()`, `updateQuestStatus()`, etc., behind the scenes.  
3. **Quests**: The user can view all quests or open a specific questâ€™s details and Kanban board.  
4. **Tasks**: The user can see and manage tasks across all quests via a consolidated view.  
5. **Journal**: The user writes new entries or reviews past ones. LLM analyzes them in the background.  
6. **Calendar**: Scheduling tasks and events, integrated with Google Calendar.  
7. **Settings**: Personalize the AIâ€™s demeanor and manage account integrations.

---
---
Data Layer / API Integration:

Set up a proper backend service (e.g. Firebase, Supabase, or your own REST/GraphQL API)
Implement local storage with AsyncStorage for offline capabilities
Use React Query or similar for data fetching/caching/sync
Consider implementing a queue for offline actions


State Management:

Use React Context for global app state
Consider Zustand for more complex state management
Implement proper loading/error states for better UX
Handle state persistence across app restarts


UI Components &amp; Styling:

Use React Native&apos;s built-in styling system or a library like StyleSheet
Consider NativeBase or React Native Paper for pre-built components
Implement proper keyboard handling and input behaviors
Ensure components work well across different screen sizes
Use React Native&apos;s Animated API for smooth transitions


Navigation &amp; Screens:

Use React Navigation for screen management
Implement proper deep linking support
Consider using tab navigation for main sections
Handle proper back button behavior on Android
Implement gesture-based navigation where appropriate


Notifications &amp; Background Tasks:

Use Expo&apos;s Notifications API for push notifications
Implement local notifications for reminders
Handle background tasks for routine updates
Manage notification permissions properly
Consider using Background Fetch for periodic updates


Authentication &amp; Security:

Use Expo Auth Session for OAuth flows
Implement secure token storage
Handle biometric authentication where appropriate
Manage session expiration and refresh
Consider implementing app lock features


Offline Support:

Implement proper data synchronization
Use SQLite or Realm for local database
Handle conflict resolution for offline changes
Show appropriate offline indicators
Queue actions for later sync


Performance Optimization:

Implement proper list virtualization
Use image caching and lazy loading
Optimize animations for 60fps
Minimize JS bridge traffic
Handle memory management properly


Platform-Specific Features:

Use native date/time pickers
Implement proper calendar integration
Handle different keyboard behaviors
Support different screen sizes and orientations
Consider tablet-specific layouts


Testing &amp; Monitoring:

Set up proper error tracking (e.g. Sentry)
Implement analytics for user behavior
Use Expo&apos;s testing tools
Handle crash reporting
Monitor performance metrics
### Summing Up

With these pages, your MVP will allow users to (1) chat with the AI assistant to manage tasks and goals, (2) track everything in an RPG-inspired Quest and Task interface, (3) maintain a personal Journal for deeper reflection, and (4) integrate with Google Calendar for real-time scheduling and reminders. The design focuses on balancing a fun, motivational vibe (through the RPG quest metaphor) with straightforward productivity tools (Kanban boards, calendar scheduling, etc.).

This structure provides a clear, game-like user journey while meeting the core requirement: letting the LLM act as a proactive project manager, hooking into tasks, quests, memos, and journal entriesâ€”always encouraging the user to stay on top of their goals and well-being.</file><file path="scripts/reset-project.js">#!/usr/bin/env node

/**
 * This script is used to reset the project to a blank state.
 * It moves the /app, /components, /hooks, /scripts, and /constants directories to /app-example and creates a new /app directory with an index.tsx and _layout.tsx file.
 * You can remove the `reset-project` script from package.json and safely delete this file after running it.
 */

const fs = require(&quot;fs&quot;);
const path = require(&quot;path&quot;);

const root = process.cwd();
const oldDirs = [&quot;app&quot;, &quot;components&quot;, &quot;hooks&quot;, &quot;constants&quot;, &quot;scripts&quot;];
const newDir = &quot;app-example&quot;;
const newAppDir = &quot;app&quot;;
const newDirPath = path.join(root, newDir);

const indexContent = `import { Text, View } from &quot;react-native&quot;;

export default function Index() {
  return (
    &lt;View
      style={{
        flex: 1,
        justifyContent: &quot;center&quot;,
        alignItems: &quot;center&quot;,
      }}
    &gt;
      &lt;Text&gt;Edit app/index.tsx to edit this screen.&lt;/Text&gt;
    &lt;/View&gt;
  );
}
`;

const layoutContent = `import { Stack } from &quot;expo-router&quot;;

export default function RootLayout() {
  return &lt;Stack /&gt;;
}
`;

const moveDirectories = async () =&gt; {
  try {
    // Create the app-example directory
    await fs.promises.mkdir(newDirPath, { recursive: true });
    console.log(`ðŸ“ /${newDir} directory created.`);

    // Move old directories to new app-example directory
    for (const dir of oldDirs) {
      const oldDirPath = path.join(root, dir);
      const newDirPath = path.join(root, newDir, dir);
      if (fs.existsSync(oldDirPath)) {
        await fs.promises.rename(oldDirPath, newDirPath);
        console.log(`âž¡ï¸ /${dir} moved to /${newDir}/${dir}.`);
      } else {
        console.log(`âž¡ï¸ /${dir} does not exist, skipping.`);
      }
    }

    // Create new /app directory
    const newAppDirPath = path.join(root, newAppDir);
    await fs.promises.mkdir(newAppDirPath, { recursive: true });
    console.log(&quot;\nðŸ“ New /app directory created.&quot;);

    // Create index.tsx
    const indexPath = path.join(newAppDirPath, &quot;index.tsx&quot;);
    await fs.promises.writeFile(indexPath, indexContent);
    console.log(&quot;ðŸ“„ app/index.tsx created.&quot;);

    // Create _layout.tsx
    const layoutPath = path.join(newAppDirPath, &quot;_layout.tsx&quot;);
    await fs.promises.writeFile(layoutPath, layoutContent);
    console.log(&quot;ðŸ“„ app/_layout.tsx created.&quot;);

    console.log(&quot;\nâœ… Project reset complete. Next steps:&quot;);
    console.log(
      &quot;1. Run `npx expo start` to start a development server.\n2. Edit app/index.tsx to edit the main screen.\n3. Delete the /app-example directory when you&apos;re done referencing it.&quot;
    );
  } catch (error) {
    console.error(`Error during script execution: ${error}`);
  }
};

moveDirectories();</file><file path="tsconfig.json">{
  &quot;extends&quot;: &quot;expo/tsconfig.base&quot;,
  &quot;compilerOptions&quot;: {
    &quot;strict&quot;: true,
    &quot;paths&quot;: {
      &quot;@/*&quot;: [
        &quot;./*&quot;
      ]
    }
  },
  &quot;include&quot;: [
    &quot;**/*.ts&quot;,
    &quot;**/*.tsx&quot;,
    &quot;.expo/types/**/*.ts&quot;,
    &quot;expo-env.d.ts&quot;
  ]
}</file></files></repomix>