# Current Task: Refactor Suggestion & Task Update Logic to Use Checkups

**Objective:** Modify the system so that task/quest suggestions and task status updates are generated by analyzing `CheckupEntry` content (including manual, chat-generated, and voice-transcribed entries) instead of raw chat messages. Introduce a dedicated `UpdateAgent` for handling status updates.

**Status:** Planning Complete. Implementation starting.

**Core Requirements:**
1.  **Checkup as Source:** All suggestion generation (tasks, quests) must originate from analyzing the `content` field of a saved `CheckupEntry`.
2.  **Status Updates from Checkups:** Detecting user intent to mark tasks as 'InProgress' or 'Done' must also originate from analyzing `CheckupEntry.content`.
3.  **New Update Agent:** Create a dedicated agent (`UpdateAgent`) responsible solely for detecting and applying task status updates based on checkup analysis.
4.  **Concurrent Processing:** After a checkup is saved, trigger both the suggestion analysis (`SuggestionAgent`) and the status update analysis (`UpdateAgent`) concurrently.
5.  **Deprecate Old Logic:** Remove or disable the previous logic in `SuggestionAgent` that analyzed full chat conversations (`analyzeConversation`).

**Detailed Implementation Plan:**

**Phase 1: Create `UpdateAgent`**

1.  **Create File:** Create `services/agents/UpdateAgent.ts`.
2.  **Define Class:** Define `UpdateAgent` class (potentially as a singleton similar to `SuggestionAgent`).
3.  **Import Dependencies:** Import necessary types (`Task`, `TaskStatusChangeResult`), services (`tasksService`, `personalityService`), and AI clients (e.g., `GoogleGenerativeAI`).
4.  **Move Logic:**
    *   Copy the core logic from `SuggestionAgent.detectTaskStatusChangeIntent` (or the most recent version of status detection logic) into a new primary method within `UpdateAgent`, named `processCheckupForStatusUpdates`.
    *   Signature: `async processCheckupForStatusUpdates(checkupContent: string, userId: string, activeTasks?: Task[]): Promise<void>` (or return the updated task if needed elsewhere).
5.  **Refine Logic:**
    *   Ensure the method fetches active tasks (`fetchActiveTasks`) if not provided.
    *   Use an appropriate LLM (e.g., Gemini Flash) with a prompt focused *only* on detecting 'Done' or 'InProgress' status changes based on `checkupContent` and the list of `activeTasks`.
    *   The prompt should request a structured JSON output similar to the existing `TaskStatusChangeResult`.
    *   Implement robust validation:
        *   Check confidence score (> 0.88).
        *   Verify the detected `existingTaskId` exists in the `activeTasks` list.
        *   Validate the status transition (ToDo -> InProgress, ToDo/InProgress -> Done).
    *   If a valid, high-confidence change is detected, call `tasksService.updateTask` with the `existingTaskId` and the `newStatus`.
    *   Add clear logging for detected changes, validation failures, and successful updates.

**Phase 2: Refactor `SuggestionAgent`**

1.  **New Method:** Create `async analyzeCheckupForSuggestions(checkupContent: string, userId: string): Promise<void>` in `SuggestionAgent.ts`.
2.  **Adapt Prompt:**
    *   Take the core LLM prompt logic from the *current* `analyzeConversation` method.
    *   Modify the prompt to analyze the single `checkupContent` string instead of `conversation.messages`.
    *   The prompt should instruct the LLM to identify potential new Quests and Tasks (standalone or associated with *newly suggested* Quests in the same response) based *only* on the `checkupContent`.
    *   Maintain the structured JSON output format (e.g., `suggestedQuests` with `associatedTasks`, `standaloneTasks`).
3.  **Integrate Helpers:** Ensure `analyzeCheckupForSuggestions` correctly calls existing helper methods after parsing the LLM response:
    *   `checkForDuplicatesBeforeShowing`
    *   `findBestQuestForTask` (for standalone tasks)
    *   `convertToEditSuggestion`
    *   `regenerateTaskWithContinuationContext`
    *   Ensure suggestions are added to `globalSuggestionStore`.
4.  **Deprecate/Remove:**
    *   Remove the `analyzeConversation` method entirely.
    *   Remove the `detectTaskStatusChangeIntent`/`detectTaskStatusChange` method (logic moved to `UpdateAgent`).
    *   Remove any helper methods solely used by the removed methods (e.g., `identifyTaskGroups`, `identifyQuestPatterns` if they were only for `analyzeConversation`).

**Phase 3: Integrate into Checkup Saving Flow**

1.  **Identify Trigger Point:** Locate the code block where `CheckupEntry` objects are successfully saved to the database. This is likely within `services/journalService.ts` (e.g., in `saveCheckupEntry` or a related function called by `useJournal`).
2.  **Modify Flow:**
    *   After the `await db.insert(...)` or equivalent call for saving the checkup succeeds:
        *   Retrieve the saved `checkupContent` and `userId`.
        *   Instantiate or get instances of `SuggestionAgent` and `UpdateAgent`.
        *   **(Optimization):** Fetch the user's active tasks *once*: `const activeTasks = await fetchActiveTasks(userId);`
        *   Use `Promise.allSettled` to run both agents concurrently:
            ```typescript
            const updateAgent = UpdateAgent.getInstance(); // Assuming singleton
            const suggestionAgent = SuggestionAgent.getInstance(); // Assuming singleton

            const [updateResult, suggestionResult] = await Promise.allSettled([
              updateAgent.processCheckupForStatusUpdates(checkupContent, userId, activeTasks),
              suggestionAgent.analyzeCheckupForSuggestions(checkupContent, userId) // Suggestion agent might fetch tasks internally if needed for context/duplicates
            ]);

            // Log results/errors from each promise
            if (updateResult.status === 'rejected') {
              console.error("UpdateAgent failed:", updateResult.reason);
            }
            if (suggestionResult.status === 'rejected') {
              console.error("SuggestionAgent failed:", suggestionResult.reason);
            }
            ```
    *   Ensure this concurrent processing does not block the primary function (saving the checkup) from returning successfully to the UI.

**Phase 4: Documentation & Cleanup**

1.  **Update Memory Bank:**
    *   Modify `memory-bank/systemPatterns.md`: Add `UpdateAgent`, update the description of `SuggestionAgent`, and revise the checkup processing flow diagram/description.
    *   Update `memory-bank/activeContext.md`: Reflect that this refactoring is the current focus, mentioning the shift to checkup-based analysis and the new agent.
2.  **Code Comments:** Add comments explaining the new flow, the purpose of `UpdateAgent`, and the reasoning behind the refactoring in relevant files (`UpdateAgent.ts`, `SuggestionAgent.ts`, `journalService.ts`).
3.  **Remove Obsolete Code:** Delete any functions or helper methods that are no longer used after the refactoring.

**Testing Considerations:**
*   Test with various checkup inputs (manual, chat-generated, voice-transcribed).
*   Verify task status updates (ToDo -> InProgress, InProgress -> Done, ToDo -> Done).
*   Verify suggestion generation (new tasks, new quests, standalone tasks, edit suggestions, continuation suggestions).
*   Confirm that both processes run concurrently after checkup save.
*   Check logs for correct execution and error handling.

**Next Steps:**
*   Proceed with Phase 1: Create `UpdateAgent`.
